"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/workflows/datasets",{

/***/ "(pages-dir-browser)/./pages/workflows/datasets.md":
/*!*************************************!*\
  !*** ./pages/workflows/datasets.md ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __N_SSG: () => (/* binding */ __N_SSG),\n/* harmony export */   \"default\": () => (/* binding */ MarkdocComponent),\n/* harmony export */   markdoc: () => (/* binding */ markdoc)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-yaml */ \"(pages-dir-browser)/./node_modules/js-yaml/dist/js-yaml.mjs\");\n/* harmony import */ var _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @markdoc/markdoc */ \"(pages-dir-browser)/./node_modules/@markdoc/markdoc/dist/index.mjs\");\n/* harmony import */ var _markdoc_next_js_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @markdoc/next.js/runtime */ \"(pages-dir-browser)/./node_modules/@markdoc/next.js/src/runtime.js\");\n/* harmony import */ var _Users_maxlund_projects_floze_docs_markdoc_tags_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./markdoc/tags.js */ \"(pages-dir-browser)/./markdoc/tags.js\");\n/* harmony import */ var _Users_maxlund_projects_floze_docs_markdoc_nodes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./markdoc/nodes.js */ \"(pages-dir-browser)/./markdoc/nodes.js\");\n\n\n// renderers is imported separately so Markdoc isn't sent to the client\n\n\n/**\n * Schema is imported like this so end-user's code is compiled using build-in babel/webpack configs.\n * This enables typescript/ESnext support\n */ const config = {};\n\n\nconst functions = {};\nconst schema = {\n    tags: (0,_markdoc_next_js_runtime__WEBPACK_IMPORTED_MODULE_2__.defaultObject)(_Users_maxlund_projects_floze_docs_markdoc_tags_js__WEBPACK_IMPORTED_MODULE_3__),\n    nodes: (0,_markdoc_next_js_runtime__WEBPACK_IMPORTED_MODULE_2__.defaultObject)(_Users_maxlund_projects_floze_docs_markdoc_nodes_js__WEBPACK_IMPORTED_MODULE_4__),\n    functions: (0,_markdoc_next_js_runtime__WEBPACK_IMPORTED_MODULE_2__.defaultObject)(functions),\n    ...(0,_markdoc_next_js_runtime__WEBPACK_IMPORTED_MODULE_2__.defaultObject)(config)\n};\nconst tokenizer = new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_5__[\"default\"].Tokenizer({\n    \"allowComments\": true\n});\n/**\n * Source will never change at runtime, so parse happens at the file root\n */ const source = \"---\\ntitle: Datasets\\n---\\n\\n# Datasets\\n\\nDatasets are collections of items that tasks can iterate over.\\n\\n## Defining Datasets\\n\\n```hcl\\nworkflow \\\"process_cities\\\" {\\n  dataset \\\"city_list\\\" {\\n    description = \\\"Cities to process\\\"\\n\\n    schema {\\n      field \\\"name\\\"  { type = \\\"string\\\"; required = true }\\n      field \\\"state\\\" { type = \\\"string\\\" }\\n    }\\n  }\\n\\n  # Tasks can iterate over this dataset\\n}\\n```\\n\\n## Attributes\\n\\n| Attribute | Type | Description |\\n|-----------|------|-------------|\\n| `description` | string | Documentation for the dataset |\\n| `schema` | block | Optional schema for validating items |\\n\\n## Schema Definition\\n\\nDefine expected fields:\\n\\n```hcl\\nschema {\\n  field \\\"id\\\" {\\n    type     = \\\"integer\\\"\\n    required = true\\n  }\\n\\n  field \\\"name\\\" {\\n    type     = \\\"string\\\"\\n    required = true\\n  }\\n\\n  field \\\"metadata\\\" {\\n    type = \\\"object\\\"\\n  }\\n}\\n```\\n\\n### Field Types\\n\\n- `string`\\n- `number`\\n- `integer`\\n- `boolean`\\n- `array`\\n- `object`\\n\\n## Populating Datasets\\n\\nDatasets can be populated in three ways:\\n\\n### 1. Bind to Workflow Input\\n\\n```hcl\\nworkflow \\\"process\\\" {\\n  input \\\"items\\\" {\\n    type = \\\"list\\\"\\n  }\\n\\n  dataset \\\"item_list\\\" {\\n    bind_to = inputs.items\\n  }\\n}\\n```\\n\\n### 2. Default Values\\n\\n```hcl\\ndataset \\\"regions\\\" {\\n  default = [\\n    { name = \\\"us-east-1\\\" },\\n    { name = \\\"us-west-2\\\" },\\n    { name = \\\"eu-west-1\\\" }\\n  ]\\n}\\n```\\n\\n### 3. Dynamic Population\\n\\nAgents can populate datasets at runtime using the `set_dataset` tool:\\n\\n```hcl\\ntask \\\"load_data\\\" {\\n  objective = \\\"Read cities from data.json and populate the city_list dataset\\\"\\n}\\n\\ntask \\\"process_cities\\\" {\\n  depends_on = [tasks.load_data]\\n  iterator {\\n    dataset = datasets.city_list\\n  }\\n}\\n```\\n\\n## Dataset Tools\\n\\nWhen running in a workflow, agents automatically have access to:\\n\\n- **set_dataset** - Populate a dataset with items\\n- **dataset_sample** - Get sample items from a dataset\\n- **dataset_count** - Get the number of items in a dataset\\n\\n### set_dataset\\n\\n```json\\n{\\n  \\\"name\\\": \\\"city_list\\\",\\n  \\\"items\\\": [\\n    {\\\"name\\\": \\\"Chicago\\\", \\\"state\\\": \\\"IL\\\"},\\n    {\\\"name\\\": \\\"Detroit\\\", \\\"state\\\": \\\"MI\\\"}\\n  ]\\n}\\n```\\n\\n### dataset_sample\\n\\n```json\\n{\\n  \\\"name\\\": \\\"city_list\\\",\\n  \\\"count\\\": 3\\n}\\n```\\n\\n### dataset_count\\n\\n```json\\n{\\n  \\\"name\\\": \\\"city_list\\\"\\n}\\n```\\n\\n## Schema Validation\\n\\nWhen a schema is defined, all items are validated:\\n\\n```hcl\\ndataset \\\"users\\\" {\\n  schema {\\n    field \\\"email\\\" { type = \\\"string\\\"; required = true }\\n  }\\n}\\n```\\n\\nSetting an item without `email` will fail validation.\\n\\n## Large Result Handling\\n\\nWhen tools return large results (>8KB), Squad automatically protects context by:\\n\\n1. Storing the full result outside LLM context\\n2. Returning a sample/summary to the LLM\\n3. Providing tools for the LLM to access more data as needed\\n\\nThis prevents context overflow while preserving full access to the data.\\n\\n### How It Works\\n\\n```\\nTool returns large JSON array (500 items)\\n         │\\n         ▼\\n   Intercepted & stored\\n         │\\n         ▼\\nLLM sees:\\n  <OBSERVATION>\\n  [{...}, {...}, ...]  (sample)\\n  </OBSERVATION>\\n  <OBSERVATION_METADATA>\\n  type: array\\n  id: _result_http_get_1\\n  partial: true\\n  total_items: 500\\n  shown_items: 5\\n  </OBSERVATION_METADATA>\\n```\\n\\n### Result Tools\\n\\nWhen a large result is intercepted, the LLM can use these tools:\\n\\n| Tool | Purpose |\\n|------|---------|\\n| `result_info` | Get type and size of stored result |\\n| `result_items` | Get items from array by offset/count |\\n| `result_get` | Navigate object with dot path (e.g., `users.0.name`) |\\n| `result_keys` | Get keys of an object |\\n| `result_chunk` | Get text by offset/length |\\n\\n### Promoting to Datasets\\n\\nUse `result_to_dataset` to convert a large array result into a dataset for iteration:\\n\\n```json\\n{\\n  \\\"id\\\": \\\"_result_http_get_1\\\",\\n  \\\"dataset_name\\\": \\\"users\\\"\\n}\\n```\\n\\nAfter promotion, the data is available via standard dataset tools and can be iterated with `for_each`.\\n\\n### Example Flow\\n\\n1. Agent calls `http_get` → returns 500 users\\n2. Interceptor stores full array, LLM sees sample of 5\\n3. LLM examines sample, decides this is useful\\n4. LLM calls `result_to_dataset(\\\"_result_http_get_1\\\", \\\"users\\\")`\\n5. Subsequent task iterates: `for_each = datasets.users`\\n\\n## See Also\\n\\n- [Iteration](/workflows/iteration) - Process datasets in tasks\\n\";\nconst tokens = tokenizer.tokenize(source);\nconst parseOptions = {\n    \"slots\": false\n};\nconst ast = _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parse(tokens, parseOptions);\n/**\n * Like the AST, frontmatter won't change at runtime, so it is loaded at file root.\n * This unblocks future features, such a per-page dataFetchingFunction.\n */ const frontmatter = ast.attributes.frontmatter ? js_yaml__WEBPACK_IMPORTED_MODULE_1__[\"default\"].load(ast.attributes.frontmatter) : {};\nconst { components } = (0,_markdoc_next_js_runtime__WEBPACK_IMPORTED_MODULE_2__.getSchema)(schema);\nvar __N_SSG = true;\nconst markdoc = {\n    frontmatter\n};\nfunction MarkdocComponent(props) {\n    const markdoc = props.markdoc;\n    // Only execute HMR code in development\n    return _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_5__.renderers.react(markdoc.content, (react__WEBPACK_IMPORTED_MODULE_0___default()), {\n        components: {\n            ...components,\n            // Allows users to override default components at runtime, via their _app\n            ...props.components\n        }\n    });\n}\n_c = MarkdocComponent;\nvar _c;\n$RefreshReg$(_c, \"MarkdocComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL3dvcmtmbG93cy9kYXRhc2V0cy5tZCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ0M7QUFDM0IsdUVBQXVFO0FBQ3BCO0FBRWU7QUFDbEU7OztDQUdDLEdBQ0QsTUFBTU0sU0FBUyxDQUFDO0FBQzBEO0FBQ0U7QUFDNUUsTUFBTUcsWUFBWSxDQUFDO0FBQ25CLE1BQU1DLFNBQVM7SUFDZkgsTUFBTUYsdUVBQWFBLENBQUNFLCtFQUFJQTtJQUN4QkMsT0FBT0gsdUVBQWFBLENBQUNHLGdGQUFLQTtJQUMxQkMsV0FBV0osdUVBQWFBLENBQUNJO0lBQ3pCLEdBQUdKLHVFQUFhQSxDQUFDQyxPQUFPO0FBQ3hCO0FBRUEsTUFBTUssWUFBWSxJQUFJVCxrRUFBaUIsQ0FBQztJQUFDLGlCQUFnQjtBQUFJO0FBRTdEOztDQUVDLEdBQ0QsTUFBTVcsU0FBUztBQUVmLE1BQU1DLFNBQVNILFVBQVVJLFFBQVEsQ0FBQ0Y7QUFDbEMsTUFBTUcsZUFBZTtJQUFDLFNBQVE7QUFBSztBQUNuQyxNQUFNQyxNQUFNZiw4REFBYSxDQUFDWSxRQUFRRTtBQUVsQzs7O0NBR0MsR0FDRCxNQUFNRyxjQUFjRixJQUFJRyxVQUFVLENBQUNELFdBQVcsR0FDMUNsQixvREFBUyxDQUFDZ0IsSUFBSUcsVUFBVSxDQUFDRCxXQUFXLElBQ3BDLENBQUM7QUFFTCxNQUFNLEVBQUNHLFVBQVUsRUFBVSxHQUFHbEIsbUVBQVNBLENBQUNNOztBQWtEakMsTUFBTWEsVUFBVTtJQUFDSjtBQUFXLEVBQUU7QUFDdEIsU0FBU0ssaUJBQWlCQyxLQUFLO0lBQzVDLE1BQU1GLFVBQVVFLE1BQU1GLE9BQU87SUFDN0IsdUNBQXVDO0lBQ3ZDLE9BQU9wQix1REFBU0EsQ0FBQ3VCLEtBQUssQ0FBQ0gsUUFBUUksT0FBTyxFQUFFM0IsOENBQUtBLEVBQUU7UUFDN0NzQixZQUFZO1lBQ1YsR0FBR0EsVUFBVTtZQUNiLHlFQUF5RTtZQUN6RSxHQUFHRyxNQUFNSCxVQUFVO1FBQ3JCO0lBQ0Y7QUFDRjtLQVZ3QkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXhsdW5kL3Byb2plY3RzL2Zsb3plL2RvY3MvcGFnZXMvd29ya2Zsb3dzL2RhdGFzZXRzLm1kIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeWFtbCBmcm9tICdqcy15YW1sJztcbi8vIHJlbmRlcmVycyBpcyBpbXBvcnRlZCBzZXBhcmF0ZWx5IHNvIE1hcmtkb2MgaXNuJ3Qgc2VudCB0byB0aGUgY2xpZW50XG5pbXBvcnQgTWFya2RvYywge3JlbmRlcmVyc30gZnJvbSAnQG1hcmtkb2MvbWFya2RvYydcblxuaW1wb3J0IHtnZXRTY2hlbWEsIGRlZmF1bHRPYmplY3R9IGZyb20gJ0BtYXJrZG9jL25leHQuanMvcnVudGltZSc7XG4vKipcbiAqIFNjaGVtYSBpcyBpbXBvcnRlZCBsaWtlIHRoaXMgc28gZW5kLXVzZXIncyBjb2RlIGlzIGNvbXBpbGVkIHVzaW5nIGJ1aWxkLWluIGJhYmVsL3dlYnBhY2sgY29uZmlncy5cbiAqIFRoaXMgZW5hYmxlcyB0eXBlc2NyaXB0L0VTbmV4dCBzdXBwb3J0XG4gKi9cbmNvbnN0IGNvbmZpZyA9IHt9O1xuaW1wb3J0ICogYXMgdGFncyBmcm9tICcvVXNlcnMvbWF4bHVuZC9wcm9qZWN0cy9mbG96ZS9kb2NzL21hcmtkb2MvdGFncy5qcydcbmltcG9ydCAqIGFzIG5vZGVzIGZyb20gJy9Vc2Vycy9tYXhsdW5kL3Byb2plY3RzL2Zsb3plL2RvY3MvbWFya2RvYy9ub2Rlcy5qcydcbmNvbnN0IGZ1bmN0aW9ucyA9IHt9O1xuY29uc3Qgc2NoZW1hID0ge1xudGFnczogZGVmYXVsdE9iamVjdCh0YWdzKSxcbm5vZGVzOiBkZWZhdWx0T2JqZWN0KG5vZGVzKSxcbmZ1bmN0aW9uczogZGVmYXVsdE9iamVjdChmdW5jdGlvbnMpLFxuLi4uZGVmYXVsdE9iamVjdChjb25maWcpLFxufTtcblxuY29uc3QgdG9rZW5pemVyID0gbmV3IE1hcmtkb2MuVG9rZW5pemVyKHtcImFsbG93Q29tbWVudHNcIjp0cnVlfSk7XG5cbi8qKlxuICogU291cmNlIHdpbGwgbmV2ZXIgY2hhbmdlIGF0IHJ1bnRpbWUsIHNvIHBhcnNlIGhhcHBlbnMgYXQgdGhlIGZpbGUgcm9vdFxuICovXG5jb25zdCBzb3VyY2UgPSBcIi0tLVxcbnRpdGxlOiBEYXRhc2V0c1xcbi0tLVxcblxcbiMgRGF0YXNldHNcXG5cXG5EYXRhc2V0cyBhcmUgY29sbGVjdGlvbnMgb2YgaXRlbXMgdGhhdCB0YXNrcyBjYW4gaXRlcmF0ZSBvdmVyLlxcblxcbiMjIERlZmluaW5nIERhdGFzZXRzXFxuXFxuYGBgaGNsXFxud29ya2Zsb3cgXFxcInByb2Nlc3NfY2l0aWVzXFxcIiB7XFxuICBkYXRhc2V0IFxcXCJjaXR5X2xpc3RcXFwiIHtcXG4gICAgZGVzY3JpcHRpb24gPSBcXFwiQ2l0aWVzIHRvIHByb2Nlc3NcXFwiXFxuXFxuICAgIHNjaGVtYSB7XFxuICAgICAgZmllbGQgXFxcIm5hbWVcXFwiICB7IHR5cGUgPSBcXFwic3RyaW5nXFxcIjsgcmVxdWlyZWQgPSB0cnVlIH1cXG4gICAgICBmaWVsZCBcXFwic3RhdGVcXFwiIHsgdHlwZSA9IFxcXCJzdHJpbmdcXFwiIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgIyBUYXNrcyBjYW4gaXRlcmF0ZSBvdmVyIHRoaXMgZGF0YXNldFxcbn1cXG5gYGBcXG5cXG4jIyBBdHRyaWJ1dGVzXFxuXFxufCBBdHRyaWJ1dGUgfCBUeXBlIHwgRGVzY3JpcHRpb24gfFxcbnwtLS0tLS0tLS0tLXwtLS0tLS18LS0tLS0tLS0tLS0tLXxcXG58IGBkZXNjcmlwdGlvbmAgfCBzdHJpbmcgfCBEb2N1bWVudGF0aW9uIGZvciB0aGUgZGF0YXNldCB8XFxufCBgc2NoZW1hYCB8IGJsb2NrIHwgT3B0aW9uYWwgc2NoZW1hIGZvciB2YWxpZGF0aW5nIGl0ZW1zIHxcXG5cXG4jIyBTY2hlbWEgRGVmaW5pdGlvblxcblxcbkRlZmluZSBleHBlY3RlZCBmaWVsZHM6XFxuXFxuYGBgaGNsXFxuc2NoZW1hIHtcXG4gIGZpZWxkIFxcXCJpZFxcXCIge1xcbiAgICB0eXBlICAgICA9IFxcXCJpbnRlZ2VyXFxcIlxcbiAgICByZXF1aXJlZCA9IHRydWVcXG4gIH1cXG5cXG4gIGZpZWxkIFxcXCJuYW1lXFxcIiB7XFxuICAgIHR5cGUgICAgID0gXFxcInN0cmluZ1xcXCJcXG4gICAgcmVxdWlyZWQgPSB0cnVlXFxuICB9XFxuXFxuICBmaWVsZCBcXFwibWV0YWRhdGFcXFwiIHtcXG4gICAgdHlwZSA9IFxcXCJvYmplY3RcXFwiXFxuICB9XFxufVxcbmBgYFxcblxcbiMjIyBGaWVsZCBUeXBlc1xcblxcbi0gYHN0cmluZ2BcXG4tIGBudW1iZXJgXFxuLSBgaW50ZWdlcmBcXG4tIGBib29sZWFuYFxcbi0gYGFycmF5YFxcbi0gYG9iamVjdGBcXG5cXG4jIyBQb3B1bGF0aW5nIERhdGFzZXRzXFxuXFxuRGF0YXNldHMgY2FuIGJlIHBvcHVsYXRlZCBpbiB0aHJlZSB3YXlzOlxcblxcbiMjIyAxLiBCaW5kIHRvIFdvcmtmbG93IElucHV0XFxuXFxuYGBgaGNsXFxud29ya2Zsb3cgXFxcInByb2Nlc3NcXFwiIHtcXG4gIGlucHV0IFxcXCJpdGVtc1xcXCIge1xcbiAgICB0eXBlID0gXFxcImxpc3RcXFwiXFxuICB9XFxuXFxuICBkYXRhc2V0IFxcXCJpdGVtX2xpc3RcXFwiIHtcXG4gICAgYmluZF90byA9IGlucHV0cy5pdGVtc1xcbiAgfVxcbn1cXG5gYGBcXG5cXG4jIyMgMi4gRGVmYXVsdCBWYWx1ZXNcXG5cXG5gYGBoY2xcXG5kYXRhc2V0IFxcXCJyZWdpb25zXFxcIiB7XFxuICBkZWZhdWx0ID0gW1xcbiAgICB7IG5hbWUgPSBcXFwidXMtZWFzdC0xXFxcIiB9LFxcbiAgICB7IG5hbWUgPSBcXFwidXMtd2VzdC0yXFxcIiB9LFxcbiAgICB7IG5hbWUgPSBcXFwiZXUtd2VzdC0xXFxcIiB9XFxuICBdXFxufVxcbmBgYFxcblxcbiMjIyAzLiBEeW5hbWljIFBvcHVsYXRpb25cXG5cXG5BZ2VudHMgY2FuIHBvcHVsYXRlIGRhdGFzZXRzIGF0IHJ1bnRpbWUgdXNpbmcgdGhlIGBzZXRfZGF0YXNldGAgdG9vbDpcXG5cXG5gYGBoY2xcXG50YXNrIFxcXCJsb2FkX2RhdGFcXFwiIHtcXG4gIG9iamVjdGl2ZSA9IFxcXCJSZWFkIGNpdGllcyBmcm9tIGRhdGEuanNvbiBhbmQgcG9wdWxhdGUgdGhlIGNpdHlfbGlzdCBkYXRhc2V0XFxcIlxcbn1cXG5cXG50YXNrIFxcXCJwcm9jZXNzX2NpdGllc1xcXCIge1xcbiAgZGVwZW5kc19vbiA9IFt0YXNrcy5sb2FkX2RhdGFdXFxuICBpdGVyYXRvciB7XFxuICAgIGRhdGFzZXQgPSBkYXRhc2V0cy5jaXR5X2xpc3RcXG4gIH1cXG59XFxuYGBgXFxuXFxuIyMgRGF0YXNldCBUb29sc1xcblxcbldoZW4gcnVubmluZyBpbiBhIHdvcmtmbG93LCBhZ2VudHMgYXV0b21hdGljYWxseSBoYXZlIGFjY2VzcyB0bzpcXG5cXG4tICoqc2V0X2RhdGFzZXQqKiAtIFBvcHVsYXRlIGEgZGF0YXNldCB3aXRoIGl0ZW1zXFxuLSAqKmRhdGFzZXRfc2FtcGxlKiogLSBHZXQgc2FtcGxlIGl0ZW1zIGZyb20gYSBkYXRhc2V0XFxuLSAqKmRhdGFzZXRfY291bnQqKiAtIEdldCB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIGEgZGF0YXNldFxcblxcbiMjIyBzZXRfZGF0YXNldFxcblxcbmBgYGpzb25cXG57XFxuICBcXFwibmFtZVxcXCI6IFxcXCJjaXR5X2xpc3RcXFwiLFxcbiAgXFxcIml0ZW1zXFxcIjogW1xcbiAgICB7XFxcIm5hbWVcXFwiOiBcXFwiQ2hpY2Fnb1xcXCIsIFxcXCJzdGF0ZVxcXCI6IFxcXCJJTFxcXCJ9LFxcbiAgICB7XFxcIm5hbWVcXFwiOiBcXFwiRGV0cm9pdFxcXCIsIFxcXCJzdGF0ZVxcXCI6IFxcXCJNSVxcXCJ9XFxuICBdXFxufVxcbmBgYFxcblxcbiMjIyBkYXRhc2V0X3NhbXBsZVxcblxcbmBgYGpzb25cXG57XFxuICBcXFwibmFtZVxcXCI6IFxcXCJjaXR5X2xpc3RcXFwiLFxcbiAgXFxcImNvdW50XFxcIjogM1xcbn1cXG5gYGBcXG5cXG4jIyMgZGF0YXNldF9jb3VudFxcblxcbmBgYGpzb25cXG57XFxuICBcXFwibmFtZVxcXCI6IFxcXCJjaXR5X2xpc3RcXFwiXFxufVxcbmBgYFxcblxcbiMjIFNjaGVtYSBWYWxpZGF0aW9uXFxuXFxuV2hlbiBhIHNjaGVtYSBpcyBkZWZpbmVkLCBhbGwgaXRlbXMgYXJlIHZhbGlkYXRlZDpcXG5cXG5gYGBoY2xcXG5kYXRhc2V0IFxcXCJ1c2Vyc1xcXCIge1xcbiAgc2NoZW1hIHtcXG4gICAgZmllbGQgXFxcImVtYWlsXFxcIiB7IHR5cGUgPSBcXFwic3RyaW5nXFxcIjsgcmVxdWlyZWQgPSB0cnVlIH1cXG4gIH1cXG59XFxuYGBgXFxuXFxuU2V0dGluZyBhbiBpdGVtIHdpdGhvdXQgYGVtYWlsYCB3aWxsIGZhaWwgdmFsaWRhdGlvbi5cXG5cXG4jIyBMYXJnZSBSZXN1bHQgSGFuZGxpbmdcXG5cXG5XaGVuIHRvb2xzIHJldHVybiBsYXJnZSByZXN1bHRzICg+OEtCKSwgU3F1YWQgYXV0b21hdGljYWxseSBwcm90ZWN0cyBjb250ZXh0IGJ5OlxcblxcbjEuIFN0b3JpbmcgdGhlIGZ1bGwgcmVzdWx0IG91dHNpZGUgTExNIGNvbnRleHRcXG4yLiBSZXR1cm5pbmcgYSBzYW1wbGUvc3VtbWFyeSB0byB0aGUgTExNXFxuMy4gUHJvdmlkaW5nIHRvb2xzIGZvciB0aGUgTExNIHRvIGFjY2VzcyBtb3JlIGRhdGEgYXMgbmVlZGVkXFxuXFxuVGhpcyBwcmV2ZW50cyBjb250ZXh0IG92ZXJmbG93IHdoaWxlIHByZXNlcnZpbmcgZnVsbCBhY2Nlc3MgdG8gdGhlIGRhdGEuXFxuXFxuIyMjIEhvdyBJdCBXb3Jrc1xcblxcbmBgYFxcblRvb2wgcmV0dXJucyBsYXJnZSBKU09OIGFycmF5ICg1MDAgaXRlbXMpXFxuICAgICAgICAg4pSCXFxuICAgICAgICAg4pa8XFxuICAgSW50ZXJjZXB0ZWQgJiBzdG9yZWRcXG4gICAgICAgICDilIJcXG4gICAgICAgICDilrxcXG5MTE0gc2VlczpcXG4gIDxPQlNFUlZBVElPTj5cXG4gIFt7Li4ufSwgey4uLn0sIC4uLl0gIChzYW1wbGUpXFxuICA8L09CU0VSVkFUSU9OPlxcbiAgPE9CU0VSVkFUSU9OX01FVEFEQVRBPlxcbiAgdHlwZTogYXJyYXlcXG4gIGlkOiBfcmVzdWx0X2h0dHBfZ2V0XzFcXG4gIHBhcnRpYWw6IHRydWVcXG4gIHRvdGFsX2l0ZW1zOiA1MDBcXG4gIHNob3duX2l0ZW1zOiA1XFxuICA8L09CU0VSVkFUSU9OX01FVEFEQVRBPlxcbmBgYFxcblxcbiMjIyBSZXN1bHQgVG9vbHNcXG5cXG5XaGVuIGEgbGFyZ2UgcmVzdWx0IGlzIGludGVyY2VwdGVkLCB0aGUgTExNIGNhbiB1c2UgdGhlc2UgdG9vbHM6XFxuXFxufCBUb29sIHwgUHVycG9zZSB8XFxufC0tLS0tLXwtLS0tLS0tLS18XFxufCBgcmVzdWx0X2luZm9gIHwgR2V0IHR5cGUgYW5kIHNpemUgb2Ygc3RvcmVkIHJlc3VsdCB8XFxufCBgcmVzdWx0X2l0ZW1zYCB8IEdldCBpdGVtcyBmcm9tIGFycmF5IGJ5IG9mZnNldC9jb3VudCB8XFxufCBgcmVzdWx0X2dldGAgfCBOYXZpZ2F0ZSBvYmplY3Qgd2l0aCBkb3QgcGF0aCAoZS5nLiwgYHVzZXJzLjAubmFtZWApIHxcXG58IGByZXN1bHRfa2V5c2AgfCBHZXQga2V5cyBvZiBhbiBvYmplY3QgfFxcbnwgYHJlc3VsdF9jaHVua2AgfCBHZXQgdGV4dCBieSBvZmZzZXQvbGVuZ3RoIHxcXG5cXG4jIyMgUHJvbW90aW5nIHRvIERhdGFzZXRzXFxuXFxuVXNlIGByZXN1bHRfdG9fZGF0YXNldGAgdG8gY29udmVydCBhIGxhcmdlIGFycmF5IHJlc3VsdCBpbnRvIGEgZGF0YXNldCBmb3IgaXRlcmF0aW9uOlxcblxcbmBgYGpzb25cXG57XFxuICBcXFwiaWRcXFwiOiBcXFwiX3Jlc3VsdF9odHRwX2dldF8xXFxcIixcXG4gIFxcXCJkYXRhc2V0X25hbWVcXFwiOiBcXFwidXNlcnNcXFwiXFxufVxcbmBgYFxcblxcbkFmdGVyIHByb21vdGlvbiwgdGhlIGRhdGEgaXMgYXZhaWxhYmxlIHZpYSBzdGFuZGFyZCBkYXRhc2V0IHRvb2xzIGFuZCBjYW4gYmUgaXRlcmF0ZWQgd2l0aCBgZm9yX2VhY2hgLlxcblxcbiMjIyBFeGFtcGxlIEZsb3dcXG5cXG4xLiBBZ2VudCBjYWxscyBgaHR0cF9nZXRgIOKGkiByZXR1cm5zIDUwMCB1c2Vyc1xcbjIuIEludGVyY2VwdG9yIHN0b3JlcyBmdWxsIGFycmF5LCBMTE0gc2VlcyBzYW1wbGUgb2YgNVxcbjMuIExMTSBleGFtaW5lcyBzYW1wbGUsIGRlY2lkZXMgdGhpcyBpcyB1c2VmdWxcXG40LiBMTE0gY2FsbHMgYHJlc3VsdF90b19kYXRhc2V0KFxcXCJfcmVzdWx0X2h0dHBfZ2V0XzFcXFwiLCBcXFwidXNlcnNcXFwiKWBcXG41LiBTdWJzZXF1ZW50IHRhc2sgaXRlcmF0ZXM6IGBmb3JfZWFjaCA9IGRhdGFzZXRzLnVzZXJzYFxcblxcbiMjIFNlZSBBbHNvXFxuXFxuLSBbSXRlcmF0aW9uXSgvd29ya2Zsb3dzL2l0ZXJhdGlvbikgLSBQcm9jZXNzIGRhdGFzZXRzIGluIHRhc2tzXFxuXCI7XG5jb25zdCBmaWxlcGF0aCA9IFwiL3dvcmtmbG93cy9kYXRhc2V0cy5tZFwiO1xuY29uc3QgdG9rZW5zID0gdG9rZW5pemVyLnRva2VuaXplKHNvdXJjZSk7XG5jb25zdCBwYXJzZU9wdGlvbnMgPSB7XCJzbG90c1wiOmZhbHNlfTtcbmNvbnN0IGFzdCA9IE1hcmtkb2MucGFyc2UodG9rZW5zLCBwYXJzZU9wdGlvbnMpO1xuXG4vKipcbiAqIExpa2UgdGhlIEFTVCwgZnJvbnRtYXR0ZXIgd29uJ3QgY2hhbmdlIGF0IHJ1bnRpbWUsIHNvIGl0IGlzIGxvYWRlZCBhdCBmaWxlIHJvb3QuXG4gKiBUaGlzIHVuYmxvY2tzIGZ1dHVyZSBmZWF0dXJlcywgc3VjaCBhIHBlci1wYWdlIGRhdGFGZXRjaGluZ0Z1bmN0aW9uLlxuICovXG5jb25zdCBmcm9udG1hdHRlciA9IGFzdC5hdHRyaWJ1dGVzLmZyb250bWF0dGVyXG4gID8geWFtbC5sb2FkKGFzdC5hdHRyaWJ1dGVzLmZyb250bWF0dGVyKVxuICA6IHt9O1xuXG5jb25zdCB7Y29tcG9uZW50cywgLi4ucmVzdH0gPSBnZXRTY2hlbWEoc2NoZW1hKVxuXG5hc3luYyBmdW5jdGlvbiBnZXRNYXJrZG9jRGF0YShjb250ZXh0ID0ge30pIHtcbiAgY29uc3QgcGFydGlhbHMgPSB7fTtcblxuICAvLyBFbnN1cmUgTm9kZS50cmFuc2Zvcm1DaGlsZHJlbiBpcyBhdmFpbGFibGVcbiAgT2JqZWN0LmtleXMocGFydGlhbHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IHRva2VucyA9IHRva2VuaXplci50b2tlbml6ZShwYXJ0aWFsc1trZXldKTtcbiAgICBwYXJ0aWFsc1trZXldID0gTWFya2RvYy5wYXJzZSh0b2tlbnMsIHBhcnNlT3B0aW9ucyk7XG4gIH0pO1xuXG4gIGNvbnN0IGNmZyA9IHtcbiAgICAuLi5yZXN0LFxuICAgIHZhcmlhYmxlczoge1xuICAgICAgLi4uKHJlc3QgPyByZXN0LnZhcmlhYmxlcyA6IHt9KSxcbiAgICAgIC8vIHVzZXIgY2FuJ3Qgb3ZlcnJpZGUgdGhpcyBuYW1lc3BhY2VcbiAgICAgIG1hcmtkb2M6IHtmcm9udG1hdHRlcn0sXG4gICAgICAvLyBBbGxvd3MgdXNlcnMgdG8gZWplY3QgZnJvbSBNYXJrZG9jIHJlbmRlcmluZyBhbmQgcGFzcyBpbiBkeW5hbWljIHZhcmlhYmxlcyB2aWEgZ2V0U2VydmVyU2lkZVByb3BzXG4gICAgICAuLi4oY29udGV4dC52YXJpYWJsZXMgfHwge30pXG4gICAgfSxcbiAgICBwYXJ0aWFscyxcbiAgICBzb3VyY2UsXG4gIH07XG5cbiAgLyoqXG4gICAqIHRyYW5zZm9ybSBtdXN0IGJlIGNhbGxlZCBpbiBkYXRhRmV0Y2hpbmdGdW5jdGlvbiB0byBzdXBwb3J0IHNlcnZlci1zaWRlIHJlbmRlcmluZyB3aGlsZVxuICAgKiBhY2Nlc3NpbmcgdmFyaWFibGVzIG9uIHRoZSBzZXJ2ZXJcbiAgICovXG4gIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBNYXJrZG9jLnRyYW5zZm9ybShhc3QsIGNmZyk7XG5cbiAgLy8gUmVtb3ZlcyB1bmRlZmluZWRcbiAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgY29udGVudCxcbiAgICAgIGZyb250bWF0dGVyLFxuICAgICAgZmlsZToge1xuICAgICAgICBwYXRoOiBmaWxlcGF0aCxcbiAgICAgIH0sXG4gICAgfSlcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0YXRpY1Byb3BzKGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9wczoge1xuICAgICAgbWFya2RvYzogYXdhaXQgZ2V0TWFya2RvY0RhdGEoY29udGV4dCksXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IG1hcmtkb2MgPSB7ZnJvbnRtYXR0ZXJ9O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFya2RvY0NvbXBvbmVudChwcm9wcykge1xuICBjb25zdCBtYXJrZG9jID0gcHJvcHMubWFya2RvYztcbiAgLy8gT25seSBleGVjdXRlIEhNUiBjb2RlIGluIGRldmVsb3BtZW50XG4gIHJldHVybiByZW5kZXJlcnMucmVhY3QobWFya2RvYy5jb250ZW50LCBSZWFjdCwge1xuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIC4uLmNvbXBvbmVudHMsXG4gICAgICAvLyBBbGxvd3MgdXNlcnMgdG8gb3ZlcnJpZGUgZGVmYXVsdCBjb21wb25lbnRzIGF0IHJ1bnRpbWUsIHZpYSB0aGVpciBfYXBwXG4gICAgICAuLi5wcm9wcy5jb21wb25lbnRzLFxuICAgIH0sXG4gIH0pO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwieWFtbCIsIk1hcmtkb2MiLCJyZW5kZXJlcnMiLCJnZXRTY2hlbWEiLCJkZWZhdWx0T2JqZWN0IiwiY29uZmlnIiwidGFncyIsIm5vZGVzIiwiZnVuY3Rpb25zIiwic2NoZW1hIiwidG9rZW5pemVyIiwiVG9rZW5pemVyIiwic291cmNlIiwidG9rZW5zIiwidG9rZW5pemUiLCJwYXJzZU9wdGlvbnMiLCJhc3QiLCJwYXJzZSIsImZyb250bWF0dGVyIiwiYXR0cmlidXRlcyIsImxvYWQiLCJjb21wb25lbnRzIiwibWFya2RvYyIsIk1hcmtkb2NDb21wb25lbnQiLCJwcm9wcyIsInJlYWN0IiwiY29udGVudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/workflows/datasets.md\n"));

/***/ })

});
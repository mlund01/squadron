/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/config/variables"],{

/***/ "(pages-dir-browser)/./components/Callout.js":
/*!*******************************!*\
  !*** ./components/Callout.js ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Callout: () => (/* binding */ Callout)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction Callout({ type = 'note', children }) {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: `callout callout-${type}`,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/maxlund/projects/floze/docs/components/Callout.js\",\n        lineNumber: 2,\n        columnNumber: 10\n    }, this);\n}\n_c = Callout;\nvar _c;\n$RefreshReg$(_c, \"Callout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvQ2FsbG91dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQU8sU0FBU0EsUUFBUSxFQUFFQyxPQUFPLE1BQU0sRUFBRUMsUUFBUSxFQUFFO0lBQ2pELHFCQUFPLDhEQUFDQztRQUFJQyxXQUFXLENBQUMsZ0JBQWdCLEVBQUVILE1BQU07a0JBQUdDOzs7Ozs7QUFDckQ7S0FGZ0JGIiwic291cmNlcyI6WyIvVXNlcnMvbWF4bHVuZC9wcm9qZWN0cy9mbG96ZS9kb2NzL2NvbXBvbmVudHMvQ2FsbG91dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gQ2FsbG91dCh7IHR5cGUgPSAnbm90ZScsIGNoaWxkcmVuIH0pIHtcbiAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXtgY2FsbG91dCBjYWxsb3V0LSR7dHlwZX1gfT57Y2hpbGRyZW59PC9kaXY+O1xufVxuIl0sIm5hbWVzIjpbIkNhbGxvdXQiLCJ0eXBlIiwiY2hpbGRyZW4iLCJkaXYiLCJjbGFzc05hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/Callout.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./markdoc/nodes.js":
/*!**************************!*\
  !*** ./markdoc/nodes.js ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fence: () => (/* binding */ fence)\n/* harmony export */ });\n/* harmony import */ var _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @markdoc/markdoc */ \"(pages-dir-browser)/./node_modules/@markdoc/markdoc/dist/index.mjs\");\n\nconst fence = {\n    ..._markdoc_markdoc__WEBPACK_IMPORTED_MODULE_0__.nodes.fence,\n    transform (node, config) {\n        const attributes = node.transformAttributes(config);\n        const children = node.transformChildren(config);\n        const language = node.attributes.language || 'text';\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_0__.Tag('pre', {\n            className: `language-${language}`\n        }, [\n            new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_0__.Tag('code', {\n                className: `language-${language}`\n            }, [\n                node.attributes.content\n            ])\n        ]);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL21hcmtkb2Mvbm9kZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBOEQ7QUFFdkQsTUFBTUcsUUFBUTtJQUNuQixHQUFHRixtREFBWUEsQ0FBQ0UsS0FBSztJQUNyQkMsV0FBVUMsSUFBSSxFQUFFQyxNQUFNO1FBQ3BCLE1BQU1DLGFBQWFGLEtBQUtHLG1CQUFtQixDQUFDRjtRQUM1QyxNQUFNRyxXQUFXSixLQUFLSyxpQkFBaUIsQ0FBQ0o7UUFDeEMsTUFBTUssV0FBV04sS0FBS0UsVUFBVSxDQUFDSSxRQUFRLElBQUk7UUFFN0MsT0FBTyxJQUFJVCxpREFBR0EsQ0FDWixPQUNBO1lBQUVVLFdBQVcsQ0FBQyxTQUFTLEVBQUVELFVBQVU7UUFBQyxHQUNwQztZQUNFLElBQUlULGlEQUFHQSxDQUNMLFFBQ0E7Z0JBQUVVLFdBQVcsQ0FBQyxTQUFTLEVBQUVELFVBQVU7WUFBQyxHQUNwQztnQkFBQ04sS0FBS0UsVUFBVSxDQUFDTSxPQUFPO2FBQUM7U0FFNUI7SUFFTDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXhsdW5kL3Byb2plY3RzL2Zsb3plL2RvY3MvbWFya2RvYy9ub2Rlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub2RlcyBhcyBkZWZhdWx0Tm9kZXMsIFRhZyB9IGZyb20gJ0BtYXJrZG9jL21hcmtkb2MnO1xuXG5leHBvcnQgY29uc3QgZmVuY2UgPSB7XG4gIC4uLmRlZmF1bHROb2Rlcy5mZW5jZSxcbiAgdHJhbnNmb3JtKG5vZGUsIGNvbmZpZykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLnRyYW5zZm9ybUF0dHJpYnV0ZXMoY29uZmlnKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUudHJhbnNmb3JtQ2hpbGRyZW4oY29uZmlnKTtcbiAgICBjb25zdCBsYW5ndWFnZSA9IG5vZGUuYXR0cmlidXRlcy5sYW5ndWFnZSB8fCAndGV4dCc7XG5cbiAgICByZXR1cm4gbmV3IFRhZyhcbiAgICAgICdwcmUnLFxuICAgICAgeyBjbGFzc05hbWU6IGBsYW5ndWFnZS0ke2xhbmd1YWdlfWAgfSxcbiAgICAgIFtcbiAgICAgICAgbmV3IFRhZyhcbiAgICAgICAgICAnY29kZScsXG4gICAgICAgICAgeyBjbGFzc05hbWU6IGBsYW5ndWFnZS0ke2xhbmd1YWdlfWAgfSxcbiAgICAgICAgICBbbm9kZS5hdHRyaWJ1dGVzLmNvbnRlbnRdXG4gICAgICAgIClcbiAgICAgIF1cbiAgICApO1xuICB9LFxufTtcbiJdLCJuYW1lcyI6WyJub2RlcyIsImRlZmF1bHROb2RlcyIsIlRhZyIsImZlbmNlIiwidHJhbnNmb3JtIiwibm9kZSIsImNvbmZpZyIsImF0dHJpYnV0ZXMiLCJ0cmFuc2Zvcm1BdHRyaWJ1dGVzIiwiY2hpbGRyZW4iLCJ0cmFuc2Zvcm1DaGlsZHJlbiIsImxhbmd1YWdlIiwiY2xhc3NOYW1lIiwiY29udGVudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./markdoc/nodes.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./markdoc/tags.js":
/*!*************************!*\
  !*** ./markdoc/tags.js ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   callout: () => (/* binding */ callout)\n/* harmony export */ });\n/* harmony import */ var _components_Callout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/Callout */ \"(pages-dir-browser)/./components/Callout.js\");\n\nconst callout = {\n    render: 'Callout',\n    attributes: {\n        type: {\n            type: String,\n            default: 'note',\n            matches: [\n                'note',\n                'warning',\n                'tip'\n            ]\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL21hcmtkb2MvdGFncy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnRDtBQUV6QyxNQUFNQyxVQUFVO0lBQ3JCQyxRQUFRO0lBQ1JDLFlBQVk7UUFDVkMsTUFBTTtZQUNKQSxNQUFNQztZQUNOQyxTQUFTO1lBQ1RDLFNBQVM7Z0JBQUM7Z0JBQVE7Z0JBQVc7YUFBTTtRQUNyQztJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL21heGx1bmQvcHJvamVjdHMvZmxvemUvZG9jcy9tYXJrZG9jL3RhZ3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FsbG91dCB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ2FsbG91dCc7XG5cbmV4cG9ydCBjb25zdCBjYWxsb3V0ID0ge1xuICByZW5kZXI6ICdDYWxsb3V0JyxcbiAgYXR0cmlidXRlczoge1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdub3RlJyxcbiAgICAgIG1hdGNoZXM6IFsnbm90ZScsICd3YXJuaW5nJywgJ3RpcCddLFxuICAgIH0sXG4gIH0sXG59O1xuIl0sIm5hbWVzIjpbIkNhbGxvdXQiLCJjYWxsb3V0IiwicmVuZGVyIiwiYXR0cmlidXRlcyIsInR5cGUiLCJTdHJpbmciLCJkZWZhdWx0IiwibWF0Y2hlcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./markdoc/tags.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@markdoc/markdoc/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@markdoc/markdoc/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ast: () => (/* binding */ ast_default),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   Tokenizer: () => (/* binding */ Tokenizer),\n/* harmony export */   createElement: () => (/* binding */ createElement),\n/* harmony export */   \"default\": () => (/* binding */ Markdoc),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   functions: () => (/* binding */ functions_default),\n/* harmony export */   globalAttributes: () => (/* binding */ globalAttributes),\n/* harmony export */   nodes: () => (/* binding */ schema_exports),\n/* harmony export */   parse: () => (/* binding */ parse3),\n/* harmony export */   parseTags: () => (/* binding */ parseTags),\n/* harmony export */   renderers: () => (/* binding */ renderers_default),\n/* harmony export */   resolve: () => (/* binding */ resolve2),\n/* harmony export */   tags: () => (/* binding */ tags_default),\n/* harmony export */   transform: () => (/* binding */ transform2),\n/* harmony export */   transformer: () => (/* binding */ transformer_default),\n/* harmony export */   transforms: () => (/* binding */ transforms_default),\n/* harmony export */   truthy: () => (/* binding */ truthy),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   validator: () => (/* binding */ validator)\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module, desc) => {\n  if (module && typeof module === \"object\" || typeof module === \"function\") {\n    for (let key of __getOwnPropNames(module))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module) => {\n  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, \"default\", module && module.__esModule && \"default\" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);\n};\n\n// src/grammar/tag.js\nvar require_tag = __commonJS({\n  \"src/grammar/tag.js\"(exports, module) {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      this.message = message;\n      this.expected = expected;\n      this.found = found;\n      this.location = location;\n      this.name = \"SyntaxError\";\n      if (typeof Error.captureStackTrace === \"function\") {\n        Error.captureStackTrace(this, peg$SyntaxError);\n      }\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    peg$SyntaxError.buildMessage = function(expected, found, location) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        },\n        not: function(expectation) {\n          return \"not \" + describeExpectation(expectation.expected);\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s2) {\n        return s2.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s2) {\n        return s2.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$startRuleFunctions = { Top: peg$parseTop };\n      var peg$startRuleFunction = peg$parseTop;\n      var peg$c0 = \"/\";\n      var peg$c1 = \".\";\n      var peg$c2 = \"#\";\n      var peg$c3 = \"=\";\n      var peg$c4 = \"(\";\n      var peg$c5 = \")\";\n      var peg$c6 = \",\";\n      var peg$c7 = \"[\";\n      var peg$c8 = \"]\";\n      var peg$c9 = \"null\";\n      var peg$c10 = \"true\";\n      var peg$c11 = \"false\";\n      var peg$c12 = \"{\";\n      var peg$c13 = \"}\";\n      var peg$c14 = \":\";\n      var peg$c15 = \"-\";\n      var peg$c16 = '\"';\n      var peg$c17 = \"\\\\\";\n      var peg$c18 = \"n\";\n      var peg$c19 = \"r\";\n      var peg$c20 = \"t\";\n      var peg$r0 = /^[$@]/;\n      var peg$r1 = /^[0-9]/;\n      var peg$r2 = /^[^\\0-\\x1F\"\\\\]/;\n      var peg$r3 = /^[a-zA-Z0-9_\\-]/;\n      var peg$r4 = /^[ \\n\\t]/;\n      var peg$e0 = peg$literalExpectation(\"/\", false);\n      var peg$e1 = peg$otherExpectation(\"tag name\");\n      var peg$e2 = peg$otherExpectation(\"class\");\n      var peg$e3 = peg$otherExpectation(\"id\");\n      var peg$e4 = peg$literalExpectation(\"=\", false);\n      var peg$e5 = peg$literalExpectation(\"(\", false);\n      var peg$e6 = peg$literalExpectation(\")\", false);\n      var peg$e7 = peg$literalExpectation(\",\", false);\n      var peg$e8 = peg$otherExpectation(\"variable\");\n      var peg$e9 = peg$otherExpectation(\"null\");\n      var peg$e10 = peg$otherExpectation(\"boolean\");\n      var peg$e11 = peg$literalExpectation(\"[\", false);\n      var peg$e12 = peg$literalExpectation(\"]\", false);\n      var peg$e13 = peg$literalExpectation(\"{\", false);\n      var peg$e14 = peg$literalExpectation(\"}\", false);\n      var peg$e15 = peg$literalExpectation(\":\", false);\n      var peg$e16 = peg$otherExpectation(\"number\");\n      var peg$e17 = peg$otherExpectation(\"string\");\n      var peg$e18 = peg$otherExpectation(\"identifier\");\n      var peg$e19 = peg$otherExpectation(\"whitespace\");\n      var peg$f0 = function(variable) {\n        return { type: \"variable\", meta: { variable } };\n      };\n      var peg$f1 = function(attributes) {\n        return { type: \"annotation\", meta: { attributes } };\n      };\n      var peg$f2 = function(tag, value) {\n        return value;\n      };\n      var peg$f3 = function(tag, primary, attributes, close) {\n        if (primary) {\n          attributes = attributes || [];\n          attributes.unshift({\n            type: \"attribute\",\n            name: \"primary\",\n            value: primary\n          });\n        }\n        const [type, nesting] = close ? [\"tag\", 0] : [\"tag_open\", 1];\n        return { type, nesting, meta: { tag, attributes } };\n      };\n      var peg$f4 = function(tag) {\n        return { type: \"tag_close\", nesting: -1, meta: { tag } };\n      };\n      var peg$f5 = function(head, tail) {\n        return !head ? [] : [head, ...tail];\n      };\n      var peg$f6 = function(item2) {\n        return item2;\n      };\n      var peg$f7 = function(ids) {\n        return ids;\n      };\n      var peg$f8 = function(classes) {\n        return classes;\n      };\n      var peg$f9 = function(attribute) {\n        return attribute;\n      };\n      var peg$f10 = function(name) {\n        return { type: \"class\", name, value: true };\n      };\n      var peg$f11 = function(value) {\n        return { type: \"attribute\", name: \"id\", value };\n      };\n      var peg$f12 = function(name, value) {\n        return { type: \"attribute\", name, value };\n      };\n      var peg$f13 = function(name, head, tail) {\n        return head ? [head, ...tail] : [];\n      };\n      var peg$f14 = function(name, params) {\n        let parameters = {};\n        for (let [index, { name: name2, value }] of params.entries())\n          parameters[name2 || index] = value;\n        return new Function3(name, parameters);\n      };\n      var peg$f15 = function(name) {\n        return name;\n      };\n      var peg$f16 = function(name, value) {\n        return { name, value };\n      };\n      var peg$f17 = function(value) {\n        return value;\n      };\n      var peg$f18 = function(prefix, head, tail) {\n        if (prefix === \"@\")\n          return [head, ...tail];\n        return new Variable2([head, ...tail]);\n      };\n      var peg$f19 = function() {\n        return null;\n      };\n      var peg$f20 = function() {\n        return true;\n      };\n      var peg$f21 = function() {\n        return false;\n      };\n      var peg$f22 = function(head, tail) {\n        return [head, ...tail];\n      };\n      var peg$f23 = function(value) {\n        return value || [];\n      };\n      var peg$f24 = function(head, tail) {\n        return Object.assign(head, ...tail);\n      };\n      var peg$f25 = function(value) {\n        return value || {};\n      };\n      var peg$f26 = function(key, value) {\n        return key === \"$$mdtype\" ? {} : { [key]: value };\n      };\n      var peg$f27 = function() {\n        return parseFloat(text2());\n      };\n      var peg$f28 = function(value) {\n        return value.join(\"\");\n      };\n      var peg$f29 = function() {\n        return \"\\n\";\n      };\n      var peg$f30 = function() {\n        return \"\\r\";\n      };\n      var peg$f31 = function() {\n        return \"\t\";\n      };\n      var peg$f32 = function(sequence) {\n        return sequence;\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$expected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text2() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return [peg$savedPos, peg$currPos];\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);\n      }\n      function error2(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text3, ignoreCase) {\n        return { type: \"literal\", text: text3, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return {\n          type: \"class\",\n          parts,\n          inverted,\n          ignoreCase\n        };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      var peg$VALIDFILENAME = typeof options.filename === \"string\" && options.filename.length > 0;\n      function peg$computeLocation(startPos, endPos) {\n        var loc = {};\n        if (peg$VALIDFILENAME)\n          loc.filename = options.filename;\n        var startPosDetails = peg$computePosDetails(startPos);\n        loc.start = {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        };\n        var endPosDetails = peg$computePosDetails(endPos);\n        loc.end = {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        };\n        return loc;\n      }\n      function peg$begin() {\n        peg$expected.push({ pos: peg$currPos, variants: [] });\n      }\n      function peg$expect(expected2) {\n        var top = peg$expected[peg$expected.length - 1];\n        if (peg$currPos < top.pos) {\n          return;\n        }\n        if (peg$currPos > top.pos) {\n          top.pos = peg$currPos;\n          top.variants = [];\n        }\n        top.variants.push(expected2);\n      }\n      function peg$end(invert) {\n        var expected2 = peg$expected.pop();\n        var top = peg$expected[peg$expected.length - 1];\n        var variants = expected2.variants;\n        if (top.pos !== expected2.pos) {\n          return;\n        }\n        if (invert) {\n          variants = variants.map(function(e) {\n            return e.type === \"not\" ? e.expected : { type: \"not\", expected: e };\n          });\n        }\n        Array.prototype.push.apply(top.variants, variants);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found, location2), expected2, found, location2);\n      }\n      function peg$buildError() {\n        var expected2 = peg$expected[0];\n        var failPos = expected2.pos;\n        return peg$buildStructuredError(expected2.variants, failPos < input.length ? input.charAt(failPos) : null, failPos < input.length ? peg$computeLocation(failPos, failPos + 1) : peg$computeLocation(failPos, failPos));\n      }\n      function peg$parseTop() {\n        var s0;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$parseTopLevelValue();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseAnnotation();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseTagOpen();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseTagClose();\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parseTopLevelValue() {\n        var s0, s1;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseVariable();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseFunction();\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f0(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parseAnnotation() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseTagAttributes();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parse_();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parse_();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f1(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseTagOpen() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseTagName();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parse_();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parse_();\n          }\n          s3 = peg$currPos;\n          s4 = peg$parseValue();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            peg$savedPos = s3;\n            s3 = peg$f2(s1, s4);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          s4 = peg$parseTagAttributes();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          s5 = [];\n          s6 = peg$parse_();\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parse_();\n          }\n          rule$expects(peg$e0);\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s6 = peg$c0;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n          }\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f3(s1, s3, s4, s6);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseTagClose() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        rule$expects(peg$e0);\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s1 = peg$c0;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseTagName();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f4(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseTagName() {\n        var s0;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e1);\n        peg$silentFails++;\n        s0 = peg$parseIdentifier();\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseTagAttributes() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseTagAttributesItem();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parseTagAttributesTail();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseTagAttributesTail();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f5(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseTagAttributesTail() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parse_();\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseTagAttributesItem();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseTagAttributesItem() {\n        var s0, s1;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseTagShortcutId();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f7(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseTagShortcutClass();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f8(s1);\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseTagAttribute();\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$f9(s1);\n            }\n            s0 = s1;\n          }\n        }\n        return s0;\n      }\n      function peg$parseTagShortcutClass() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e2);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s1 = peg$c1;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseIdentifier();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f10(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseTagShortcutId() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e3);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 35) {\n          s1 = peg$c2;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseIdentifier();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f11(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseTagAttribute() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseIdentifier();\n        if (s1 !== peg$FAILED) {\n          rule$expects(peg$e4);\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s2 = peg$c3;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseValue();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f12(s1, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseFunction() {\n        var s0, s1, s2, s3, s4, s5, s6, s7;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseIdentifier();\n        if (s1 !== peg$FAILED) {\n          rule$expects(peg$e5);\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s2 = peg$c4;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$parse_();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parse_();\n            }\n            s4 = peg$currPos;\n            s5 = peg$parseFunctionParameter();\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            s6 = [];\n            s7 = peg$parseFunctionParameterTail();\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              s7 = peg$parseFunctionParameterTail();\n            }\n            peg$savedPos = s4;\n            s4 = peg$f13(s1, s5, s6);\n            rule$expects(peg$e6);\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s5 = peg$c5;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f14(s1, s4);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseFunctionParameter() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$parseIdentifier();\n        if (s2 !== peg$FAILED) {\n          rule$expects(peg$e4);\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s3 = peg$c3;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s1 = peg$f15(s2);\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        s2 = peg$parseValue();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f16(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseFunctionParameterTail() {\n        var s0, s1, s2, s3, s4;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        rule$expects(peg$e7);\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parse_();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parse_();\n          }\n          s4 = peg$parseFunctionParameter();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f17(s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseTrailingComma() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        rule$expects(peg$e7);\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = null;\n        }\n        return s0;\n      }\n      function peg$parseVariable() {\n        var s0, s1, s2, s3, s4;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e8);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseIdentifier();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$parseVariableTail();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parseVariableTail();\n            }\n            peg$savedPos = s0;\n            s0 = peg$f18(s1, s2, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseVariableTail() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s1 = peg$c1;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseIdentifier();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f15(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s1 = peg$c7;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseValueNumber();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parseValueString();\n            }\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s3 = peg$c8;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n              }\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f17(s2);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        return s0;\n      }\n      function peg$parseValue() {\n        var s0;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$parseValueNull();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseValueBoolean();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseValueString();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseValueNumber();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseValueArray();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parseValueHash();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseFunction();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parseVariable();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parseValueNull() {\n        var s0, s1;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e9);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 4) === peg$c9) {\n          s1 = peg$c9;\n          peg$currPos += 4;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f19();\n        }\n        s0 = s1;\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseValueBoolean() {\n        var s0, s1;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e10);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 4) === peg$c10) {\n          s1 = peg$c10;\n          peg$currPos += 4;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f20();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 5) === peg$c11) {\n            s1 = peg$c11;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f21();\n          }\n          s0 = s1;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseValueArray() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        rule$expects(peg$e11);\n        if (input.charCodeAt(peg$currPos) === 91) {\n          s1 = peg$c7;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parse_();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parse_();\n          }\n          s3 = peg$currPos;\n          s4 = peg$parseValue();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parseValueArrayTail();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parseValueArrayTail();\n            }\n            s6 = peg$parseTrailingComma();\n            peg$savedPos = s3;\n            s3 = peg$f22(s4, s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          s4 = [];\n          s5 = peg$parse_();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parse_();\n          }\n          rule$expects(peg$e12);\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s5 = peg$c8;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f23(s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseValueArrayTail() {\n        var s0, s1, s2, s3, s4;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        rule$expects(peg$e7);\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parse_();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parse_();\n          }\n          s4 = peg$parseValue();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f17(s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseValueHash() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        rule$expects(peg$e13);\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s1 = peg$c12;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parse_();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parse_();\n          }\n          s3 = peg$currPos;\n          s4 = peg$parseValueHashItem();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parseValueHashTail();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parseValueHashTail();\n            }\n            s6 = peg$parseTrailingComma();\n            peg$savedPos = s3;\n            s3 = peg$f24(s4, s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          s4 = [];\n          s5 = peg$parse_();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parse_();\n          }\n          rule$expects(peg$e14);\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s5 = peg$c13;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f25(s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseValueHashTail() {\n        var s0, s1, s2, s3, s4;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        rule$expects(peg$e7);\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parse_();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parse_();\n          }\n          s4 = peg$parseValueHashItem();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6(s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseValueHashItem() {\n        var s0, s1, s2, s3, s4;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseIdentifier();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseValueString();\n        }\n        if (s1 !== peg$FAILED) {\n          rule$expects(peg$e15);\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s2 = peg$c14;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$parse_();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parse_();\n            }\n            s4 = peg$parseValue();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f26(s1, s4);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseValueNumber() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e16);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s1 = peg$c15;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        s2 = [];\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s4 = peg$c1;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                if (peg$r1.test(input.charAt(peg$currPos))) {\n                  s6 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                }\n              }\n            } else {\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f27();\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseValueString() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e17);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s1 = peg$c16;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parseValueStringChars();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseValueStringChars();\n          }\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c16;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f28(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseValueStringChars() {\n        var s0;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        if (peg$r2.test(input.charAt(peg$currPos))) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseValueStringEscapes();\n        }\n        return s0;\n      }\n      function peg$parseValueStringEscapes() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s1 = peg$c17;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s2 = peg$c16;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s2 = peg$c17;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n            }\n            if (s2 === peg$FAILED) {\n              s2 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 110) {\n                s3 = peg$c18;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n              }\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s2;\n                s3 = peg$f29();\n              }\n              s2 = s3;\n              if (s2 === peg$FAILED) {\n                s2 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 114) {\n                  s3 = peg$c19;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                }\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s2;\n                  s3 = peg$f30();\n                }\n                s2 = s3;\n                if (s2 === peg$FAILED) {\n                  s2 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 116) {\n                    s3 = peg$c20;\n                    peg$currPos++;\n                  } else {\n                    s3 = peg$FAILED;\n                  }\n                  if (s3 !== peg$FAILED) {\n                    peg$savedPos = s2;\n                    s3 = peg$f31();\n                  }\n                  s2 = s3;\n                }\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f32(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseIdentifier() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e18);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        if (peg$r3.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            if (peg$r3.test(input.charAt(peg$currPos))) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parse_() {\n        var s0;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e19);\n        peg$silentFails++;\n        if (peg$r4.test(input.charAt(peg$currPos))) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      const { Variable: Variable2, Function: Function3 } = options;\n      peg$begin();\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$expect(peg$endExpectation());\n        }\n        throw peg$buildError();\n      }\n    }\n    module.exports = {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }\n});\n\n// node_modules/entities/lib/maps/entities.json\nvar require_entities = __commonJS({\n  \"node_modules/entities/lib/maps/entities.json\"(exports, module) {\n    module.exports = { Aacute: \"\\xC1\", aacute: \"\\xE1\", Abreve: \"\\u0102\", abreve: \"\\u0103\", ac: \"\\u223E\", acd: \"\\u223F\", acE: \"\\u223E\\u0333\", Acirc: \"\\xC2\", acirc: \"\\xE2\", acute: \"\\xB4\", Acy: \"\\u0410\", acy: \"\\u0430\", AElig: \"\\xC6\", aelig: \"\\xE6\", af: \"\\u2061\", Afr: \"\\u{1D504}\", afr: \"\\u{1D51E}\", Agrave: \"\\xC0\", agrave: \"\\xE0\", alefsym: \"\\u2135\", aleph: \"\\u2135\", Alpha: \"\\u0391\", alpha: \"\\u03B1\", Amacr: \"\\u0100\", amacr: \"\\u0101\", amalg: \"\\u2A3F\", amp: \"&\", AMP: \"&\", andand: \"\\u2A55\", And: \"\\u2A53\", and: \"\\u2227\", andd: \"\\u2A5C\", andslope: \"\\u2A58\", andv: \"\\u2A5A\", ang: \"\\u2220\", ange: \"\\u29A4\", angle: \"\\u2220\", angmsdaa: \"\\u29A8\", angmsdab: \"\\u29A9\", angmsdac: \"\\u29AA\", angmsdad: \"\\u29AB\", angmsdae: \"\\u29AC\", angmsdaf: \"\\u29AD\", angmsdag: \"\\u29AE\", angmsdah: \"\\u29AF\", angmsd: \"\\u2221\", angrt: \"\\u221F\", angrtvb: \"\\u22BE\", angrtvbd: \"\\u299D\", angsph: \"\\u2222\", angst: \"\\xC5\", angzarr: \"\\u237C\", Aogon: \"\\u0104\", aogon: \"\\u0105\", Aopf: \"\\u{1D538}\", aopf: \"\\u{1D552}\", apacir: \"\\u2A6F\", ap: \"\\u2248\", apE: \"\\u2A70\", ape: \"\\u224A\", apid: \"\\u224B\", apos: \"'\", ApplyFunction: \"\\u2061\", approx: \"\\u2248\", approxeq: \"\\u224A\", Aring: \"\\xC5\", aring: \"\\xE5\", Ascr: \"\\u{1D49C}\", ascr: \"\\u{1D4B6}\", Assign: \"\\u2254\", ast: \"*\", asymp: \"\\u2248\", asympeq: \"\\u224D\", Atilde: \"\\xC3\", atilde: \"\\xE3\", Auml: \"\\xC4\", auml: \"\\xE4\", awconint: \"\\u2233\", awint: \"\\u2A11\", backcong: \"\\u224C\", backepsilon: \"\\u03F6\", backprime: \"\\u2035\", backsim: \"\\u223D\", backsimeq: \"\\u22CD\", Backslash: \"\\u2216\", Barv: \"\\u2AE7\", barvee: \"\\u22BD\", barwed: \"\\u2305\", Barwed: \"\\u2306\", barwedge: \"\\u2305\", bbrk: \"\\u23B5\", bbrktbrk: \"\\u23B6\", bcong: \"\\u224C\", Bcy: \"\\u0411\", bcy: \"\\u0431\", bdquo: \"\\u201E\", becaus: \"\\u2235\", because: \"\\u2235\", Because: \"\\u2235\", bemptyv: \"\\u29B0\", bepsi: \"\\u03F6\", bernou: \"\\u212C\", Bernoullis: \"\\u212C\", Beta: \"\\u0392\", beta: \"\\u03B2\", beth: \"\\u2136\", between: \"\\u226C\", Bfr: \"\\u{1D505}\", bfr: \"\\u{1D51F}\", bigcap: \"\\u22C2\", bigcirc: \"\\u25EF\", bigcup: \"\\u22C3\", bigodot: \"\\u2A00\", bigoplus: \"\\u2A01\", bigotimes: \"\\u2A02\", bigsqcup: \"\\u2A06\", bigstar: \"\\u2605\", bigtriangledown: \"\\u25BD\", bigtriangleup: \"\\u25B3\", biguplus: \"\\u2A04\", bigvee: \"\\u22C1\", bigwedge: \"\\u22C0\", bkarow: \"\\u290D\", blacklozenge: \"\\u29EB\", blacksquare: \"\\u25AA\", blacktriangle: \"\\u25B4\", blacktriangledown: \"\\u25BE\", blacktriangleleft: \"\\u25C2\", blacktriangleright: \"\\u25B8\", blank: \"\\u2423\", blk12: \"\\u2592\", blk14: \"\\u2591\", blk34: \"\\u2593\", block: \"\\u2588\", bne: \"=\\u20E5\", bnequiv: \"\\u2261\\u20E5\", bNot: \"\\u2AED\", bnot: \"\\u2310\", Bopf: \"\\u{1D539}\", bopf: \"\\u{1D553}\", bot: \"\\u22A5\", bottom: \"\\u22A5\", bowtie: \"\\u22C8\", boxbox: \"\\u29C9\", boxdl: \"\\u2510\", boxdL: \"\\u2555\", boxDl: \"\\u2556\", boxDL: \"\\u2557\", boxdr: \"\\u250C\", boxdR: \"\\u2552\", boxDr: \"\\u2553\", boxDR: \"\\u2554\", boxh: \"\\u2500\", boxH: \"\\u2550\", boxhd: \"\\u252C\", boxHd: \"\\u2564\", boxhD: \"\\u2565\", boxHD: \"\\u2566\", boxhu: \"\\u2534\", boxHu: \"\\u2567\", boxhU: \"\\u2568\", boxHU: \"\\u2569\", boxminus: \"\\u229F\", boxplus: \"\\u229E\", boxtimes: \"\\u22A0\", boxul: \"\\u2518\", boxuL: \"\\u255B\", boxUl: \"\\u255C\", boxUL: \"\\u255D\", boxur: \"\\u2514\", boxuR: \"\\u2558\", boxUr: \"\\u2559\", boxUR: \"\\u255A\", boxv: \"\\u2502\", boxV: \"\\u2551\", boxvh: \"\\u253C\", boxvH: \"\\u256A\", boxVh: \"\\u256B\", boxVH: \"\\u256C\", boxvl: \"\\u2524\", boxvL: \"\\u2561\", boxVl: \"\\u2562\", boxVL: \"\\u2563\", boxvr: \"\\u251C\", boxvR: \"\\u255E\", boxVr: \"\\u255F\", boxVR: \"\\u2560\", bprime: \"\\u2035\", breve: \"\\u02D8\", Breve: \"\\u02D8\", brvbar: \"\\xA6\", bscr: \"\\u{1D4B7}\", Bscr: \"\\u212C\", bsemi: \"\\u204F\", bsim: \"\\u223D\", bsime: \"\\u22CD\", bsolb: \"\\u29C5\", bsol: \"\\\\\", bsolhsub: \"\\u27C8\", bull: \"\\u2022\", bullet: \"\\u2022\", bump: \"\\u224E\", bumpE: \"\\u2AAE\", bumpe: \"\\u224F\", Bumpeq: \"\\u224E\", bumpeq: \"\\u224F\", Cacute: \"\\u0106\", cacute: \"\\u0107\", capand: \"\\u2A44\", capbrcup: \"\\u2A49\", capcap: \"\\u2A4B\", cap: \"\\u2229\", Cap: \"\\u22D2\", capcup: \"\\u2A47\", capdot: \"\\u2A40\", CapitalDifferentialD: \"\\u2145\", caps: \"\\u2229\\uFE00\", caret: \"\\u2041\", caron: \"\\u02C7\", Cayleys: \"\\u212D\", ccaps: \"\\u2A4D\", Ccaron: \"\\u010C\", ccaron: \"\\u010D\", Ccedil: \"\\xC7\", ccedil: \"\\xE7\", Ccirc: \"\\u0108\", ccirc: \"\\u0109\", Cconint: \"\\u2230\", ccups: \"\\u2A4C\", ccupssm: \"\\u2A50\", Cdot: \"\\u010A\", cdot: \"\\u010B\", cedil: \"\\xB8\", Cedilla: \"\\xB8\", cemptyv: \"\\u29B2\", cent: \"\\xA2\", centerdot: \"\\xB7\", CenterDot: \"\\xB7\", cfr: \"\\u{1D520}\", Cfr: \"\\u212D\", CHcy: \"\\u0427\", chcy: \"\\u0447\", check: \"\\u2713\", checkmark: \"\\u2713\", Chi: \"\\u03A7\", chi: \"\\u03C7\", circ: \"\\u02C6\", circeq: \"\\u2257\", circlearrowleft: \"\\u21BA\", circlearrowright: \"\\u21BB\", circledast: \"\\u229B\", circledcirc: \"\\u229A\", circleddash: \"\\u229D\", CircleDot: \"\\u2299\", circledR: \"\\xAE\", circledS: \"\\u24C8\", CircleMinus: \"\\u2296\", CirclePlus: \"\\u2295\", CircleTimes: \"\\u2297\", cir: \"\\u25CB\", cirE: \"\\u29C3\", cire: \"\\u2257\", cirfnint: \"\\u2A10\", cirmid: \"\\u2AEF\", cirscir: \"\\u29C2\", ClockwiseContourIntegral: \"\\u2232\", CloseCurlyDoubleQuote: \"\\u201D\", CloseCurlyQuote: \"\\u2019\", clubs: \"\\u2663\", clubsuit: \"\\u2663\", colon: \":\", Colon: \"\\u2237\", Colone: \"\\u2A74\", colone: \"\\u2254\", coloneq: \"\\u2254\", comma: \",\", commat: \"@\", comp: \"\\u2201\", compfn: \"\\u2218\", complement: \"\\u2201\", complexes: \"\\u2102\", cong: \"\\u2245\", congdot: \"\\u2A6D\", Congruent: \"\\u2261\", conint: \"\\u222E\", Conint: \"\\u222F\", ContourIntegral: \"\\u222E\", copf: \"\\u{1D554}\", Copf: \"\\u2102\", coprod: \"\\u2210\", Coproduct: \"\\u2210\", copy: \"\\xA9\", COPY: \"\\xA9\", copysr: \"\\u2117\", CounterClockwiseContourIntegral: \"\\u2233\", crarr: \"\\u21B5\", cross: \"\\u2717\", Cross: \"\\u2A2F\", Cscr: \"\\u{1D49E}\", cscr: \"\\u{1D4B8}\", csub: \"\\u2ACF\", csube: \"\\u2AD1\", csup: \"\\u2AD0\", csupe: \"\\u2AD2\", ctdot: \"\\u22EF\", cudarrl: \"\\u2938\", cudarrr: \"\\u2935\", cuepr: \"\\u22DE\", cuesc: \"\\u22DF\", cularr: \"\\u21B6\", cularrp: \"\\u293D\", cupbrcap: \"\\u2A48\", cupcap: \"\\u2A46\", CupCap: \"\\u224D\", cup: \"\\u222A\", Cup: \"\\u22D3\", cupcup: \"\\u2A4A\", cupdot: \"\\u228D\", cupor: \"\\u2A45\", cups: \"\\u222A\\uFE00\", curarr: \"\\u21B7\", curarrm: \"\\u293C\", curlyeqprec: \"\\u22DE\", curlyeqsucc: \"\\u22DF\", curlyvee: \"\\u22CE\", curlywedge: \"\\u22CF\", curren: \"\\xA4\", curvearrowleft: \"\\u21B6\", curvearrowright: \"\\u21B7\", cuvee: \"\\u22CE\", cuwed: \"\\u22CF\", cwconint: \"\\u2232\", cwint: \"\\u2231\", cylcty: \"\\u232D\", dagger: \"\\u2020\", Dagger: \"\\u2021\", daleth: \"\\u2138\", darr: \"\\u2193\", Darr: \"\\u21A1\", dArr: \"\\u21D3\", dash: \"\\u2010\", Dashv: \"\\u2AE4\", dashv: \"\\u22A3\", dbkarow: \"\\u290F\", dblac: \"\\u02DD\", Dcaron: \"\\u010E\", dcaron: \"\\u010F\", Dcy: \"\\u0414\", dcy: \"\\u0434\", ddagger: \"\\u2021\", ddarr: \"\\u21CA\", DD: \"\\u2145\", dd: \"\\u2146\", DDotrahd: \"\\u2911\", ddotseq: \"\\u2A77\", deg: \"\\xB0\", Del: \"\\u2207\", Delta: \"\\u0394\", delta: \"\\u03B4\", demptyv: \"\\u29B1\", dfisht: \"\\u297F\", Dfr: \"\\u{1D507}\", dfr: \"\\u{1D521}\", dHar: \"\\u2965\", dharl: \"\\u21C3\", dharr: \"\\u21C2\", DiacriticalAcute: \"\\xB4\", DiacriticalDot: \"\\u02D9\", DiacriticalDoubleAcute: \"\\u02DD\", DiacriticalGrave: \"`\", DiacriticalTilde: \"\\u02DC\", diam: \"\\u22C4\", diamond: \"\\u22C4\", Diamond: \"\\u22C4\", diamondsuit: \"\\u2666\", diams: \"\\u2666\", die: \"\\xA8\", DifferentialD: \"\\u2146\", digamma: \"\\u03DD\", disin: \"\\u22F2\", div: \"\\xF7\", divide: \"\\xF7\", divideontimes: \"\\u22C7\", divonx: \"\\u22C7\", DJcy: \"\\u0402\", djcy: \"\\u0452\", dlcorn: \"\\u231E\", dlcrop: \"\\u230D\", dollar: \"$\", Dopf: \"\\u{1D53B}\", dopf: \"\\u{1D555}\", Dot: \"\\xA8\", dot: \"\\u02D9\", DotDot: \"\\u20DC\", doteq: \"\\u2250\", doteqdot: \"\\u2251\", DotEqual: \"\\u2250\", dotminus: \"\\u2238\", dotplus: \"\\u2214\", dotsquare: \"\\u22A1\", doublebarwedge: \"\\u2306\", DoubleContourIntegral: \"\\u222F\", DoubleDot: \"\\xA8\", DoubleDownArrow: \"\\u21D3\", DoubleLeftArrow: \"\\u21D0\", DoubleLeftRightArrow: \"\\u21D4\", DoubleLeftTee: \"\\u2AE4\", DoubleLongLeftArrow: \"\\u27F8\", DoubleLongLeftRightArrow: \"\\u27FA\", DoubleLongRightArrow: \"\\u27F9\", DoubleRightArrow: \"\\u21D2\", DoubleRightTee: \"\\u22A8\", DoubleUpArrow: \"\\u21D1\", DoubleUpDownArrow: \"\\u21D5\", DoubleVerticalBar: \"\\u2225\", DownArrowBar: \"\\u2913\", downarrow: \"\\u2193\", DownArrow: \"\\u2193\", Downarrow: \"\\u21D3\", DownArrowUpArrow: \"\\u21F5\", DownBreve: \"\\u0311\", downdownarrows: \"\\u21CA\", downharpoonleft: \"\\u21C3\", downharpoonright: \"\\u21C2\", DownLeftRightVector: \"\\u2950\", DownLeftTeeVector: \"\\u295E\", DownLeftVectorBar: \"\\u2956\", DownLeftVector: \"\\u21BD\", DownRightTeeVector: \"\\u295F\", DownRightVectorBar: \"\\u2957\", DownRightVector: \"\\u21C1\", DownTeeArrow: \"\\u21A7\", DownTee: \"\\u22A4\", drbkarow: \"\\u2910\", drcorn: \"\\u231F\", drcrop: \"\\u230C\", Dscr: \"\\u{1D49F}\", dscr: \"\\u{1D4B9}\", DScy: \"\\u0405\", dscy: \"\\u0455\", dsol: \"\\u29F6\", Dstrok: \"\\u0110\", dstrok: \"\\u0111\", dtdot: \"\\u22F1\", dtri: \"\\u25BF\", dtrif: \"\\u25BE\", duarr: \"\\u21F5\", duhar: \"\\u296F\", dwangle: \"\\u29A6\", DZcy: \"\\u040F\", dzcy: \"\\u045F\", dzigrarr: \"\\u27FF\", Eacute: \"\\xC9\", eacute: \"\\xE9\", easter: \"\\u2A6E\", Ecaron: \"\\u011A\", ecaron: \"\\u011B\", Ecirc: \"\\xCA\", ecirc: \"\\xEA\", ecir: \"\\u2256\", ecolon: \"\\u2255\", Ecy: \"\\u042D\", ecy: \"\\u044D\", eDDot: \"\\u2A77\", Edot: \"\\u0116\", edot: \"\\u0117\", eDot: \"\\u2251\", ee: \"\\u2147\", efDot: \"\\u2252\", Efr: \"\\u{1D508}\", efr: \"\\u{1D522}\", eg: \"\\u2A9A\", Egrave: \"\\xC8\", egrave: \"\\xE8\", egs: \"\\u2A96\", egsdot: \"\\u2A98\", el: \"\\u2A99\", Element: \"\\u2208\", elinters: \"\\u23E7\", ell: \"\\u2113\", els: \"\\u2A95\", elsdot: \"\\u2A97\", Emacr: \"\\u0112\", emacr: \"\\u0113\", empty: \"\\u2205\", emptyset: \"\\u2205\", EmptySmallSquare: \"\\u25FB\", emptyv: \"\\u2205\", EmptyVerySmallSquare: \"\\u25AB\", emsp13: \"\\u2004\", emsp14: \"\\u2005\", emsp: \"\\u2003\", ENG: \"\\u014A\", eng: \"\\u014B\", ensp: \"\\u2002\", Eogon: \"\\u0118\", eogon: \"\\u0119\", Eopf: \"\\u{1D53C}\", eopf: \"\\u{1D556}\", epar: \"\\u22D5\", eparsl: \"\\u29E3\", eplus: \"\\u2A71\", epsi: \"\\u03B5\", Epsilon: \"\\u0395\", epsilon: \"\\u03B5\", epsiv: \"\\u03F5\", eqcirc: \"\\u2256\", eqcolon: \"\\u2255\", eqsim: \"\\u2242\", eqslantgtr: \"\\u2A96\", eqslantless: \"\\u2A95\", Equal: \"\\u2A75\", equals: \"=\", EqualTilde: \"\\u2242\", equest: \"\\u225F\", Equilibrium: \"\\u21CC\", equiv: \"\\u2261\", equivDD: \"\\u2A78\", eqvparsl: \"\\u29E5\", erarr: \"\\u2971\", erDot: \"\\u2253\", escr: \"\\u212F\", Escr: \"\\u2130\", esdot: \"\\u2250\", Esim: \"\\u2A73\", esim: \"\\u2242\", Eta: \"\\u0397\", eta: \"\\u03B7\", ETH: \"\\xD0\", eth: \"\\xF0\", Euml: \"\\xCB\", euml: \"\\xEB\", euro: \"\\u20AC\", excl: \"!\", exist: \"\\u2203\", Exists: \"\\u2203\", expectation: \"\\u2130\", exponentiale: \"\\u2147\", ExponentialE: \"\\u2147\", fallingdotseq: \"\\u2252\", Fcy: \"\\u0424\", fcy: \"\\u0444\", female: \"\\u2640\", ffilig: \"\\uFB03\", fflig: \"\\uFB00\", ffllig: \"\\uFB04\", Ffr: \"\\u{1D509}\", ffr: \"\\u{1D523}\", filig: \"\\uFB01\", FilledSmallSquare: \"\\u25FC\", FilledVerySmallSquare: \"\\u25AA\", fjlig: \"fj\", flat: \"\\u266D\", fllig: \"\\uFB02\", fltns: \"\\u25B1\", fnof: \"\\u0192\", Fopf: \"\\u{1D53D}\", fopf: \"\\u{1D557}\", forall: \"\\u2200\", ForAll: \"\\u2200\", fork: \"\\u22D4\", forkv: \"\\u2AD9\", Fouriertrf: \"\\u2131\", fpartint: \"\\u2A0D\", frac12: \"\\xBD\", frac13: \"\\u2153\", frac14: \"\\xBC\", frac15: \"\\u2155\", frac16: \"\\u2159\", frac18: \"\\u215B\", frac23: \"\\u2154\", frac25: \"\\u2156\", frac34: \"\\xBE\", frac35: \"\\u2157\", frac38: \"\\u215C\", frac45: \"\\u2158\", frac56: \"\\u215A\", frac58: \"\\u215D\", frac78: \"\\u215E\", frasl: \"\\u2044\", frown: \"\\u2322\", fscr: \"\\u{1D4BB}\", Fscr: \"\\u2131\", gacute: \"\\u01F5\", Gamma: \"\\u0393\", gamma: \"\\u03B3\", Gammad: \"\\u03DC\", gammad: \"\\u03DD\", gap: \"\\u2A86\", Gbreve: \"\\u011E\", gbreve: \"\\u011F\", Gcedil: \"\\u0122\", Gcirc: \"\\u011C\", gcirc: \"\\u011D\", Gcy: \"\\u0413\", gcy: \"\\u0433\", Gdot: \"\\u0120\", gdot: \"\\u0121\", ge: \"\\u2265\", gE: \"\\u2267\", gEl: \"\\u2A8C\", gel: \"\\u22DB\", geq: \"\\u2265\", geqq: \"\\u2267\", geqslant: \"\\u2A7E\", gescc: \"\\u2AA9\", ges: \"\\u2A7E\", gesdot: \"\\u2A80\", gesdoto: \"\\u2A82\", gesdotol: \"\\u2A84\", gesl: \"\\u22DB\\uFE00\", gesles: \"\\u2A94\", Gfr: \"\\u{1D50A}\", gfr: \"\\u{1D524}\", gg: \"\\u226B\", Gg: \"\\u22D9\", ggg: \"\\u22D9\", gimel: \"\\u2137\", GJcy: \"\\u0403\", gjcy: \"\\u0453\", gla: \"\\u2AA5\", gl: \"\\u2277\", glE: \"\\u2A92\", glj: \"\\u2AA4\", gnap: \"\\u2A8A\", gnapprox: \"\\u2A8A\", gne: \"\\u2A88\", gnE: \"\\u2269\", gneq: \"\\u2A88\", gneqq: \"\\u2269\", gnsim: \"\\u22E7\", Gopf: \"\\u{1D53E}\", gopf: \"\\u{1D558}\", grave: \"`\", GreaterEqual: \"\\u2265\", GreaterEqualLess: \"\\u22DB\", GreaterFullEqual: \"\\u2267\", GreaterGreater: \"\\u2AA2\", GreaterLess: \"\\u2277\", GreaterSlantEqual: \"\\u2A7E\", GreaterTilde: \"\\u2273\", Gscr: \"\\u{1D4A2}\", gscr: \"\\u210A\", gsim: \"\\u2273\", gsime: \"\\u2A8E\", gsiml: \"\\u2A90\", gtcc: \"\\u2AA7\", gtcir: \"\\u2A7A\", gt: \">\", GT: \">\", Gt: \"\\u226B\", gtdot: \"\\u22D7\", gtlPar: \"\\u2995\", gtquest: \"\\u2A7C\", gtrapprox: \"\\u2A86\", gtrarr: \"\\u2978\", gtrdot: \"\\u22D7\", gtreqless: \"\\u22DB\", gtreqqless: \"\\u2A8C\", gtrless: \"\\u2277\", gtrsim: \"\\u2273\", gvertneqq: \"\\u2269\\uFE00\", gvnE: \"\\u2269\\uFE00\", Hacek: \"\\u02C7\", hairsp: \"\\u200A\", half: \"\\xBD\", hamilt: \"\\u210B\", HARDcy: \"\\u042A\", hardcy: \"\\u044A\", harrcir: \"\\u2948\", harr: \"\\u2194\", hArr: \"\\u21D4\", harrw: \"\\u21AD\", Hat: \"^\", hbar: \"\\u210F\", Hcirc: \"\\u0124\", hcirc: \"\\u0125\", hearts: \"\\u2665\", heartsuit: \"\\u2665\", hellip: \"\\u2026\", hercon: \"\\u22B9\", hfr: \"\\u{1D525}\", Hfr: \"\\u210C\", HilbertSpace: \"\\u210B\", hksearow: \"\\u2925\", hkswarow: \"\\u2926\", hoarr: \"\\u21FF\", homtht: \"\\u223B\", hookleftarrow: \"\\u21A9\", hookrightarrow: \"\\u21AA\", hopf: \"\\u{1D559}\", Hopf: \"\\u210D\", horbar: \"\\u2015\", HorizontalLine: \"\\u2500\", hscr: \"\\u{1D4BD}\", Hscr: \"\\u210B\", hslash: \"\\u210F\", Hstrok: \"\\u0126\", hstrok: \"\\u0127\", HumpDownHump: \"\\u224E\", HumpEqual: \"\\u224F\", hybull: \"\\u2043\", hyphen: \"\\u2010\", Iacute: \"\\xCD\", iacute: \"\\xED\", ic: \"\\u2063\", Icirc: \"\\xCE\", icirc: \"\\xEE\", Icy: \"\\u0418\", icy: \"\\u0438\", Idot: \"\\u0130\", IEcy: \"\\u0415\", iecy: \"\\u0435\", iexcl: \"\\xA1\", iff: \"\\u21D4\", ifr: \"\\u{1D526}\", Ifr: \"\\u2111\", Igrave: \"\\xCC\", igrave: \"\\xEC\", ii: \"\\u2148\", iiiint: \"\\u2A0C\", iiint: \"\\u222D\", iinfin: \"\\u29DC\", iiota: \"\\u2129\", IJlig: \"\\u0132\", ijlig: \"\\u0133\", Imacr: \"\\u012A\", imacr: \"\\u012B\", image: \"\\u2111\", ImaginaryI: \"\\u2148\", imagline: \"\\u2110\", imagpart: \"\\u2111\", imath: \"\\u0131\", Im: \"\\u2111\", imof: \"\\u22B7\", imped: \"\\u01B5\", Implies: \"\\u21D2\", incare: \"\\u2105\", in: \"\\u2208\", infin: \"\\u221E\", infintie: \"\\u29DD\", inodot: \"\\u0131\", intcal: \"\\u22BA\", int: \"\\u222B\", Int: \"\\u222C\", integers: \"\\u2124\", Integral: \"\\u222B\", intercal: \"\\u22BA\", Intersection: \"\\u22C2\", intlarhk: \"\\u2A17\", intprod: \"\\u2A3C\", InvisibleComma: \"\\u2063\", InvisibleTimes: \"\\u2062\", IOcy: \"\\u0401\", iocy: \"\\u0451\", Iogon: \"\\u012E\", iogon: \"\\u012F\", Iopf: \"\\u{1D540}\", iopf: \"\\u{1D55A}\", Iota: \"\\u0399\", iota: \"\\u03B9\", iprod: \"\\u2A3C\", iquest: \"\\xBF\", iscr: \"\\u{1D4BE}\", Iscr: \"\\u2110\", isin: \"\\u2208\", isindot: \"\\u22F5\", isinE: \"\\u22F9\", isins: \"\\u22F4\", isinsv: \"\\u22F3\", isinv: \"\\u2208\", it: \"\\u2062\", Itilde: \"\\u0128\", itilde: \"\\u0129\", Iukcy: \"\\u0406\", iukcy: \"\\u0456\", Iuml: \"\\xCF\", iuml: \"\\xEF\", Jcirc: \"\\u0134\", jcirc: \"\\u0135\", Jcy: \"\\u0419\", jcy: \"\\u0439\", Jfr: \"\\u{1D50D}\", jfr: \"\\u{1D527}\", jmath: \"\\u0237\", Jopf: \"\\u{1D541}\", jopf: \"\\u{1D55B}\", Jscr: \"\\u{1D4A5}\", jscr: \"\\u{1D4BF}\", Jsercy: \"\\u0408\", jsercy: \"\\u0458\", Jukcy: \"\\u0404\", jukcy: \"\\u0454\", Kappa: \"\\u039A\", kappa: \"\\u03BA\", kappav: \"\\u03F0\", Kcedil: \"\\u0136\", kcedil: \"\\u0137\", Kcy: \"\\u041A\", kcy: \"\\u043A\", Kfr: \"\\u{1D50E}\", kfr: \"\\u{1D528}\", kgreen: \"\\u0138\", KHcy: \"\\u0425\", khcy: \"\\u0445\", KJcy: \"\\u040C\", kjcy: \"\\u045C\", Kopf: \"\\u{1D542}\", kopf: \"\\u{1D55C}\", Kscr: \"\\u{1D4A6}\", kscr: \"\\u{1D4C0}\", lAarr: \"\\u21DA\", Lacute: \"\\u0139\", lacute: \"\\u013A\", laemptyv: \"\\u29B4\", lagran: \"\\u2112\", Lambda: \"\\u039B\", lambda: \"\\u03BB\", lang: \"\\u27E8\", Lang: \"\\u27EA\", langd: \"\\u2991\", langle: \"\\u27E8\", lap: \"\\u2A85\", Laplacetrf: \"\\u2112\", laquo: \"\\xAB\", larrb: \"\\u21E4\", larrbfs: \"\\u291F\", larr: \"\\u2190\", Larr: \"\\u219E\", lArr: \"\\u21D0\", larrfs: \"\\u291D\", larrhk: \"\\u21A9\", larrlp: \"\\u21AB\", larrpl: \"\\u2939\", larrsim: \"\\u2973\", larrtl: \"\\u21A2\", latail: \"\\u2919\", lAtail: \"\\u291B\", lat: \"\\u2AAB\", late: \"\\u2AAD\", lates: \"\\u2AAD\\uFE00\", lbarr: \"\\u290C\", lBarr: \"\\u290E\", lbbrk: \"\\u2772\", lbrace: \"{\", lbrack: \"[\", lbrke: \"\\u298B\", lbrksld: \"\\u298F\", lbrkslu: \"\\u298D\", Lcaron: \"\\u013D\", lcaron: \"\\u013E\", Lcedil: \"\\u013B\", lcedil: \"\\u013C\", lceil: \"\\u2308\", lcub: \"{\", Lcy: \"\\u041B\", lcy: \"\\u043B\", ldca: \"\\u2936\", ldquo: \"\\u201C\", ldquor: \"\\u201E\", ldrdhar: \"\\u2967\", ldrushar: \"\\u294B\", ldsh: \"\\u21B2\", le: \"\\u2264\", lE: \"\\u2266\", LeftAngleBracket: \"\\u27E8\", LeftArrowBar: \"\\u21E4\", leftarrow: \"\\u2190\", LeftArrow: \"\\u2190\", Leftarrow: \"\\u21D0\", LeftArrowRightArrow: \"\\u21C6\", leftarrowtail: \"\\u21A2\", LeftCeiling: \"\\u2308\", LeftDoubleBracket: \"\\u27E6\", LeftDownTeeVector: \"\\u2961\", LeftDownVectorBar: \"\\u2959\", LeftDownVector: \"\\u21C3\", LeftFloor: \"\\u230A\", leftharpoondown: \"\\u21BD\", leftharpoonup: \"\\u21BC\", leftleftarrows: \"\\u21C7\", leftrightarrow: \"\\u2194\", LeftRightArrow: \"\\u2194\", Leftrightarrow: \"\\u21D4\", leftrightarrows: \"\\u21C6\", leftrightharpoons: \"\\u21CB\", leftrightsquigarrow: \"\\u21AD\", LeftRightVector: \"\\u294E\", LeftTeeArrow: \"\\u21A4\", LeftTee: \"\\u22A3\", LeftTeeVector: \"\\u295A\", leftthreetimes: \"\\u22CB\", LeftTriangleBar: \"\\u29CF\", LeftTriangle: \"\\u22B2\", LeftTriangleEqual: \"\\u22B4\", LeftUpDownVector: \"\\u2951\", LeftUpTeeVector: \"\\u2960\", LeftUpVectorBar: \"\\u2958\", LeftUpVector: \"\\u21BF\", LeftVectorBar: \"\\u2952\", LeftVector: \"\\u21BC\", lEg: \"\\u2A8B\", leg: \"\\u22DA\", leq: \"\\u2264\", leqq: \"\\u2266\", leqslant: \"\\u2A7D\", lescc: \"\\u2AA8\", les: \"\\u2A7D\", lesdot: \"\\u2A7F\", lesdoto: \"\\u2A81\", lesdotor: \"\\u2A83\", lesg: \"\\u22DA\\uFE00\", lesges: \"\\u2A93\", lessapprox: \"\\u2A85\", lessdot: \"\\u22D6\", lesseqgtr: \"\\u22DA\", lesseqqgtr: \"\\u2A8B\", LessEqualGreater: \"\\u22DA\", LessFullEqual: \"\\u2266\", LessGreater: \"\\u2276\", lessgtr: \"\\u2276\", LessLess: \"\\u2AA1\", lesssim: \"\\u2272\", LessSlantEqual: \"\\u2A7D\", LessTilde: \"\\u2272\", lfisht: \"\\u297C\", lfloor: \"\\u230A\", Lfr: \"\\u{1D50F}\", lfr: \"\\u{1D529}\", lg: \"\\u2276\", lgE: \"\\u2A91\", lHar: \"\\u2962\", lhard: \"\\u21BD\", lharu: \"\\u21BC\", lharul: \"\\u296A\", lhblk: \"\\u2584\", LJcy: \"\\u0409\", ljcy: \"\\u0459\", llarr: \"\\u21C7\", ll: \"\\u226A\", Ll: \"\\u22D8\", llcorner: \"\\u231E\", Lleftarrow: \"\\u21DA\", llhard: \"\\u296B\", lltri: \"\\u25FA\", Lmidot: \"\\u013F\", lmidot: \"\\u0140\", lmoustache: \"\\u23B0\", lmoust: \"\\u23B0\", lnap: \"\\u2A89\", lnapprox: \"\\u2A89\", lne: \"\\u2A87\", lnE: \"\\u2268\", lneq: \"\\u2A87\", lneqq: \"\\u2268\", lnsim: \"\\u22E6\", loang: \"\\u27EC\", loarr: \"\\u21FD\", lobrk: \"\\u27E6\", longleftarrow: \"\\u27F5\", LongLeftArrow: \"\\u27F5\", Longleftarrow: \"\\u27F8\", longleftrightarrow: \"\\u27F7\", LongLeftRightArrow: \"\\u27F7\", Longleftrightarrow: \"\\u27FA\", longmapsto: \"\\u27FC\", longrightarrow: \"\\u27F6\", LongRightArrow: \"\\u27F6\", Longrightarrow: \"\\u27F9\", looparrowleft: \"\\u21AB\", looparrowright: \"\\u21AC\", lopar: \"\\u2985\", Lopf: \"\\u{1D543}\", lopf: \"\\u{1D55D}\", loplus: \"\\u2A2D\", lotimes: \"\\u2A34\", lowast: \"\\u2217\", lowbar: \"_\", LowerLeftArrow: \"\\u2199\", LowerRightArrow: \"\\u2198\", loz: \"\\u25CA\", lozenge: \"\\u25CA\", lozf: \"\\u29EB\", lpar: \"(\", lparlt: \"\\u2993\", lrarr: \"\\u21C6\", lrcorner: \"\\u231F\", lrhar: \"\\u21CB\", lrhard: \"\\u296D\", lrm: \"\\u200E\", lrtri: \"\\u22BF\", lsaquo: \"\\u2039\", lscr: \"\\u{1D4C1}\", Lscr: \"\\u2112\", lsh: \"\\u21B0\", Lsh: \"\\u21B0\", lsim: \"\\u2272\", lsime: \"\\u2A8D\", lsimg: \"\\u2A8F\", lsqb: \"[\", lsquo: \"\\u2018\", lsquor: \"\\u201A\", Lstrok: \"\\u0141\", lstrok: \"\\u0142\", ltcc: \"\\u2AA6\", ltcir: \"\\u2A79\", lt: \"<\", LT: \"<\", Lt: \"\\u226A\", ltdot: \"\\u22D6\", lthree: \"\\u22CB\", ltimes: \"\\u22C9\", ltlarr: \"\\u2976\", ltquest: \"\\u2A7B\", ltri: \"\\u25C3\", ltrie: \"\\u22B4\", ltrif: \"\\u25C2\", ltrPar: \"\\u2996\", lurdshar: \"\\u294A\", luruhar: \"\\u2966\", lvertneqq: \"\\u2268\\uFE00\", lvnE: \"\\u2268\\uFE00\", macr: \"\\xAF\", male: \"\\u2642\", malt: \"\\u2720\", maltese: \"\\u2720\", Map: \"\\u2905\", map: \"\\u21A6\", mapsto: \"\\u21A6\", mapstodown: \"\\u21A7\", mapstoleft: \"\\u21A4\", mapstoup: \"\\u21A5\", marker: \"\\u25AE\", mcomma: \"\\u2A29\", Mcy: \"\\u041C\", mcy: \"\\u043C\", mdash: \"\\u2014\", mDDot: \"\\u223A\", measuredangle: \"\\u2221\", MediumSpace: \"\\u205F\", Mellintrf: \"\\u2133\", Mfr: \"\\u{1D510}\", mfr: \"\\u{1D52A}\", mho: \"\\u2127\", micro: \"\\xB5\", midast: \"*\", midcir: \"\\u2AF0\", mid: \"\\u2223\", middot: \"\\xB7\", minusb: \"\\u229F\", minus: \"\\u2212\", minusd: \"\\u2238\", minusdu: \"\\u2A2A\", MinusPlus: \"\\u2213\", mlcp: \"\\u2ADB\", mldr: \"\\u2026\", mnplus: \"\\u2213\", models: \"\\u22A7\", Mopf: \"\\u{1D544}\", mopf: \"\\u{1D55E}\", mp: \"\\u2213\", mscr: \"\\u{1D4C2}\", Mscr: \"\\u2133\", mstpos: \"\\u223E\", Mu: \"\\u039C\", mu: \"\\u03BC\", multimap: \"\\u22B8\", mumap: \"\\u22B8\", nabla: \"\\u2207\", Nacute: \"\\u0143\", nacute: \"\\u0144\", nang: \"\\u2220\\u20D2\", nap: \"\\u2249\", napE: \"\\u2A70\\u0338\", napid: \"\\u224B\\u0338\", napos: \"\\u0149\", napprox: \"\\u2249\", natural: \"\\u266E\", naturals: \"\\u2115\", natur: \"\\u266E\", nbsp: \"\\xA0\", nbump: \"\\u224E\\u0338\", nbumpe: \"\\u224F\\u0338\", ncap: \"\\u2A43\", Ncaron: \"\\u0147\", ncaron: \"\\u0148\", Ncedil: \"\\u0145\", ncedil: \"\\u0146\", ncong: \"\\u2247\", ncongdot: \"\\u2A6D\\u0338\", ncup: \"\\u2A42\", Ncy: \"\\u041D\", ncy: \"\\u043D\", ndash: \"\\u2013\", nearhk: \"\\u2924\", nearr: \"\\u2197\", neArr: \"\\u21D7\", nearrow: \"\\u2197\", ne: \"\\u2260\", nedot: \"\\u2250\\u0338\", NegativeMediumSpace: \"\\u200B\", NegativeThickSpace: \"\\u200B\", NegativeThinSpace: \"\\u200B\", NegativeVeryThinSpace: \"\\u200B\", nequiv: \"\\u2262\", nesear: \"\\u2928\", nesim: \"\\u2242\\u0338\", NestedGreaterGreater: \"\\u226B\", NestedLessLess: \"\\u226A\", NewLine: \"\\n\", nexist: \"\\u2204\", nexists: \"\\u2204\", Nfr: \"\\u{1D511}\", nfr: \"\\u{1D52B}\", ngE: \"\\u2267\\u0338\", nge: \"\\u2271\", ngeq: \"\\u2271\", ngeqq: \"\\u2267\\u0338\", ngeqslant: \"\\u2A7E\\u0338\", nges: \"\\u2A7E\\u0338\", nGg: \"\\u22D9\\u0338\", ngsim: \"\\u2275\", nGt: \"\\u226B\\u20D2\", ngt: \"\\u226F\", ngtr: \"\\u226F\", nGtv: \"\\u226B\\u0338\", nharr: \"\\u21AE\", nhArr: \"\\u21CE\", nhpar: \"\\u2AF2\", ni: \"\\u220B\", nis: \"\\u22FC\", nisd: \"\\u22FA\", niv: \"\\u220B\", NJcy: \"\\u040A\", njcy: \"\\u045A\", nlarr: \"\\u219A\", nlArr: \"\\u21CD\", nldr: \"\\u2025\", nlE: \"\\u2266\\u0338\", nle: \"\\u2270\", nleftarrow: \"\\u219A\", nLeftarrow: \"\\u21CD\", nleftrightarrow: \"\\u21AE\", nLeftrightarrow: \"\\u21CE\", nleq: \"\\u2270\", nleqq: \"\\u2266\\u0338\", nleqslant: \"\\u2A7D\\u0338\", nles: \"\\u2A7D\\u0338\", nless: \"\\u226E\", nLl: \"\\u22D8\\u0338\", nlsim: \"\\u2274\", nLt: \"\\u226A\\u20D2\", nlt: \"\\u226E\", nltri: \"\\u22EA\", nltrie: \"\\u22EC\", nLtv: \"\\u226A\\u0338\", nmid: \"\\u2224\", NoBreak: \"\\u2060\", NonBreakingSpace: \"\\xA0\", nopf: \"\\u{1D55F}\", Nopf: \"\\u2115\", Not: \"\\u2AEC\", not: \"\\xAC\", NotCongruent: \"\\u2262\", NotCupCap: \"\\u226D\", NotDoubleVerticalBar: \"\\u2226\", NotElement: \"\\u2209\", NotEqual: \"\\u2260\", NotEqualTilde: \"\\u2242\\u0338\", NotExists: \"\\u2204\", NotGreater: \"\\u226F\", NotGreaterEqual: \"\\u2271\", NotGreaterFullEqual: \"\\u2267\\u0338\", NotGreaterGreater: \"\\u226B\\u0338\", NotGreaterLess: \"\\u2279\", NotGreaterSlantEqual: \"\\u2A7E\\u0338\", NotGreaterTilde: \"\\u2275\", NotHumpDownHump: \"\\u224E\\u0338\", NotHumpEqual: \"\\u224F\\u0338\", notin: \"\\u2209\", notindot: \"\\u22F5\\u0338\", notinE: \"\\u22F9\\u0338\", notinva: \"\\u2209\", notinvb: \"\\u22F7\", notinvc: \"\\u22F6\", NotLeftTriangleBar: \"\\u29CF\\u0338\", NotLeftTriangle: \"\\u22EA\", NotLeftTriangleEqual: \"\\u22EC\", NotLess: \"\\u226E\", NotLessEqual: \"\\u2270\", NotLessGreater: \"\\u2278\", NotLessLess: \"\\u226A\\u0338\", NotLessSlantEqual: \"\\u2A7D\\u0338\", NotLessTilde: \"\\u2274\", NotNestedGreaterGreater: \"\\u2AA2\\u0338\", NotNestedLessLess: \"\\u2AA1\\u0338\", notni: \"\\u220C\", notniva: \"\\u220C\", notnivb: \"\\u22FE\", notnivc: \"\\u22FD\", NotPrecedes: \"\\u2280\", NotPrecedesEqual: \"\\u2AAF\\u0338\", NotPrecedesSlantEqual: \"\\u22E0\", NotReverseElement: \"\\u220C\", NotRightTriangleBar: \"\\u29D0\\u0338\", NotRightTriangle: \"\\u22EB\", NotRightTriangleEqual: \"\\u22ED\", NotSquareSubset: \"\\u228F\\u0338\", NotSquareSubsetEqual: \"\\u22E2\", NotSquareSuperset: \"\\u2290\\u0338\", NotSquareSupersetEqual: \"\\u22E3\", NotSubset: \"\\u2282\\u20D2\", NotSubsetEqual: \"\\u2288\", NotSucceeds: \"\\u2281\", NotSucceedsEqual: \"\\u2AB0\\u0338\", NotSucceedsSlantEqual: \"\\u22E1\", NotSucceedsTilde: \"\\u227F\\u0338\", NotSuperset: \"\\u2283\\u20D2\", NotSupersetEqual: \"\\u2289\", NotTilde: \"\\u2241\", NotTildeEqual: \"\\u2244\", NotTildeFullEqual: \"\\u2247\", NotTildeTilde: \"\\u2249\", NotVerticalBar: \"\\u2224\", nparallel: \"\\u2226\", npar: \"\\u2226\", nparsl: \"\\u2AFD\\u20E5\", npart: \"\\u2202\\u0338\", npolint: \"\\u2A14\", npr: \"\\u2280\", nprcue: \"\\u22E0\", nprec: \"\\u2280\", npreceq: \"\\u2AAF\\u0338\", npre: \"\\u2AAF\\u0338\", nrarrc: \"\\u2933\\u0338\", nrarr: \"\\u219B\", nrArr: \"\\u21CF\", nrarrw: \"\\u219D\\u0338\", nrightarrow: \"\\u219B\", nRightarrow: \"\\u21CF\", nrtri: \"\\u22EB\", nrtrie: \"\\u22ED\", nsc: \"\\u2281\", nsccue: \"\\u22E1\", nsce: \"\\u2AB0\\u0338\", Nscr: \"\\u{1D4A9}\", nscr: \"\\u{1D4C3}\", nshortmid: \"\\u2224\", nshortparallel: \"\\u2226\", nsim: \"\\u2241\", nsime: \"\\u2244\", nsimeq: \"\\u2244\", nsmid: \"\\u2224\", nspar: \"\\u2226\", nsqsube: \"\\u22E2\", nsqsupe: \"\\u22E3\", nsub: \"\\u2284\", nsubE: \"\\u2AC5\\u0338\", nsube: \"\\u2288\", nsubset: \"\\u2282\\u20D2\", nsubseteq: \"\\u2288\", nsubseteqq: \"\\u2AC5\\u0338\", nsucc: \"\\u2281\", nsucceq: \"\\u2AB0\\u0338\", nsup: \"\\u2285\", nsupE: \"\\u2AC6\\u0338\", nsupe: \"\\u2289\", nsupset: \"\\u2283\\u20D2\", nsupseteq: \"\\u2289\", nsupseteqq: \"\\u2AC6\\u0338\", ntgl: \"\\u2279\", Ntilde: \"\\xD1\", ntilde: \"\\xF1\", ntlg: \"\\u2278\", ntriangleleft: \"\\u22EA\", ntrianglelefteq: \"\\u22EC\", ntriangleright: \"\\u22EB\", ntrianglerighteq: \"\\u22ED\", Nu: \"\\u039D\", nu: \"\\u03BD\", num: \"#\", numero: \"\\u2116\", numsp: \"\\u2007\", nvap: \"\\u224D\\u20D2\", nvdash: \"\\u22AC\", nvDash: \"\\u22AD\", nVdash: \"\\u22AE\", nVDash: \"\\u22AF\", nvge: \"\\u2265\\u20D2\", nvgt: \">\\u20D2\", nvHarr: \"\\u2904\", nvinfin: \"\\u29DE\", nvlArr: \"\\u2902\", nvle: \"\\u2264\\u20D2\", nvlt: \"<\\u20D2\", nvltrie: \"\\u22B4\\u20D2\", nvrArr: \"\\u2903\", nvrtrie: \"\\u22B5\\u20D2\", nvsim: \"\\u223C\\u20D2\", nwarhk: \"\\u2923\", nwarr: \"\\u2196\", nwArr: \"\\u21D6\", nwarrow: \"\\u2196\", nwnear: \"\\u2927\", Oacute: \"\\xD3\", oacute: \"\\xF3\", oast: \"\\u229B\", Ocirc: \"\\xD4\", ocirc: \"\\xF4\", ocir: \"\\u229A\", Ocy: \"\\u041E\", ocy: \"\\u043E\", odash: \"\\u229D\", Odblac: \"\\u0150\", odblac: \"\\u0151\", odiv: \"\\u2A38\", odot: \"\\u2299\", odsold: \"\\u29BC\", OElig: \"\\u0152\", oelig: \"\\u0153\", ofcir: \"\\u29BF\", Ofr: \"\\u{1D512}\", ofr: \"\\u{1D52C}\", ogon: \"\\u02DB\", Ograve: \"\\xD2\", ograve: \"\\xF2\", ogt: \"\\u29C1\", ohbar: \"\\u29B5\", ohm: \"\\u03A9\", oint: \"\\u222E\", olarr: \"\\u21BA\", olcir: \"\\u29BE\", olcross: \"\\u29BB\", oline: \"\\u203E\", olt: \"\\u29C0\", Omacr: \"\\u014C\", omacr: \"\\u014D\", Omega: \"\\u03A9\", omega: \"\\u03C9\", Omicron: \"\\u039F\", omicron: \"\\u03BF\", omid: \"\\u29B6\", ominus: \"\\u2296\", Oopf: \"\\u{1D546}\", oopf: \"\\u{1D560}\", opar: \"\\u29B7\", OpenCurlyDoubleQuote: \"\\u201C\", OpenCurlyQuote: \"\\u2018\", operp: \"\\u29B9\", oplus: \"\\u2295\", orarr: \"\\u21BB\", Or: \"\\u2A54\", or: \"\\u2228\", ord: \"\\u2A5D\", order: \"\\u2134\", orderof: \"\\u2134\", ordf: \"\\xAA\", ordm: \"\\xBA\", origof: \"\\u22B6\", oror: \"\\u2A56\", orslope: \"\\u2A57\", orv: \"\\u2A5B\", oS: \"\\u24C8\", Oscr: \"\\u{1D4AA}\", oscr: \"\\u2134\", Oslash: \"\\xD8\", oslash: \"\\xF8\", osol: \"\\u2298\", Otilde: \"\\xD5\", otilde: \"\\xF5\", otimesas: \"\\u2A36\", Otimes: \"\\u2A37\", otimes: \"\\u2297\", Ouml: \"\\xD6\", ouml: \"\\xF6\", ovbar: \"\\u233D\", OverBar: \"\\u203E\", OverBrace: \"\\u23DE\", OverBracket: \"\\u23B4\", OverParenthesis: \"\\u23DC\", para: \"\\xB6\", parallel: \"\\u2225\", par: \"\\u2225\", parsim: \"\\u2AF3\", parsl: \"\\u2AFD\", part: \"\\u2202\", PartialD: \"\\u2202\", Pcy: \"\\u041F\", pcy: \"\\u043F\", percnt: \"%\", period: \".\", permil: \"\\u2030\", perp: \"\\u22A5\", pertenk: \"\\u2031\", Pfr: \"\\u{1D513}\", pfr: \"\\u{1D52D}\", Phi: \"\\u03A6\", phi: \"\\u03C6\", phiv: \"\\u03D5\", phmmat: \"\\u2133\", phone: \"\\u260E\", Pi: \"\\u03A0\", pi: \"\\u03C0\", pitchfork: \"\\u22D4\", piv: \"\\u03D6\", planck: \"\\u210F\", planckh: \"\\u210E\", plankv: \"\\u210F\", plusacir: \"\\u2A23\", plusb: \"\\u229E\", pluscir: \"\\u2A22\", plus: \"+\", plusdo: \"\\u2214\", plusdu: \"\\u2A25\", pluse: \"\\u2A72\", PlusMinus: \"\\xB1\", plusmn: \"\\xB1\", plussim: \"\\u2A26\", plustwo: \"\\u2A27\", pm: \"\\xB1\", Poincareplane: \"\\u210C\", pointint: \"\\u2A15\", popf: \"\\u{1D561}\", Popf: \"\\u2119\", pound: \"\\xA3\", prap: \"\\u2AB7\", Pr: \"\\u2ABB\", pr: \"\\u227A\", prcue: \"\\u227C\", precapprox: \"\\u2AB7\", prec: \"\\u227A\", preccurlyeq: \"\\u227C\", Precedes: \"\\u227A\", PrecedesEqual: \"\\u2AAF\", PrecedesSlantEqual: \"\\u227C\", PrecedesTilde: \"\\u227E\", preceq: \"\\u2AAF\", precnapprox: \"\\u2AB9\", precneqq: \"\\u2AB5\", precnsim: \"\\u22E8\", pre: \"\\u2AAF\", prE: \"\\u2AB3\", precsim: \"\\u227E\", prime: \"\\u2032\", Prime: \"\\u2033\", primes: \"\\u2119\", prnap: \"\\u2AB9\", prnE: \"\\u2AB5\", prnsim: \"\\u22E8\", prod: \"\\u220F\", Product: \"\\u220F\", profalar: \"\\u232E\", profline: \"\\u2312\", profsurf: \"\\u2313\", prop: \"\\u221D\", Proportional: \"\\u221D\", Proportion: \"\\u2237\", propto: \"\\u221D\", prsim: \"\\u227E\", prurel: \"\\u22B0\", Pscr: \"\\u{1D4AB}\", pscr: \"\\u{1D4C5}\", Psi: \"\\u03A8\", psi: \"\\u03C8\", puncsp: \"\\u2008\", Qfr: \"\\u{1D514}\", qfr: \"\\u{1D52E}\", qint: \"\\u2A0C\", qopf: \"\\u{1D562}\", Qopf: \"\\u211A\", qprime: \"\\u2057\", Qscr: \"\\u{1D4AC}\", qscr: \"\\u{1D4C6}\", quaternions: \"\\u210D\", quatint: \"\\u2A16\", quest: \"?\", questeq: \"\\u225F\", quot: '\"', QUOT: '\"', rAarr: \"\\u21DB\", race: \"\\u223D\\u0331\", Racute: \"\\u0154\", racute: \"\\u0155\", radic: \"\\u221A\", raemptyv: \"\\u29B3\", rang: \"\\u27E9\", Rang: \"\\u27EB\", rangd: \"\\u2992\", range: \"\\u29A5\", rangle: \"\\u27E9\", raquo: \"\\xBB\", rarrap: \"\\u2975\", rarrb: \"\\u21E5\", rarrbfs: \"\\u2920\", rarrc: \"\\u2933\", rarr: \"\\u2192\", Rarr: \"\\u21A0\", rArr: \"\\u21D2\", rarrfs: \"\\u291E\", rarrhk: \"\\u21AA\", rarrlp: \"\\u21AC\", rarrpl: \"\\u2945\", rarrsim: \"\\u2974\", Rarrtl: \"\\u2916\", rarrtl: \"\\u21A3\", rarrw: \"\\u219D\", ratail: \"\\u291A\", rAtail: \"\\u291C\", ratio: \"\\u2236\", rationals: \"\\u211A\", rbarr: \"\\u290D\", rBarr: \"\\u290F\", RBarr: \"\\u2910\", rbbrk: \"\\u2773\", rbrace: \"}\", rbrack: \"]\", rbrke: \"\\u298C\", rbrksld: \"\\u298E\", rbrkslu: \"\\u2990\", Rcaron: \"\\u0158\", rcaron: \"\\u0159\", Rcedil: \"\\u0156\", rcedil: \"\\u0157\", rceil: \"\\u2309\", rcub: \"}\", Rcy: \"\\u0420\", rcy: \"\\u0440\", rdca: \"\\u2937\", rdldhar: \"\\u2969\", rdquo: \"\\u201D\", rdquor: \"\\u201D\", rdsh: \"\\u21B3\", real: \"\\u211C\", realine: \"\\u211B\", realpart: \"\\u211C\", reals: \"\\u211D\", Re: \"\\u211C\", rect: \"\\u25AD\", reg: \"\\xAE\", REG: \"\\xAE\", ReverseElement: \"\\u220B\", ReverseEquilibrium: \"\\u21CB\", ReverseUpEquilibrium: \"\\u296F\", rfisht: \"\\u297D\", rfloor: \"\\u230B\", rfr: \"\\u{1D52F}\", Rfr: \"\\u211C\", rHar: \"\\u2964\", rhard: \"\\u21C1\", rharu: \"\\u21C0\", rharul: \"\\u296C\", Rho: \"\\u03A1\", rho: \"\\u03C1\", rhov: \"\\u03F1\", RightAngleBracket: \"\\u27E9\", RightArrowBar: \"\\u21E5\", rightarrow: \"\\u2192\", RightArrow: \"\\u2192\", Rightarrow: \"\\u21D2\", RightArrowLeftArrow: \"\\u21C4\", rightarrowtail: \"\\u21A3\", RightCeiling: \"\\u2309\", RightDoubleBracket: \"\\u27E7\", RightDownTeeVector: \"\\u295D\", RightDownVectorBar: \"\\u2955\", RightDownVector: \"\\u21C2\", RightFloor: \"\\u230B\", rightharpoondown: \"\\u21C1\", rightharpoonup: \"\\u21C0\", rightleftarrows: \"\\u21C4\", rightleftharpoons: \"\\u21CC\", rightrightarrows: \"\\u21C9\", rightsquigarrow: \"\\u219D\", RightTeeArrow: \"\\u21A6\", RightTee: \"\\u22A2\", RightTeeVector: \"\\u295B\", rightthreetimes: \"\\u22CC\", RightTriangleBar: \"\\u29D0\", RightTriangle: \"\\u22B3\", RightTriangleEqual: \"\\u22B5\", RightUpDownVector: \"\\u294F\", RightUpTeeVector: \"\\u295C\", RightUpVectorBar: \"\\u2954\", RightUpVector: \"\\u21BE\", RightVectorBar: \"\\u2953\", RightVector: \"\\u21C0\", ring: \"\\u02DA\", risingdotseq: \"\\u2253\", rlarr: \"\\u21C4\", rlhar: \"\\u21CC\", rlm: \"\\u200F\", rmoustache: \"\\u23B1\", rmoust: \"\\u23B1\", rnmid: \"\\u2AEE\", roang: \"\\u27ED\", roarr: \"\\u21FE\", robrk: \"\\u27E7\", ropar: \"\\u2986\", ropf: \"\\u{1D563}\", Ropf: \"\\u211D\", roplus: \"\\u2A2E\", rotimes: \"\\u2A35\", RoundImplies: \"\\u2970\", rpar: \")\", rpargt: \"\\u2994\", rppolint: \"\\u2A12\", rrarr: \"\\u21C9\", Rrightarrow: \"\\u21DB\", rsaquo: \"\\u203A\", rscr: \"\\u{1D4C7}\", Rscr: \"\\u211B\", rsh: \"\\u21B1\", Rsh: \"\\u21B1\", rsqb: \"]\", rsquo: \"\\u2019\", rsquor: \"\\u2019\", rthree: \"\\u22CC\", rtimes: \"\\u22CA\", rtri: \"\\u25B9\", rtrie: \"\\u22B5\", rtrif: \"\\u25B8\", rtriltri: \"\\u29CE\", RuleDelayed: \"\\u29F4\", ruluhar: \"\\u2968\", rx: \"\\u211E\", Sacute: \"\\u015A\", sacute: \"\\u015B\", sbquo: \"\\u201A\", scap: \"\\u2AB8\", Scaron: \"\\u0160\", scaron: \"\\u0161\", Sc: \"\\u2ABC\", sc: \"\\u227B\", sccue: \"\\u227D\", sce: \"\\u2AB0\", scE: \"\\u2AB4\", Scedil: \"\\u015E\", scedil: \"\\u015F\", Scirc: \"\\u015C\", scirc: \"\\u015D\", scnap: \"\\u2ABA\", scnE: \"\\u2AB6\", scnsim: \"\\u22E9\", scpolint: \"\\u2A13\", scsim: \"\\u227F\", Scy: \"\\u0421\", scy: \"\\u0441\", sdotb: \"\\u22A1\", sdot: \"\\u22C5\", sdote: \"\\u2A66\", searhk: \"\\u2925\", searr: \"\\u2198\", seArr: \"\\u21D8\", searrow: \"\\u2198\", sect: \"\\xA7\", semi: \";\", seswar: \"\\u2929\", setminus: \"\\u2216\", setmn: \"\\u2216\", sext: \"\\u2736\", Sfr: \"\\u{1D516}\", sfr: \"\\u{1D530}\", sfrown: \"\\u2322\", sharp: \"\\u266F\", SHCHcy: \"\\u0429\", shchcy: \"\\u0449\", SHcy: \"\\u0428\", shcy: \"\\u0448\", ShortDownArrow: \"\\u2193\", ShortLeftArrow: \"\\u2190\", shortmid: \"\\u2223\", shortparallel: \"\\u2225\", ShortRightArrow: \"\\u2192\", ShortUpArrow: \"\\u2191\", shy: \"\\xAD\", Sigma: \"\\u03A3\", sigma: \"\\u03C3\", sigmaf: \"\\u03C2\", sigmav: \"\\u03C2\", sim: \"\\u223C\", simdot: \"\\u2A6A\", sime: \"\\u2243\", simeq: \"\\u2243\", simg: \"\\u2A9E\", simgE: \"\\u2AA0\", siml: \"\\u2A9D\", simlE: \"\\u2A9F\", simne: \"\\u2246\", simplus: \"\\u2A24\", simrarr: \"\\u2972\", slarr: \"\\u2190\", SmallCircle: \"\\u2218\", smallsetminus: \"\\u2216\", smashp: \"\\u2A33\", smeparsl: \"\\u29E4\", smid: \"\\u2223\", smile: \"\\u2323\", smt: \"\\u2AAA\", smte: \"\\u2AAC\", smtes: \"\\u2AAC\\uFE00\", SOFTcy: \"\\u042C\", softcy: \"\\u044C\", solbar: \"\\u233F\", solb: \"\\u29C4\", sol: \"/\", Sopf: \"\\u{1D54A}\", sopf: \"\\u{1D564}\", spades: \"\\u2660\", spadesuit: \"\\u2660\", spar: \"\\u2225\", sqcap: \"\\u2293\", sqcaps: \"\\u2293\\uFE00\", sqcup: \"\\u2294\", sqcups: \"\\u2294\\uFE00\", Sqrt: \"\\u221A\", sqsub: \"\\u228F\", sqsube: \"\\u2291\", sqsubset: \"\\u228F\", sqsubseteq: \"\\u2291\", sqsup: \"\\u2290\", sqsupe: \"\\u2292\", sqsupset: \"\\u2290\", sqsupseteq: \"\\u2292\", square: \"\\u25A1\", Square: \"\\u25A1\", SquareIntersection: \"\\u2293\", SquareSubset: \"\\u228F\", SquareSubsetEqual: \"\\u2291\", SquareSuperset: \"\\u2290\", SquareSupersetEqual: \"\\u2292\", SquareUnion: \"\\u2294\", squarf: \"\\u25AA\", squ: \"\\u25A1\", squf: \"\\u25AA\", srarr: \"\\u2192\", Sscr: \"\\u{1D4AE}\", sscr: \"\\u{1D4C8}\", ssetmn: \"\\u2216\", ssmile: \"\\u2323\", sstarf: \"\\u22C6\", Star: \"\\u22C6\", star: \"\\u2606\", starf: \"\\u2605\", straightepsilon: \"\\u03F5\", straightphi: \"\\u03D5\", strns: \"\\xAF\", sub: \"\\u2282\", Sub: \"\\u22D0\", subdot: \"\\u2ABD\", subE: \"\\u2AC5\", sube: \"\\u2286\", subedot: \"\\u2AC3\", submult: \"\\u2AC1\", subnE: \"\\u2ACB\", subne: \"\\u228A\", subplus: \"\\u2ABF\", subrarr: \"\\u2979\", subset: \"\\u2282\", Subset: \"\\u22D0\", subseteq: \"\\u2286\", subseteqq: \"\\u2AC5\", SubsetEqual: \"\\u2286\", subsetneq: \"\\u228A\", subsetneqq: \"\\u2ACB\", subsim: \"\\u2AC7\", subsub: \"\\u2AD5\", subsup: \"\\u2AD3\", succapprox: \"\\u2AB8\", succ: \"\\u227B\", succcurlyeq: \"\\u227D\", Succeeds: \"\\u227B\", SucceedsEqual: \"\\u2AB0\", SucceedsSlantEqual: \"\\u227D\", SucceedsTilde: \"\\u227F\", succeq: \"\\u2AB0\", succnapprox: \"\\u2ABA\", succneqq: \"\\u2AB6\", succnsim: \"\\u22E9\", succsim: \"\\u227F\", SuchThat: \"\\u220B\", sum: \"\\u2211\", Sum: \"\\u2211\", sung: \"\\u266A\", sup1: \"\\xB9\", sup2: \"\\xB2\", sup3: \"\\xB3\", sup: \"\\u2283\", Sup: \"\\u22D1\", supdot: \"\\u2ABE\", supdsub: \"\\u2AD8\", supE: \"\\u2AC6\", supe: \"\\u2287\", supedot: \"\\u2AC4\", Superset: \"\\u2283\", SupersetEqual: \"\\u2287\", suphsol: \"\\u27C9\", suphsub: \"\\u2AD7\", suplarr: \"\\u297B\", supmult: \"\\u2AC2\", supnE: \"\\u2ACC\", supne: \"\\u228B\", supplus: \"\\u2AC0\", supset: \"\\u2283\", Supset: \"\\u22D1\", supseteq: \"\\u2287\", supseteqq: \"\\u2AC6\", supsetneq: \"\\u228B\", supsetneqq: \"\\u2ACC\", supsim: \"\\u2AC8\", supsub: \"\\u2AD4\", supsup: \"\\u2AD6\", swarhk: \"\\u2926\", swarr: \"\\u2199\", swArr: \"\\u21D9\", swarrow: \"\\u2199\", swnwar: \"\\u292A\", szlig: \"\\xDF\", Tab: \"\t\", target: \"\\u2316\", Tau: \"\\u03A4\", tau: \"\\u03C4\", tbrk: \"\\u23B4\", Tcaron: \"\\u0164\", tcaron: \"\\u0165\", Tcedil: \"\\u0162\", tcedil: \"\\u0163\", Tcy: \"\\u0422\", tcy: \"\\u0442\", tdot: \"\\u20DB\", telrec: \"\\u2315\", Tfr: \"\\u{1D517}\", tfr: \"\\u{1D531}\", there4: \"\\u2234\", therefore: \"\\u2234\", Therefore: \"\\u2234\", Theta: \"\\u0398\", theta: \"\\u03B8\", thetasym: \"\\u03D1\", thetav: \"\\u03D1\", thickapprox: \"\\u2248\", thicksim: \"\\u223C\", ThickSpace: \"\\u205F\\u200A\", ThinSpace: \"\\u2009\", thinsp: \"\\u2009\", thkap: \"\\u2248\", thksim: \"\\u223C\", THORN: \"\\xDE\", thorn: \"\\xFE\", tilde: \"\\u02DC\", Tilde: \"\\u223C\", TildeEqual: \"\\u2243\", TildeFullEqual: \"\\u2245\", TildeTilde: \"\\u2248\", timesbar: \"\\u2A31\", timesb: \"\\u22A0\", times: \"\\xD7\", timesd: \"\\u2A30\", tint: \"\\u222D\", toea: \"\\u2928\", topbot: \"\\u2336\", topcir: \"\\u2AF1\", top: \"\\u22A4\", Topf: \"\\u{1D54B}\", topf: \"\\u{1D565}\", topfork: \"\\u2ADA\", tosa: \"\\u2929\", tprime: \"\\u2034\", trade: \"\\u2122\", TRADE: \"\\u2122\", triangle: \"\\u25B5\", triangledown: \"\\u25BF\", triangleleft: \"\\u25C3\", trianglelefteq: \"\\u22B4\", triangleq: \"\\u225C\", triangleright: \"\\u25B9\", trianglerighteq: \"\\u22B5\", tridot: \"\\u25EC\", trie: \"\\u225C\", triminus: \"\\u2A3A\", TripleDot: \"\\u20DB\", triplus: \"\\u2A39\", trisb: \"\\u29CD\", tritime: \"\\u2A3B\", trpezium: \"\\u23E2\", Tscr: \"\\u{1D4AF}\", tscr: \"\\u{1D4C9}\", TScy: \"\\u0426\", tscy: \"\\u0446\", TSHcy: \"\\u040B\", tshcy: \"\\u045B\", Tstrok: \"\\u0166\", tstrok: \"\\u0167\", twixt: \"\\u226C\", twoheadleftarrow: \"\\u219E\", twoheadrightarrow: \"\\u21A0\", Uacute: \"\\xDA\", uacute: \"\\xFA\", uarr: \"\\u2191\", Uarr: \"\\u219F\", uArr: \"\\u21D1\", Uarrocir: \"\\u2949\", Ubrcy: \"\\u040E\", ubrcy: \"\\u045E\", Ubreve: \"\\u016C\", ubreve: \"\\u016D\", Ucirc: \"\\xDB\", ucirc: \"\\xFB\", Ucy: \"\\u0423\", ucy: \"\\u0443\", udarr: \"\\u21C5\", Udblac: \"\\u0170\", udblac: \"\\u0171\", udhar: \"\\u296E\", ufisht: \"\\u297E\", Ufr: \"\\u{1D518}\", ufr: \"\\u{1D532}\", Ugrave: \"\\xD9\", ugrave: \"\\xF9\", uHar: \"\\u2963\", uharl: \"\\u21BF\", uharr: \"\\u21BE\", uhblk: \"\\u2580\", ulcorn: \"\\u231C\", ulcorner: \"\\u231C\", ulcrop: \"\\u230F\", ultri: \"\\u25F8\", Umacr: \"\\u016A\", umacr: \"\\u016B\", uml: \"\\xA8\", UnderBar: \"_\", UnderBrace: \"\\u23DF\", UnderBracket: \"\\u23B5\", UnderParenthesis: \"\\u23DD\", Union: \"\\u22C3\", UnionPlus: \"\\u228E\", Uogon: \"\\u0172\", uogon: \"\\u0173\", Uopf: \"\\u{1D54C}\", uopf: \"\\u{1D566}\", UpArrowBar: \"\\u2912\", uparrow: \"\\u2191\", UpArrow: \"\\u2191\", Uparrow: \"\\u21D1\", UpArrowDownArrow: \"\\u21C5\", updownarrow: \"\\u2195\", UpDownArrow: \"\\u2195\", Updownarrow: \"\\u21D5\", UpEquilibrium: \"\\u296E\", upharpoonleft: \"\\u21BF\", upharpoonright: \"\\u21BE\", uplus: \"\\u228E\", UpperLeftArrow: \"\\u2196\", UpperRightArrow: \"\\u2197\", upsi: \"\\u03C5\", Upsi: \"\\u03D2\", upsih: \"\\u03D2\", Upsilon: \"\\u03A5\", upsilon: \"\\u03C5\", UpTeeArrow: \"\\u21A5\", UpTee: \"\\u22A5\", upuparrows: \"\\u21C8\", urcorn: \"\\u231D\", urcorner: \"\\u231D\", urcrop: \"\\u230E\", Uring: \"\\u016E\", uring: \"\\u016F\", urtri: \"\\u25F9\", Uscr: \"\\u{1D4B0}\", uscr: \"\\u{1D4CA}\", utdot: \"\\u22F0\", Utilde: \"\\u0168\", utilde: \"\\u0169\", utri: \"\\u25B5\", utrif: \"\\u25B4\", uuarr: \"\\u21C8\", Uuml: \"\\xDC\", uuml: \"\\xFC\", uwangle: \"\\u29A7\", vangrt: \"\\u299C\", varepsilon: \"\\u03F5\", varkappa: \"\\u03F0\", varnothing: \"\\u2205\", varphi: \"\\u03D5\", varpi: \"\\u03D6\", varpropto: \"\\u221D\", varr: \"\\u2195\", vArr: \"\\u21D5\", varrho: \"\\u03F1\", varsigma: \"\\u03C2\", varsubsetneq: \"\\u228A\\uFE00\", varsubsetneqq: \"\\u2ACB\\uFE00\", varsupsetneq: \"\\u228B\\uFE00\", varsupsetneqq: \"\\u2ACC\\uFE00\", vartheta: \"\\u03D1\", vartriangleleft: \"\\u22B2\", vartriangleright: \"\\u22B3\", vBar: \"\\u2AE8\", Vbar: \"\\u2AEB\", vBarv: \"\\u2AE9\", Vcy: \"\\u0412\", vcy: \"\\u0432\", vdash: \"\\u22A2\", vDash: \"\\u22A8\", Vdash: \"\\u22A9\", VDash: \"\\u22AB\", Vdashl: \"\\u2AE6\", veebar: \"\\u22BB\", vee: \"\\u2228\", Vee: \"\\u22C1\", veeeq: \"\\u225A\", vellip: \"\\u22EE\", verbar: \"|\", Verbar: \"\\u2016\", vert: \"|\", Vert: \"\\u2016\", VerticalBar: \"\\u2223\", VerticalLine: \"|\", VerticalSeparator: \"\\u2758\", VerticalTilde: \"\\u2240\", VeryThinSpace: \"\\u200A\", Vfr: \"\\u{1D519}\", vfr: \"\\u{1D533}\", vltri: \"\\u22B2\", vnsub: \"\\u2282\\u20D2\", vnsup: \"\\u2283\\u20D2\", Vopf: \"\\u{1D54D}\", vopf: \"\\u{1D567}\", vprop: \"\\u221D\", vrtri: \"\\u22B3\", Vscr: \"\\u{1D4B1}\", vscr: \"\\u{1D4CB}\", vsubnE: \"\\u2ACB\\uFE00\", vsubne: \"\\u228A\\uFE00\", vsupnE: \"\\u2ACC\\uFE00\", vsupne: \"\\u228B\\uFE00\", Vvdash: \"\\u22AA\", vzigzag: \"\\u299A\", Wcirc: \"\\u0174\", wcirc: \"\\u0175\", wedbar: \"\\u2A5F\", wedge: \"\\u2227\", Wedge: \"\\u22C0\", wedgeq: \"\\u2259\", weierp: \"\\u2118\", Wfr: \"\\u{1D51A}\", wfr: \"\\u{1D534}\", Wopf: \"\\u{1D54E}\", wopf: \"\\u{1D568}\", wp: \"\\u2118\", wr: \"\\u2240\", wreath: \"\\u2240\", Wscr: \"\\u{1D4B2}\", wscr: \"\\u{1D4CC}\", xcap: \"\\u22C2\", xcirc: \"\\u25EF\", xcup: \"\\u22C3\", xdtri: \"\\u25BD\", Xfr: \"\\u{1D51B}\", xfr: \"\\u{1D535}\", xharr: \"\\u27F7\", xhArr: \"\\u27FA\", Xi: \"\\u039E\", xi: \"\\u03BE\", xlarr: \"\\u27F5\", xlArr: \"\\u27F8\", xmap: \"\\u27FC\", xnis: \"\\u22FB\", xodot: \"\\u2A00\", Xopf: \"\\u{1D54F}\", xopf: \"\\u{1D569}\", xoplus: \"\\u2A01\", xotime: \"\\u2A02\", xrarr: \"\\u27F6\", xrArr: \"\\u27F9\", Xscr: \"\\u{1D4B3}\", xscr: \"\\u{1D4CD}\", xsqcup: \"\\u2A06\", xuplus: \"\\u2A04\", xutri: \"\\u25B3\", xvee: \"\\u22C1\", xwedge: \"\\u22C0\", Yacute: \"\\xDD\", yacute: \"\\xFD\", YAcy: \"\\u042F\", yacy: \"\\u044F\", Ycirc: \"\\u0176\", ycirc: \"\\u0177\", Ycy: \"\\u042B\", ycy: \"\\u044B\", yen: \"\\xA5\", Yfr: \"\\u{1D51C}\", yfr: \"\\u{1D536}\", YIcy: \"\\u0407\", yicy: \"\\u0457\", Yopf: \"\\u{1D550}\", yopf: \"\\u{1D56A}\", Yscr: \"\\u{1D4B4}\", yscr: \"\\u{1D4CE}\", YUcy: \"\\u042E\", yucy: \"\\u044E\", yuml: \"\\xFF\", Yuml: \"\\u0178\", Zacute: \"\\u0179\", zacute: \"\\u017A\", Zcaron: \"\\u017D\", zcaron: \"\\u017E\", Zcy: \"\\u0417\", zcy: \"\\u0437\", Zdot: \"\\u017B\", zdot: \"\\u017C\", zeetrf: \"\\u2128\", ZeroWidthSpace: \"\\u200B\", Zeta: \"\\u0396\", zeta: \"\\u03B6\", zfr: \"\\u{1D537}\", Zfr: \"\\u2128\", ZHcy: \"\\u0416\", zhcy: \"\\u0436\", zigrarr: \"\\u21DD\", zopf: \"\\u{1D56B}\", Zopf: \"\\u2124\", Zscr: \"\\u{1D4B5}\", zscr: \"\\u{1D4CF}\", zwj: \"\\u200D\", zwnj: \"\\u200C\" };\n  }\n});\n\n// node_modules/markdown-it/lib/common/entities.js\nvar require_entities2 = __commonJS({\n  \"node_modules/markdown-it/lib/common/entities.js\"(exports, module) {\n    \"use strict\";\n    module.exports = require_entities();\n  }\n});\n\n// node_modules/uc.micro/categories/P/regex.js\nvar require_regex = __commonJS({\n  \"node_modules/uc.micro/categories/P/regex.js\"(exports, module) {\n    module.exports = /[!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4E\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD803[\\uDF55-\\uDF59]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC8\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDC4B-\\uDC4F\\uDC5B\\uDC5D\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDE60-\\uDE6C\\uDF3C-\\uDF3E]|\\uD806[\\uDC3B\\uDE3F-\\uDE46\\uDE9A-\\uDE9C\\uDE9E-\\uDEA2]|\\uD807[\\uDC41-\\uDC45\\uDC70\\uDC71\\uDEF7\\uDEF8]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD81B[\\uDE97-\\uDE9A]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]|\\uD83A[\\uDD5E\\uDD5F]/;\n  }\n});\n\n// node_modules/mdurl/encode.js\nvar require_encode = __commonJS({\n  \"node_modules/mdurl/encode.js\"(exports, module) {\n    \"use strict\";\n    var encodeCache = {};\n    function getEncodeCache(exclude) {\n      var i, ch, cache = encodeCache[exclude];\n      if (cache) {\n        return cache;\n      }\n      cache = encodeCache[exclude] = [];\n      for (i = 0; i < 128; i++) {\n        ch = String.fromCharCode(i);\n        if (/^[0-9a-z]$/i.test(ch)) {\n          cache.push(ch);\n        } else {\n          cache.push(\"%\" + (\"0\" + i.toString(16).toUpperCase()).slice(-2));\n        }\n      }\n      for (i = 0; i < exclude.length; i++) {\n        cache[exclude.charCodeAt(i)] = exclude[i];\n      }\n      return cache;\n    }\n    function encode(string, exclude, keepEscaped) {\n      var i, l, code2, nextCode, cache, result = \"\";\n      if (typeof exclude !== \"string\") {\n        keepEscaped = exclude;\n        exclude = encode.defaultChars;\n      }\n      if (typeof keepEscaped === \"undefined\") {\n        keepEscaped = true;\n      }\n      cache = getEncodeCache(exclude);\n      for (i = 0, l = string.length; i < l; i++) {\n        code2 = string.charCodeAt(i);\n        if (keepEscaped && code2 === 37 && i + 2 < l) {\n          if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n            result += string.slice(i, i + 3);\n            i += 2;\n            continue;\n          }\n        }\n        if (code2 < 128) {\n          result += cache[code2];\n          continue;\n        }\n        if (code2 >= 55296 && code2 <= 57343) {\n          if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {\n            nextCode = string.charCodeAt(i + 1);\n            if (nextCode >= 56320 && nextCode <= 57343) {\n              result += encodeURIComponent(string[i] + string[i + 1]);\n              i++;\n              continue;\n            }\n          }\n          result += \"%EF%BF%BD\";\n          continue;\n        }\n        result += encodeURIComponent(string[i]);\n      }\n      return result;\n    }\n    encode.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\n    encode.componentChars = \"-_.!~*'()\";\n    module.exports = encode;\n  }\n});\n\n// node_modules/mdurl/decode.js\nvar require_decode = __commonJS({\n  \"node_modules/mdurl/decode.js\"(exports, module) {\n    \"use strict\";\n    var decodeCache = {};\n    function getDecodeCache(exclude) {\n      var i, ch, cache = decodeCache[exclude];\n      if (cache) {\n        return cache;\n      }\n      cache = decodeCache[exclude] = [];\n      for (i = 0; i < 128; i++) {\n        ch = String.fromCharCode(i);\n        cache.push(ch);\n      }\n      for (i = 0; i < exclude.length; i++) {\n        ch = exclude.charCodeAt(i);\n        cache[ch] = \"%\" + (\"0\" + ch.toString(16).toUpperCase()).slice(-2);\n      }\n      return cache;\n    }\n    function decode(string, exclude) {\n      var cache;\n      if (typeof exclude !== \"string\") {\n        exclude = decode.defaultChars;\n      }\n      cache = getDecodeCache(exclude);\n      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {\n        var i, l, b1, b2, b3, b4, chr, result = \"\";\n        for (i = 0, l = seq.length; i < l; i += 3) {\n          b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n          if (b1 < 128) {\n            result += cache[b1];\n            continue;\n          }\n          if ((b1 & 224) === 192 && i + 3 < l) {\n            b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n            if ((b2 & 192) === 128) {\n              chr = b1 << 6 & 1984 | b2 & 63;\n              if (chr < 128) {\n                result += \"\\uFFFD\\uFFFD\";\n              } else {\n                result += String.fromCharCode(chr);\n              }\n              i += 3;\n              continue;\n            }\n          }\n          if ((b1 & 240) === 224 && i + 6 < l) {\n            b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n            b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n            if ((b2 & 192) === 128 && (b3 & 192) === 128) {\n              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;\n              if (chr < 2048 || chr >= 55296 && chr <= 57343) {\n                result += \"\\uFFFD\\uFFFD\\uFFFD\";\n              } else {\n                result += String.fromCharCode(chr);\n              }\n              i += 6;\n              continue;\n            }\n          }\n          if ((b1 & 248) === 240 && i + 9 < l) {\n            b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n            b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n            b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {\n              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;\n              if (chr < 65536 || chr > 1114111) {\n                result += \"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\";\n              } else {\n                chr -= 65536;\n                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));\n              }\n              i += 9;\n              continue;\n            }\n          }\n          result += \"\\uFFFD\";\n        }\n        return result;\n      });\n    }\n    decode.defaultChars = \";/?:@&=+$,#\";\n    decode.componentChars = \"\";\n    module.exports = decode;\n  }\n});\n\n// node_modules/mdurl/format.js\nvar require_format = __commonJS({\n  \"node_modules/mdurl/format.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function format2(url) {\n      var result = \"\";\n      result += url.protocol || \"\";\n      result += url.slashes ? \"//\" : \"\";\n      result += url.auth ? url.auth + \"@\" : \"\";\n      if (url.hostname && url.hostname.indexOf(\":\") !== -1) {\n        result += \"[\" + url.hostname + \"]\";\n      } else {\n        result += url.hostname || \"\";\n      }\n      result += url.port ? \":\" + url.port : \"\";\n      result += url.pathname || \"\";\n      result += url.search || \"\";\n      result += url.hash || \"\";\n      return result;\n    };\n  }\n});\n\n// node_modules/mdurl/parse.js\nvar require_parse = __commonJS({\n  \"node_modules/mdurl/parse.js\"(exports, module) {\n    \"use strict\";\n    function Url() {\n      this.protocol = null;\n      this.slashes = null;\n      this.auth = null;\n      this.port = null;\n      this.hostname = null;\n      this.hash = null;\n      this.search = null;\n      this.pathname = null;\n    }\n    var protocolPattern = /^([a-z0-9.+-]+:)/i;\n    var portPattern = /:[0-9]*$/;\n    var simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/;\n    var delims = [\"<\", \">\", '\"', \"`\", \" \", \"\\r\", \"\\n\", \"\t\"];\n    var unwise = [\"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\"].concat(delims);\n    var autoEscape = [\"'\"].concat(unwise);\n    var nonHostChars = [\"%\", \"/\", \"?\", \";\", \"#\"].concat(autoEscape);\n    var hostEndingChars = [\"/\", \"?\", \"#\"];\n    var hostnameMaxLen = 255;\n    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;\n    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;\n    var hostlessProtocol = {\n      \"javascript\": true,\n      \"javascript:\": true\n    };\n    var slashedProtocol = {\n      \"http\": true,\n      \"https\": true,\n      \"ftp\": true,\n      \"gopher\": true,\n      \"file\": true,\n      \"http:\": true,\n      \"https:\": true,\n      \"ftp:\": true,\n      \"gopher:\": true,\n      \"file:\": true\n    };\n    function urlParse(url, slashesDenoteHost) {\n      if (url && url instanceof Url) {\n        return url;\n      }\n      var u = new Url();\n      u.parse(url, slashesDenoteHost);\n      return u;\n    }\n    Url.prototype.parse = function(url, slashesDenoteHost) {\n      var i, l, lowerProto, hec, slashes, rest = url;\n      rest = rest.trim();\n      if (!slashesDenoteHost && url.split(\"#\").length === 1) {\n        var simplePath = simplePathPattern.exec(rest);\n        if (simplePath) {\n          this.pathname = simplePath[1];\n          if (simplePath[2]) {\n            this.search = simplePath[2];\n          }\n          return this;\n        }\n      }\n      var proto = protocolPattern.exec(rest);\n      if (proto) {\n        proto = proto[0];\n        lowerProto = proto.toLowerCase();\n        this.protocol = proto;\n        rest = rest.substr(proto.length);\n      }\n      if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n        slashes = rest.substr(0, 2) === \"//\";\n        if (slashes && !(proto && hostlessProtocol[proto])) {\n          rest = rest.substr(2);\n          this.slashes = true;\n        }\n      }\n      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n        var hostEnd = -1;\n        for (i = 0; i < hostEndingChars.length; i++) {\n          hec = rest.indexOf(hostEndingChars[i]);\n          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n            hostEnd = hec;\n          }\n        }\n        var auth, atSign;\n        if (hostEnd === -1) {\n          atSign = rest.lastIndexOf(\"@\");\n        } else {\n          atSign = rest.lastIndexOf(\"@\", hostEnd);\n        }\n        if (atSign !== -1) {\n          auth = rest.slice(0, atSign);\n          rest = rest.slice(atSign + 1);\n          this.auth = auth;\n        }\n        hostEnd = -1;\n        for (i = 0; i < nonHostChars.length; i++) {\n          hec = rest.indexOf(nonHostChars[i]);\n          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n            hostEnd = hec;\n          }\n        }\n        if (hostEnd === -1) {\n          hostEnd = rest.length;\n        }\n        if (rest[hostEnd - 1] === \":\") {\n          hostEnd--;\n        }\n        var host = rest.slice(0, hostEnd);\n        rest = rest.slice(hostEnd);\n        this.parseHost(host);\n        this.hostname = this.hostname || \"\";\n        var ipv6Hostname = this.hostname[0] === \"[\" && this.hostname[this.hostname.length - 1] === \"]\";\n        if (!ipv6Hostname) {\n          var hostparts = this.hostname.split(/\\./);\n          for (i = 0, l = hostparts.length; i < l; i++) {\n            var part = hostparts[i];\n            if (!part) {\n              continue;\n            }\n            if (!part.match(hostnamePartPattern)) {\n              var newpart = \"\";\n              for (var j = 0, k = part.length; j < k; j++) {\n                if (part.charCodeAt(j) > 127) {\n                  newpart += \"x\";\n                } else {\n                  newpart += part[j];\n                }\n              }\n              if (!newpart.match(hostnamePartPattern)) {\n                var validParts = hostparts.slice(0, i);\n                var notHost = hostparts.slice(i + 1);\n                var bit = part.match(hostnamePartStart);\n                if (bit) {\n                  validParts.push(bit[1]);\n                  notHost.unshift(bit[2]);\n                }\n                if (notHost.length) {\n                  rest = notHost.join(\".\") + rest;\n                }\n                this.hostname = validParts.join(\".\");\n                break;\n              }\n            }\n          }\n        }\n        if (this.hostname.length > hostnameMaxLen) {\n          this.hostname = \"\";\n        }\n        if (ipv6Hostname) {\n          this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n        }\n      }\n      var hash = rest.indexOf(\"#\");\n      if (hash !== -1) {\n        this.hash = rest.substr(hash);\n        rest = rest.slice(0, hash);\n      }\n      var qm = rest.indexOf(\"?\");\n      if (qm !== -1) {\n        this.search = rest.substr(qm);\n        rest = rest.slice(0, qm);\n      }\n      if (rest) {\n        this.pathname = rest;\n      }\n      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n        this.pathname = \"\";\n      }\n      return this;\n    };\n    Url.prototype.parseHost = function(host) {\n      var port = portPattern.exec(host);\n      if (port) {\n        port = port[0];\n        if (port !== \":\") {\n          this.port = port.substr(1);\n        }\n        host = host.substr(0, host.length - port.length);\n      }\n      if (host) {\n        this.hostname = host;\n      }\n    };\n    module.exports = urlParse;\n  }\n});\n\n// node_modules/mdurl/index.js\nvar require_mdurl = __commonJS({\n  \"node_modules/mdurl/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports.encode = require_encode();\n    module.exports.decode = require_decode();\n    module.exports.format = require_format();\n    module.exports.parse = require_parse();\n  }\n});\n\n// node_modules/uc.micro/properties/Any/regex.js\nvar require_regex2 = __commonJS({\n  \"node_modules/uc.micro/properties/Any/regex.js\"(exports, module) {\n    module.exports = /[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n  }\n});\n\n// node_modules/uc.micro/categories/Cc/regex.js\nvar require_regex3 = __commonJS({\n  \"node_modules/uc.micro/categories/Cc/regex.js\"(exports, module) {\n    module.exports = /[\\0-\\x1F\\x7F-\\x9F]/;\n  }\n});\n\n// node_modules/uc.micro/categories/Cf/regex.js\nvar require_regex4 = __commonJS({\n  \"node_modules/uc.micro/categories/Cf/regex.js\"(exports, module) {\n    module.exports = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804[\\uDCBD\\uDCCD]|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/;\n  }\n});\n\n// node_modules/uc.micro/categories/Z/regex.js\nvar require_regex5 = __commonJS({\n  \"node_modules/uc.micro/categories/Z/regex.js\"(exports, module) {\n    module.exports = /[ \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/;\n  }\n});\n\n// node_modules/uc.micro/index.js\nvar require_uc = __commonJS({\n  \"node_modules/uc.micro/index.js\"(exports) {\n    \"use strict\";\n    exports.Any = require_regex2();\n    exports.Cc = require_regex3();\n    exports.Cf = require_regex4();\n    exports.P = require_regex();\n    exports.Z = require_regex5();\n  }\n});\n\n// node_modules/markdown-it/lib/common/utils.js\nvar require_utils = __commonJS({\n  \"node_modules/markdown-it/lib/common/utils.js\"(exports) {\n    \"use strict\";\n    function _class(obj) {\n      return Object.prototype.toString.call(obj);\n    }\n    function isString(obj) {\n      return _class(obj) === \"[object String]\";\n    }\n    var _hasOwnProperty = Object.prototype.hasOwnProperty;\n    function has(object, key) {\n      return _hasOwnProperty.call(object, key);\n    }\n    function assign(obj) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n      sources.forEach(function(source) {\n        if (!source) {\n          return;\n        }\n        if (typeof source !== \"object\") {\n          throw new TypeError(source + \"must be object\");\n        }\n        Object.keys(source).forEach(function(key) {\n          obj[key] = source[key];\n        });\n      });\n      return obj;\n    }\n    function arrayReplaceAt(src, pos, newElements) {\n      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));\n    }\n    function isValidEntityCode(c) {\n      if (c >= 55296 && c <= 57343) {\n        return false;\n      }\n      if (c >= 64976 && c <= 65007) {\n        return false;\n      }\n      if ((c & 65535) === 65535 || (c & 65535) === 65534) {\n        return false;\n      }\n      if (c >= 0 && c <= 8) {\n        return false;\n      }\n      if (c === 11) {\n        return false;\n      }\n      if (c >= 14 && c <= 31) {\n        return false;\n      }\n      if (c >= 127 && c <= 159) {\n        return false;\n      }\n      if (c > 1114111) {\n        return false;\n      }\n      return true;\n    }\n    function fromCodePoint(c) {\n      if (c > 65535) {\n        c -= 65536;\n        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);\n        return String.fromCharCode(surrogate1, surrogate2);\n      }\n      return String.fromCharCode(c);\n    }\n    var UNESCAPE_MD_RE = /\\\\([!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~])/g;\n    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;\n    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + \"|\" + ENTITY_RE.source, \"gi\");\n    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n    var entities = require_entities2();\n    function replaceEntityPattern(match, name) {\n      var code2 = 0;\n      if (has(entities, name)) {\n        return entities[name];\n      }\n      if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {\n        code2 = name[1].toLowerCase() === \"x\" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);\n        if (isValidEntityCode(code2)) {\n          return fromCodePoint(code2);\n        }\n      }\n      return match;\n    }\n    function unescapeMd(str) {\n      if (str.indexOf(\"\\\\\") < 0) {\n        return str;\n      }\n      return str.replace(UNESCAPE_MD_RE, \"$1\");\n    }\n    function unescapeAll(str) {\n      if (str.indexOf(\"\\\\\") < 0 && str.indexOf(\"&\") < 0) {\n        return str;\n      }\n      return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {\n        if (escaped) {\n          return escaped;\n        }\n        return replaceEntityPattern(match, entity);\n      });\n    }\n    var HTML_ESCAPE_TEST_RE = /[&<>\"]/;\n    var HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\n    var HTML_REPLACEMENTS = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': \"&quot;\"\n    };\n    function replaceUnsafeChar(ch) {\n      return HTML_REPLACEMENTS[ch];\n    }\n    function escapeHtml2(str) {\n      if (HTML_ESCAPE_TEST_RE.test(str)) {\n        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n      }\n      return str;\n    }\n    var REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g;\n    function escapeRE(str) {\n      return str.replace(REGEXP_ESCAPE_RE, \"\\\\$&\");\n    }\n    function isSpace(code2) {\n      switch (code2) {\n        case 9:\n        case 32:\n          return true;\n      }\n      return false;\n    }\n    function isWhiteSpace(code2) {\n      if (code2 >= 8192 && code2 <= 8202) {\n        return true;\n      }\n      switch (code2) {\n        case 9:\n        case 10:\n        case 11:\n        case 12:\n        case 13:\n        case 32:\n        case 160:\n        case 5760:\n        case 8239:\n        case 8287:\n        case 12288:\n          return true;\n      }\n      return false;\n    }\n    var UNICODE_PUNCT_RE = require_regex();\n    function isPunctChar(ch) {\n      return UNICODE_PUNCT_RE.test(ch);\n    }\n    function isMdAsciiPunct(ch) {\n      switch (ch) {\n        case 33:\n        case 34:\n        case 35:\n        case 36:\n        case 37:\n        case 38:\n        case 39:\n        case 40:\n        case 41:\n        case 42:\n        case 43:\n        case 44:\n        case 45:\n        case 46:\n        case 47:\n        case 58:\n        case 59:\n        case 60:\n        case 61:\n        case 62:\n        case 63:\n        case 64:\n        case 91:\n        case 92:\n        case 93:\n        case 94:\n        case 95:\n        case 96:\n        case 123:\n        case 124:\n        case 125:\n        case 126:\n          return true;\n        default:\n          return false;\n      }\n    }\n    function normalizeReference(str) {\n      str = str.trim().replace(/\\s+/g, \" \");\n      if (\"\\u1E9E\".toLowerCase() === \"\\u1E7E\") {\n        str = str.replace(//g, \"\\xDF\");\n      }\n      return str.toLowerCase().toUpperCase();\n    }\n    exports.lib = {};\n    exports.lib.mdurl = require_mdurl();\n    exports.lib.ucmicro = require_uc();\n    exports.assign = assign;\n    exports.isString = isString;\n    exports.has = has;\n    exports.unescapeMd = unescapeMd;\n    exports.unescapeAll = unescapeAll;\n    exports.isValidEntityCode = isValidEntityCode;\n    exports.fromCodePoint = fromCodePoint;\n    exports.escapeHtml = escapeHtml2;\n    exports.arrayReplaceAt = arrayReplaceAt;\n    exports.isSpace = isSpace;\n    exports.isWhiteSpace = isWhiteSpace;\n    exports.isMdAsciiPunct = isMdAsciiPunct;\n    exports.isPunctChar = isPunctChar;\n    exports.escapeRE = escapeRE;\n    exports.normalizeReference = normalizeReference;\n  }\n});\n\n// node_modules/markdown-it/lib/helpers/parse_link_label.js\nvar require_parse_link_label = __commonJS({\n  \"node_modules/markdown-it/lib/helpers/parse_link_label.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function parseLinkLabel(state, start, disableNested) {\n      var level, found, marker, prevPos, labelEnd = -1, max2 = state.posMax, oldPos = state.pos;\n      state.pos = start + 1;\n      level = 1;\n      while (state.pos < max2) {\n        marker = state.src.charCodeAt(state.pos);\n        if (marker === 93) {\n          level--;\n          if (level === 0) {\n            found = true;\n            break;\n          }\n        }\n        prevPos = state.pos;\n        state.md.inline.skipToken(state);\n        if (marker === 91) {\n          if (prevPos === state.pos - 1) {\n            level++;\n          } else if (disableNested) {\n            state.pos = oldPos;\n            return -1;\n          }\n        }\n      }\n      if (found) {\n        labelEnd = state.pos;\n      }\n      state.pos = oldPos;\n      return labelEnd;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/helpers/parse_link_destination.js\nvar require_parse_link_destination = __commonJS({\n  \"node_modules/markdown-it/lib/helpers/parse_link_destination.js\"(exports, module) {\n    \"use strict\";\n    var unescapeAll = require_utils().unescapeAll;\n    module.exports = function parseLinkDestination(str, pos, max2) {\n      var code2, level, lines = 0, start = pos, result = {\n        ok: false,\n        pos: 0,\n        lines: 0,\n        str: \"\"\n      };\n      if (str.charCodeAt(pos) === 60) {\n        pos++;\n        while (pos < max2) {\n          code2 = str.charCodeAt(pos);\n          if (code2 === 10) {\n            return result;\n          }\n          if (code2 === 60) {\n            return result;\n          }\n          if (code2 === 62) {\n            result.pos = pos + 1;\n            result.str = unescapeAll(str.slice(start + 1, pos));\n            result.ok = true;\n            return result;\n          }\n          if (code2 === 92 && pos + 1 < max2) {\n            pos += 2;\n            continue;\n          }\n          pos++;\n        }\n        return result;\n      }\n      level = 0;\n      while (pos < max2) {\n        code2 = str.charCodeAt(pos);\n        if (code2 === 32) {\n          break;\n        }\n        if (code2 < 32 || code2 === 127) {\n          break;\n        }\n        if (code2 === 92 && pos + 1 < max2) {\n          if (str.charCodeAt(pos + 1) === 32) {\n            break;\n          }\n          pos += 2;\n          continue;\n        }\n        if (code2 === 40) {\n          level++;\n          if (level > 32) {\n            return result;\n          }\n        }\n        if (code2 === 41) {\n          if (level === 0) {\n            break;\n          }\n          level--;\n        }\n        pos++;\n      }\n      if (start === pos) {\n        return result;\n      }\n      if (level !== 0) {\n        return result;\n      }\n      result.str = unescapeAll(str.slice(start, pos));\n      result.lines = lines;\n      result.pos = pos;\n      result.ok = true;\n      return result;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/helpers/parse_link_title.js\nvar require_parse_link_title = __commonJS({\n  \"node_modules/markdown-it/lib/helpers/parse_link_title.js\"(exports, module) {\n    \"use strict\";\n    var unescapeAll = require_utils().unescapeAll;\n    module.exports = function parseLinkTitle(str, pos, max2) {\n      var code2, marker, lines = 0, start = pos, result = {\n        ok: false,\n        pos: 0,\n        lines: 0,\n        str: \"\"\n      };\n      if (pos >= max2) {\n        return result;\n      }\n      marker = str.charCodeAt(pos);\n      if (marker !== 34 && marker !== 39 && marker !== 40) {\n        return result;\n      }\n      pos++;\n      if (marker === 40) {\n        marker = 41;\n      }\n      while (pos < max2) {\n        code2 = str.charCodeAt(pos);\n        if (code2 === marker) {\n          result.pos = pos + 1;\n          result.lines = lines;\n          result.str = unescapeAll(str.slice(start + 1, pos));\n          result.ok = true;\n          return result;\n        } else if (code2 === 40 && marker === 41) {\n          return result;\n        } else if (code2 === 10) {\n          lines++;\n        } else if (code2 === 92 && pos + 1 < max2) {\n          pos++;\n          if (str.charCodeAt(pos) === 10) {\n            lines++;\n          }\n        }\n        pos++;\n      }\n      return result;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/helpers/index.js\nvar require_helpers = __commonJS({\n  \"node_modules/markdown-it/lib/helpers/index.js\"(exports) {\n    \"use strict\";\n    exports.parseLinkLabel = require_parse_link_label();\n    exports.parseLinkDestination = require_parse_link_destination();\n    exports.parseLinkTitle = require_parse_link_title();\n  }\n});\n\n// node_modules/markdown-it/lib/renderer.js\nvar require_renderer = __commonJS({\n  \"node_modules/markdown-it/lib/renderer.js\"(exports, module) {\n    \"use strict\";\n    var assign = require_utils().assign;\n    var unescapeAll = require_utils().unescapeAll;\n    var escapeHtml2 = require_utils().escapeHtml;\n    var default_rules = {};\n    default_rules.code_inline = function(tokens, idx, options, env, slf) {\n      var token = tokens[idx];\n      return \"<code\" + slf.renderAttrs(token) + \">\" + escapeHtml2(tokens[idx].content) + \"</code>\";\n    };\n    default_rules.code_block = function(tokens, idx, options, env, slf) {\n      var token = tokens[idx];\n      return \"<pre\" + slf.renderAttrs(token) + \"><code>\" + escapeHtml2(tokens[idx].content) + \"</code></pre>\\n\";\n    };\n    default_rules.fence = function(tokens, idx, options, env, slf) {\n      var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : \"\", langName = \"\", langAttrs = \"\", highlighted, i, arr, tmpAttrs, tmpToken;\n      if (info) {\n        arr = info.split(/(\\s+)/g);\n        langName = arr[0];\n        langAttrs = arr.slice(2).join(\"\");\n      }\n      if (options.highlight) {\n        highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml2(token.content);\n      } else {\n        highlighted = escapeHtml2(token.content);\n      }\n      if (highlighted.indexOf(\"<pre\") === 0) {\n        return highlighted + \"\\n\";\n      }\n      if (info) {\n        i = token.attrIndex(\"class\");\n        tmpAttrs = token.attrs ? token.attrs.slice() : [];\n        if (i < 0) {\n          tmpAttrs.push([\"class\", options.langPrefix + langName]);\n        } else {\n          tmpAttrs[i] = tmpAttrs[i].slice();\n          tmpAttrs[i][1] += \" \" + options.langPrefix + langName;\n        }\n        tmpToken = {\n          attrs: tmpAttrs\n        };\n        return \"<pre><code\" + slf.renderAttrs(tmpToken) + \">\" + highlighted + \"</code></pre>\\n\";\n      }\n      return \"<pre><code\" + slf.renderAttrs(token) + \">\" + highlighted + \"</code></pre>\\n\";\n    };\n    default_rules.image = function(tokens, idx, options, env, slf) {\n      var token = tokens[idx];\n      token.attrs[token.attrIndex(\"alt\")][1] = slf.renderInlineAsText(token.children, options, env);\n      return slf.renderToken(tokens, idx, options);\n    };\n    default_rules.hardbreak = function(tokens, idx, options) {\n      return options.xhtmlOut ? \"<br />\\n\" : \"<br>\\n\";\n    };\n    default_rules.softbreak = function(tokens, idx, options) {\n      return options.breaks ? options.xhtmlOut ? \"<br />\\n\" : \"<br>\\n\" : \"\\n\";\n    };\n    default_rules.text = function(tokens, idx) {\n      return escapeHtml2(tokens[idx].content);\n    };\n    default_rules.html_block = function(tokens, idx) {\n      return tokens[idx].content;\n    };\n    default_rules.html_inline = function(tokens, idx) {\n      return tokens[idx].content;\n    };\n    function Renderer() {\n      this.rules = assign({}, default_rules);\n    }\n    Renderer.prototype.renderAttrs = function renderAttrs(token) {\n      var i, l, result;\n      if (!token.attrs) {\n        return \"\";\n      }\n      result = \"\";\n      for (i = 0, l = token.attrs.length; i < l; i++) {\n        result += \" \" + escapeHtml2(token.attrs[i][0]) + '=\"' + escapeHtml2(token.attrs[i][1]) + '\"';\n      }\n      return result;\n    };\n    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n      var nextToken, result = \"\", needLf = false, token = tokens[idx];\n      if (token.hidden) {\n        return \"\";\n      }\n      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n        result += \"\\n\";\n      }\n      result += (token.nesting === -1 ? \"</\" : \"<\") + token.tag;\n      result += this.renderAttrs(token);\n      if (token.nesting === 0 && options.xhtmlOut) {\n        result += \" /\";\n      }\n      if (token.block) {\n        needLf = true;\n        if (token.nesting === 1) {\n          if (idx + 1 < tokens.length) {\n            nextToken = tokens[idx + 1];\n            if (nextToken.type === \"inline\" || nextToken.hidden) {\n              needLf = false;\n            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n              needLf = false;\n            }\n          }\n        }\n      }\n      result += needLf ? \">\\n\" : \">\";\n      return result;\n    };\n    Renderer.prototype.renderInline = function(tokens, options, env) {\n      var type, result = \"\", rules = this.rules;\n      for (var i = 0, len = tokens.length; i < len; i++) {\n        type = tokens[i].type;\n        if (typeof rules[type] !== \"undefined\") {\n          result += rules[type](tokens, i, options, env, this);\n        } else {\n          result += this.renderToken(tokens, i, options);\n        }\n      }\n      return result;\n    };\n    Renderer.prototype.renderInlineAsText = function(tokens, options, env) {\n      var result = \"\";\n      for (var i = 0, len = tokens.length; i < len; i++) {\n        if (tokens[i].type === \"text\") {\n          result += tokens[i].content;\n        } else if (tokens[i].type === \"image\") {\n          result += this.renderInlineAsText(tokens[i].children, options, env);\n        } else if (tokens[i].type === \"softbreak\") {\n          result += \"\\n\";\n        }\n      }\n      return result;\n    };\n    Renderer.prototype.render = function(tokens, options, env) {\n      var i, len, type, result = \"\", rules = this.rules;\n      for (i = 0, len = tokens.length; i < len; i++) {\n        type = tokens[i].type;\n        if (type === \"inline\") {\n          result += this.renderInline(tokens[i].children, options, env);\n        } else if (typeof rules[type] !== \"undefined\") {\n          result += rules[tokens[i].type](tokens, i, options, env, this);\n        } else {\n          result += this.renderToken(tokens, i, options, env);\n        }\n      }\n      return result;\n    };\n    module.exports = Renderer;\n  }\n});\n\n// node_modules/markdown-it/lib/ruler.js\nvar require_ruler = __commonJS({\n  \"node_modules/markdown-it/lib/ruler.js\"(exports, module) {\n    \"use strict\";\n    function Ruler() {\n      this.__rules__ = [];\n      this.__cache__ = null;\n    }\n    Ruler.prototype.__find__ = function(name) {\n      for (var i = 0; i < this.__rules__.length; i++) {\n        if (this.__rules__[i].name === name) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    Ruler.prototype.__compile__ = function() {\n      var self = this;\n      var chains = [\"\"];\n      self.__rules__.forEach(function(rule) {\n        if (!rule.enabled) {\n          return;\n        }\n        rule.alt.forEach(function(altName) {\n          if (chains.indexOf(altName) < 0) {\n            chains.push(altName);\n          }\n        });\n      });\n      self.__cache__ = {};\n      chains.forEach(function(chain) {\n        self.__cache__[chain] = [];\n        self.__rules__.forEach(function(rule) {\n          if (!rule.enabled) {\n            return;\n          }\n          if (chain && rule.alt.indexOf(chain) < 0) {\n            return;\n          }\n          self.__cache__[chain].push(rule.fn);\n        });\n      });\n    };\n    Ruler.prototype.at = function(name, fn, options) {\n      var index = this.__find__(name);\n      var opt = options || {};\n      if (index === -1) {\n        throw new Error(\"Parser rule not found: \" + name);\n      }\n      this.__rules__[index].fn = fn;\n      this.__rules__[index].alt = opt.alt || [];\n      this.__cache__ = null;\n    };\n    Ruler.prototype.before = function(beforeName, ruleName, fn, options) {\n      var index = this.__find__(beforeName);\n      var opt = options || {};\n      if (index === -1) {\n        throw new Error(\"Parser rule not found: \" + beforeName);\n      }\n      this.__rules__.splice(index, 0, {\n        name: ruleName,\n        enabled: true,\n        fn,\n        alt: opt.alt || []\n      });\n      this.__cache__ = null;\n    };\n    Ruler.prototype.after = function(afterName, ruleName, fn, options) {\n      var index = this.__find__(afterName);\n      var opt = options || {};\n      if (index === -1) {\n        throw new Error(\"Parser rule not found: \" + afterName);\n      }\n      this.__rules__.splice(index + 1, 0, {\n        name: ruleName,\n        enabled: true,\n        fn,\n        alt: opt.alt || []\n      });\n      this.__cache__ = null;\n    };\n    Ruler.prototype.push = function(ruleName, fn, options) {\n      var opt = options || {};\n      this.__rules__.push({\n        name: ruleName,\n        enabled: true,\n        fn,\n        alt: opt.alt || []\n      });\n      this.__cache__ = null;\n    };\n    Ruler.prototype.enable = function(list2, ignoreInvalid) {\n      if (!Array.isArray(list2)) {\n        list2 = [list2];\n      }\n      var result = [];\n      list2.forEach(function(name) {\n        var idx = this.__find__(name);\n        if (idx < 0) {\n          if (ignoreInvalid) {\n            return;\n          }\n          throw new Error(\"Rules manager: invalid rule name \" + name);\n        }\n        this.__rules__[idx].enabled = true;\n        result.push(name);\n      }, this);\n      this.__cache__ = null;\n      return result;\n    };\n    Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {\n      if (!Array.isArray(list2)) {\n        list2 = [list2];\n      }\n      this.__rules__.forEach(function(rule) {\n        rule.enabled = false;\n      });\n      this.enable(list2, ignoreInvalid);\n    };\n    Ruler.prototype.disable = function(list2, ignoreInvalid) {\n      if (!Array.isArray(list2)) {\n        list2 = [list2];\n      }\n      var result = [];\n      list2.forEach(function(name) {\n        var idx = this.__find__(name);\n        if (idx < 0) {\n          if (ignoreInvalid) {\n            return;\n          }\n          throw new Error(\"Rules manager: invalid rule name \" + name);\n        }\n        this.__rules__[idx].enabled = false;\n        result.push(name);\n      }, this);\n      this.__cache__ = null;\n      return result;\n    };\n    Ruler.prototype.getRules = function(chainName) {\n      if (this.__cache__ === null) {\n        this.__compile__();\n      }\n      return this.__cache__[chainName] || [];\n    };\n    module.exports = Ruler;\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/normalize.js\nvar require_normalize = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/normalize.js\"(exports, module) {\n    \"use strict\";\n    var NEWLINES_RE = /\\r\\n?|\\n/g;\n    var NULL_RE = /\\0/g;\n    module.exports = function normalize(state) {\n      var str;\n      str = state.src.replace(NEWLINES_RE, \"\\n\");\n      str = str.replace(NULL_RE, \"\\uFFFD\");\n      state.src = str;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/block.js\nvar require_block = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/block.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function block4(state) {\n      var token;\n      if (state.inlineMode) {\n        token = new state.Token(\"inline\", \"\", 0);\n        token.content = state.src;\n        token.map = [0, 1];\n        token.children = [];\n        state.tokens.push(token);\n      } else {\n        state.md.block.parse(state.src, state.md, state.env, state.tokens);\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/inline.js\nvar require_inline = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/inline.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function inline4(state) {\n      var tokens = state.tokens, tok, i, l;\n      for (i = 0, l = tokens.length; i < l; i++) {\n        tok = tokens[i];\n        if (tok.type === \"inline\") {\n          state.md.inline.parse(tok.content, state.md, state.env, tok.children);\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/linkify.js\nvar require_linkify = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/linkify.js\"(exports, module) {\n    \"use strict\";\n    var arrayReplaceAt = require_utils().arrayReplaceAt;\n    function isLinkOpen(str) {\n      return /^<a[>\\s]/i.test(str);\n    }\n    function isLinkClose(str) {\n      return /^<\\/a\\s*>/i.test(str);\n    }\n    module.exports = function linkify(state) {\n      var i, j, l, tokens, token, currentToken, nodes, ln, text2, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;\n      if (!state.md.options.linkify) {\n        return;\n      }\n      for (j = 0, l = blockTokens.length; j < l; j++) {\n        if (blockTokens[j].type !== \"inline\" || !state.md.linkify.pretest(blockTokens[j].content)) {\n          continue;\n        }\n        tokens = blockTokens[j].children;\n        htmlLinkLevel = 0;\n        for (i = tokens.length - 1; i >= 0; i--) {\n          currentToken = tokens[i];\n          if (currentToken.type === \"link_close\") {\n            i--;\n            while (tokens[i].level !== currentToken.level && tokens[i].type !== \"link_open\") {\n              i--;\n            }\n            continue;\n          }\n          if (currentToken.type === \"html_inline\") {\n            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n              htmlLinkLevel--;\n            }\n            if (isLinkClose(currentToken.content)) {\n              htmlLinkLevel++;\n            }\n          }\n          if (htmlLinkLevel > 0) {\n            continue;\n          }\n          if (currentToken.type === \"text\" && state.md.linkify.test(currentToken.content)) {\n            text2 = currentToken.content;\n            links = state.md.linkify.match(text2);\n            nodes = [];\n            level = currentToken.level;\n            lastPos = 0;\n            for (ln = 0; ln < links.length; ln++) {\n              url = links[ln].url;\n              fullUrl = state.md.normalizeLink(url);\n              if (!state.md.validateLink(fullUrl)) {\n                continue;\n              }\n              urlText = links[ln].text;\n              if (!links[ln].schema) {\n                urlText = state.md.normalizeLinkText(\"http://\" + urlText).replace(/^http:\\/\\//, \"\");\n              } else if (links[ln].schema === \"mailto:\" && !/^mailto:/i.test(urlText)) {\n                urlText = state.md.normalizeLinkText(\"mailto:\" + urlText).replace(/^mailto:/, \"\");\n              } else {\n                urlText = state.md.normalizeLinkText(urlText);\n              }\n              pos = links[ln].index;\n              if (pos > lastPos) {\n                token = new state.Token(\"text\", \"\", 0);\n                token.content = text2.slice(lastPos, pos);\n                token.level = level;\n                nodes.push(token);\n              }\n              token = new state.Token(\"link_open\", \"a\", 1);\n              token.attrs = [[\"href\", fullUrl]];\n              token.level = level++;\n              token.markup = \"linkify\";\n              token.info = \"auto\";\n              nodes.push(token);\n              token = new state.Token(\"text\", \"\", 0);\n              token.content = urlText;\n              token.level = level;\n              nodes.push(token);\n              token = new state.Token(\"link_close\", \"a\", -1);\n              token.level = --level;\n              token.markup = \"linkify\";\n              token.info = \"auto\";\n              nodes.push(token);\n              lastPos = links[ln].lastIndex;\n            }\n            if (lastPos < text2.length) {\n              token = new state.Token(\"text\", \"\", 0);\n              token.content = text2.slice(lastPos);\n              token.level = level;\n              nodes.push(token);\n            }\n            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n          }\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/replacements.js\nvar require_replacements = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/replacements.js\"(exports, module) {\n    \"use strict\";\n    var RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n    var SCOPED_ABBR_TEST_RE = /\\((c|tm|r|p)\\)/i;\n    var SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\n    var SCOPED_ABBR = {\n      c: \"\\xA9\",\n      r: \"\\xAE\",\n      p: \"\\xA7\",\n      tm: \"\\u2122\"\n    };\n    function replaceFn(match, name) {\n      return SCOPED_ABBR[name.toLowerCase()];\n    }\n    function replace_scoped(inlineTokens) {\n      var i, token, inside_autolink = 0;\n      for (i = inlineTokens.length - 1; i >= 0; i--) {\n        token = inlineTokens[i];\n        if (token.type === \"text\" && !inside_autolink) {\n          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);\n        }\n        if (token.type === \"link_open\" && token.info === \"auto\") {\n          inside_autolink--;\n        }\n        if (token.type === \"link_close\" && token.info === \"auto\") {\n          inside_autolink++;\n        }\n      }\n    }\n    function replace_rare(inlineTokens) {\n      var i, token, inside_autolink = 0;\n      for (i = inlineTokens.length - 1; i >= 0; i--) {\n        token = inlineTokens[i];\n        if (token.type === \"text\" && !inside_autolink) {\n          if (RARE_RE.test(token.content)) {\n            token.content = token.content.replace(/\\+-/g, \"\\xB1\").replace(/\\.{2,}/g, \"\\u2026\").replace(/([?!])/g, \"$1..\").replace(/([?!]){4,}/g, \"$1$1$1\").replace(/,{2,}/g, \",\").replace(/(^|[^-])---(?=[^-]|$)/mg, \"$1\\u2014\").replace(/(^|\\s)--(?=\\s|$)/mg, \"$1\\u2013\").replace(/(^|[^-\\s])--(?=[^-\\s]|$)/mg, \"$1\\u2013\");\n          }\n        }\n        if (token.type === \"link_open\" && token.info === \"auto\") {\n          inside_autolink--;\n        }\n        if (token.type === \"link_close\" && token.info === \"auto\") {\n          inside_autolink++;\n        }\n      }\n    }\n    module.exports = function replace(state) {\n      var blkIdx;\n      if (!state.md.options.typographer) {\n        return;\n      }\n      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n        if (state.tokens[blkIdx].type !== \"inline\") {\n          continue;\n        }\n        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {\n          replace_scoped(state.tokens[blkIdx].children);\n        }\n        if (RARE_RE.test(state.tokens[blkIdx].content)) {\n          replace_rare(state.tokens[blkIdx].children);\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/smartquotes.js\nvar require_smartquotes = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/smartquotes.js\"(exports, module) {\n    \"use strict\";\n    var isWhiteSpace = require_utils().isWhiteSpace;\n    var isPunctChar = require_utils().isPunctChar;\n    var isMdAsciiPunct = require_utils().isMdAsciiPunct;\n    var QUOTE_TEST_RE = /['\"]/;\n    var QUOTE_RE = /['\"]/g;\n    var APOSTROPHE = \"\\u2019\";\n    function replaceAt(str, index, ch) {\n      return str.substr(0, index) + ch + str.substr(index + 1);\n    }\n    function process_inlines(tokens, state) {\n      var i, token, text2, t, pos, max2, thisLevel, item2, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n      stack = [];\n      for (i = 0; i < tokens.length; i++) {\n        token = tokens[i];\n        thisLevel = tokens[i].level;\n        for (j = stack.length - 1; j >= 0; j--) {\n          if (stack[j].level <= thisLevel) {\n            break;\n          }\n        }\n        stack.length = j + 1;\n        if (token.type !== \"text\") {\n          continue;\n        }\n        text2 = token.content;\n        pos = 0;\n        max2 = text2.length;\n        OUTER:\n          while (pos < max2) {\n            QUOTE_RE.lastIndex = pos;\n            t = QUOTE_RE.exec(text2);\n            if (!t) {\n              break;\n            }\n            canOpen = canClose = true;\n            pos = t.index + 1;\n            isSingle = t[0] === \"'\";\n            lastChar = 32;\n            if (t.index - 1 >= 0) {\n              lastChar = text2.charCodeAt(t.index - 1);\n            } else {\n              for (j = i - 1; j >= 0; j--) {\n                if (tokens[j].type === \"softbreak\" || tokens[j].type === \"hardbreak\")\n                  break;\n                if (!tokens[j].content)\n                  continue;\n                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n                break;\n              }\n            }\n            nextChar = 32;\n            if (pos < max2) {\n              nextChar = text2.charCodeAt(pos);\n            } else {\n              for (j = i + 1; j < tokens.length; j++) {\n                if (tokens[j].type === \"softbreak\" || tokens[j].type === \"hardbreak\")\n                  break;\n                if (!tokens[j].content)\n                  continue;\n                nextChar = tokens[j].content.charCodeAt(0);\n                break;\n              }\n            }\n            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n            isLastWhiteSpace = isWhiteSpace(lastChar);\n            isNextWhiteSpace = isWhiteSpace(nextChar);\n            if (isNextWhiteSpace) {\n              canOpen = false;\n            } else if (isNextPunctChar) {\n              if (!(isLastWhiteSpace || isLastPunctChar)) {\n                canOpen = false;\n              }\n            }\n            if (isLastWhiteSpace) {\n              canClose = false;\n            } else if (isLastPunctChar) {\n              if (!(isNextWhiteSpace || isNextPunctChar)) {\n                canClose = false;\n              }\n            }\n            if (nextChar === 34 && t[0] === '\"') {\n              if (lastChar >= 48 && lastChar <= 57) {\n                canClose = canOpen = false;\n              }\n            }\n            if (canOpen && canClose) {\n              canOpen = isLastPunctChar;\n              canClose = isNextPunctChar;\n            }\n            if (!canOpen && !canClose) {\n              if (isSingle) {\n                token.content = replaceAt(token.content, t.index, APOSTROPHE);\n              }\n              continue;\n            }\n            if (canClose) {\n              for (j = stack.length - 1; j >= 0; j--) {\n                item2 = stack[j];\n                if (stack[j].level < thisLevel) {\n                  break;\n                }\n                if (item2.single === isSingle && stack[j].level === thisLevel) {\n                  item2 = stack[j];\n                  if (isSingle) {\n                    openQuote = state.md.options.quotes[2];\n                    closeQuote = state.md.options.quotes[3];\n                  } else {\n                    openQuote = state.md.options.quotes[0];\n                    closeQuote = state.md.options.quotes[1];\n                  }\n                  token.content = replaceAt(token.content, t.index, closeQuote);\n                  tokens[item2.token].content = replaceAt(tokens[item2.token].content, item2.pos, openQuote);\n                  pos += closeQuote.length - 1;\n                  if (item2.token === i) {\n                    pos += openQuote.length - 1;\n                  }\n                  text2 = token.content;\n                  max2 = text2.length;\n                  stack.length = j;\n                  continue OUTER;\n                }\n              }\n            }\n            if (canOpen) {\n              stack.push({\n                token: i,\n                pos: t.index,\n                single: isSingle,\n                level: thisLevel\n              });\n            } else if (canClose && isSingle) {\n              token.content = replaceAt(token.content, t.index, APOSTROPHE);\n            }\n          }\n      }\n    }\n    module.exports = function smartquotes(state) {\n      var blkIdx;\n      if (!state.md.options.typographer) {\n        return;\n      }\n      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n        if (state.tokens[blkIdx].type !== \"inline\" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n          continue;\n        }\n        process_inlines(state.tokens[blkIdx].children, state);\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/token.js\nvar require_token = __commonJS({\n  \"node_modules/markdown-it/lib/token.js\"(exports, module) {\n    \"use strict\";\n    function Token(type, tag, nesting) {\n      this.type = type;\n      this.tag = tag;\n      this.attrs = null;\n      this.map = null;\n      this.nesting = nesting;\n      this.level = 0;\n      this.children = null;\n      this.content = \"\";\n      this.markup = \"\";\n      this.info = \"\";\n      this.meta = null;\n      this.block = false;\n      this.hidden = false;\n    }\n    Token.prototype.attrIndex = function attrIndex(name) {\n      var attrs, i, len;\n      if (!this.attrs) {\n        return -1;\n      }\n      attrs = this.attrs;\n      for (i = 0, len = attrs.length; i < len; i++) {\n        if (attrs[i][0] === name) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    Token.prototype.attrPush = function attrPush(attrData) {\n      if (this.attrs) {\n        this.attrs.push(attrData);\n      } else {\n        this.attrs = [attrData];\n      }\n    };\n    Token.prototype.attrSet = function attrSet(name, value) {\n      var idx = this.attrIndex(name), attrData = [name, value];\n      if (idx < 0) {\n        this.attrPush(attrData);\n      } else {\n        this.attrs[idx] = attrData;\n      }\n    };\n    Token.prototype.attrGet = function attrGet(name) {\n      var idx = this.attrIndex(name), value = null;\n      if (idx >= 0) {\n        value = this.attrs[idx][1];\n      }\n      return value;\n    };\n    Token.prototype.attrJoin = function attrJoin(name, value) {\n      var idx = this.attrIndex(name);\n      if (idx < 0) {\n        this.attrPush([name, value]);\n      } else {\n        this.attrs[idx][1] = this.attrs[idx][1] + \" \" + value;\n      }\n    };\n    module.exports = Token;\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/state_core.js\nvar require_state_core = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/state_core.js\"(exports, module) {\n    \"use strict\";\n    var Token = require_token();\n    function StateCore(src, md, env) {\n      this.src = src;\n      this.env = env;\n      this.tokens = [];\n      this.inlineMode = false;\n      this.md = md;\n    }\n    StateCore.prototype.Token = Token;\n    module.exports = StateCore;\n  }\n});\n\n// node_modules/markdown-it/lib/parser_core.js\nvar require_parser_core = __commonJS({\n  \"node_modules/markdown-it/lib/parser_core.js\"(exports, module) {\n    \"use strict\";\n    var Ruler = require_ruler();\n    var _rules = [\n      [\"normalize\", require_normalize()],\n      [\"block\", require_block()],\n      [\"inline\", require_inline()],\n      [\"linkify\", require_linkify()],\n      [\"replacements\", require_replacements()],\n      [\"smartquotes\", require_smartquotes()]\n    ];\n    function Core() {\n      this.ruler = new Ruler();\n      for (var i = 0; i < _rules.length; i++) {\n        this.ruler.push(_rules[i][0], _rules[i][1]);\n      }\n    }\n    Core.prototype.process = function(state) {\n      var i, l, rules;\n      rules = this.ruler.getRules(\"\");\n      for (i = 0, l = rules.length; i < l; i++) {\n        rules[i](state);\n      }\n    };\n    Core.prototype.State = require_state_core();\n    module.exports = Core;\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/table.js\nvar require_table = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/table.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    function getLine2(state, line) {\n      var pos = state.bMarks[line] + state.tShift[line], max2 = state.eMarks[line];\n      return state.src.substr(pos, max2 - pos);\n    }\n    function escapedSplit(str) {\n      var result = [], pos = 0, max2 = str.length, ch, isEscaped = false, lastPos = 0, current = \"\";\n      ch = str.charCodeAt(pos);\n      while (pos < max2) {\n        if (ch === 124) {\n          if (!isEscaped) {\n            result.push(current + str.substring(lastPos, pos));\n            current = \"\";\n            lastPos = pos + 1;\n          } else {\n            current += str.substring(lastPos, pos - 1);\n            lastPos = pos;\n          }\n        }\n        isEscaped = ch === 92;\n        pos++;\n        ch = str.charCodeAt(pos);\n      }\n      result.push(current + str.substring(lastPos));\n      return result;\n    }\n    module.exports = function table3(state, startLine, endLine, silent) {\n      var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;\n      if (startLine + 2 > endLine) {\n        return false;\n      }\n      nextLine = startLine + 1;\n      if (state.sCount[nextLine] < state.blkIndent) {\n        return false;\n      }\n      if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      if (pos >= state.eMarks[nextLine]) {\n        return false;\n      }\n      firstCh = state.src.charCodeAt(pos++);\n      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {\n        return false;\n      }\n      if (pos >= state.eMarks[nextLine]) {\n        return false;\n      }\n      secondCh = state.src.charCodeAt(pos++);\n      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {\n        return false;\n      }\n      if (firstCh === 45 && isSpace(secondCh)) {\n        return false;\n      }\n      while (pos < state.eMarks[nextLine]) {\n        ch = state.src.charCodeAt(pos);\n        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {\n          return false;\n        }\n        pos++;\n      }\n      lineText = getLine2(state, startLine + 1);\n      columns = lineText.split(\"|\");\n      aligns = [];\n      for (i = 0; i < columns.length; i++) {\n        t = columns[i].trim();\n        if (!t) {\n          if (i === 0 || i === columns.length - 1) {\n            continue;\n          } else {\n            return false;\n          }\n        }\n        if (!/^:?-+:?$/.test(t)) {\n          return false;\n        }\n        if (t.charCodeAt(t.length - 1) === 58) {\n          aligns.push(t.charCodeAt(0) === 58 ? \"center\" : \"right\");\n        } else if (t.charCodeAt(0) === 58) {\n          aligns.push(\"left\");\n        } else {\n          aligns.push(\"\");\n        }\n      }\n      lineText = getLine2(state, startLine).trim();\n      if (lineText.indexOf(\"|\") === -1) {\n        return false;\n      }\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      columns = escapedSplit(lineText);\n      if (columns.length && columns[0] === \"\")\n        columns.shift();\n      if (columns.length && columns[columns.length - 1] === \"\")\n        columns.pop();\n      columnCount = columns.length;\n      if (columnCount === 0 || columnCount !== aligns.length) {\n        return false;\n      }\n      if (silent) {\n        return true;\n      }\n      oldParentType = state.parentType;\n      state.parentType = \"table\";\n      terminatorRules = state.md.block.ruler.getRules(\"blockquote\");\n      token = state.push(\"table_open\", \"table\", 1);\n      token.map = tableLines = [startLine, 0];\n      token = state.push(\"thead_open\", \"thead\", 1);\n      token.map = [startLine, startLine + 1];\n      token = state.push(\"tr_open\", \"tr\", 1);\n      token.map = [startLine, startLine + 1];\n      for (i = 0; i < columns.length; i++) {\n        token = state.push(\"th_open\", \"th\", 1);\n        if (aligns[i]) {\n          token.attrs = [[\"style\", \"text-align:\" + aligns[i]]];\n        }\n        token = state.push(\"inline\", \"\", 0);\n        token.content = columns[i].trim();\n        token.children = [];\n        token = state.push(\"th_close\", \"th\", -1);\n      }\n      token = state.push(\"tr_close\", \"tr\", -1);\n      token = state.push(\"thead_close\", \"thead\", -1);\n      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n        if (state.sCount[nextLine] < state.blkIndent) {\n          break;\n        }\n        terminate = false;\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\n          if (terminatorRules[i](state, nextLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n        if (terminate) {\n          break;\n        }\n        lineText = getLine2(state, nextLine).trim();\n        if (!lineText) {\n          break;\n        }\n        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {\n          break;\n        }\n        columns = escapedSplit(lineText);\n        if (columns.length && columns[0] === \"\")\n          columns.shift();\n        if (columns.length && columns[columns.length - 1] === \"\")\n          columns.pop();\n        if (nextLine === startLine + 2) {\n          token = state.push(\"tbody_open\", \"tbody\", 1);\n          token.map = tbodyLines = [startLine + 2, 0];\n        }\n        token = state.push(\"tr_open\", \"tr\", 1);\n        token.map = [nextLine, nextLine + 1];\n        for (i = 0; i < columnCount; i++) {\n          token = state.push(\"td_open\", \"td\", 1);\n          if (aligns[i]) {\n            token.attrs = [[\"style\", \"text-align:\" + aligns[i]]];\n          }\n          token = state.push(\"inline\", \"\", 0);\n          token.content = columns[i] ? columns[i].trim() : \"\";\n          token.children = [];\n          token = state.push(\"td_close\", \"td\", -1);\n        }\n        token = state.push(\"tr_close\", \"tr\", -1);\n      }\n      if (tbodyLines) {\n        token = state.push(\"tbody_close\", \"tbody\", -1);\n        tbodyLines[1] = nextLine;\n      }\n      token = state.push(\"table_close\", \"table\", -1);\n      tableLines[1] = nextLine;\n      state.parentType = oldParentType;\n      state.line = nextLine;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/code.js\nvar require_code = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/code.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function code2(state, startLine, endLine) {\n      if (state.md.options.allowIndentation) {\n        return false;\n      }\n      var nextLine, last, token;\n      if (state.sCount[startLine] - state.blkIndent < 4) {\n        return false;\n      }\n      last = nextLine = startLine + 1;\n      while (nextLine < endLine) {\n        if (state.isEmpty(nextLine)) {\n          nextLine++;\n          continue;\n        }\n        if (state.sCount[nextLine] - state.blkIndent >= 4) {\n          nextLine++;\n          last = nextLine;\n          continue;\n        }\n        break;\n      }\n      state.line = last;\n      token = state.push(\"code_block\", \"code\", 0);\n      token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + \"\\n\";\n      token.map = [startLine, state.line];\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/fence.js\nvar require_fence = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/fence.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function fence3(state, startLine, endLine, silent) {\n      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      if (pos + 3 > max2) {\n        return false;\n      }\n      marker = state.src.charCodeAt(pos);\n      if (marker !== 126 && marker !== 96) {\n        return false;\n      }\n      mem = pos;\n      pos = state.skipChars(pos, marker);\n      len = pos - mem;\n      if (len < 3) {\n        return false;\n      }\n      markup = state.src.slice(mem, pos);\n      params = state.src.slice(pos, max2);\n      if (marker === 96) {\n        if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n          return false;\n        }\n      }\n      if (silent) {\n        return true;\n      }\n      nextLine = startLine;\n      for (; ; ) {\n        nextLine++;\n        if (nextLine >= endLine) {\n          break;\n        }\n        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n        max2 = state.eMarks[nextLine];\n        if (pos < max2 && state.sCount[nextLine] < state.blkIndent) {\n          break;\n        }\n        if (state.src.charCodeAt(pos) !== marker) {\n          continue;\n        }\n        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {\n          continue;\n        }\n        pos = state.skipChars(pos, marker);\n        if (pos - mem < len) {\n          continue;\n        }\n        pos = state.skipSpaces(pos);\n        if (pos < max2) {\n          continue;\n        }\n        haveEndMarker = true;\n        break;\n      }\n      len = state.sCount[startLine];\n      state.line = nextLine + (haveEndMarker ? 1 : 0);\n      token = state.push(\"fence\", \"code\", 0);\n      token.info = params;\n      token.content = state.getLines(startLine + 1, nextLine, len, true);\n      token.markup = markup;\n      token.map = [startLine, state.line];\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/blockquote.js\nvar require_blockquote = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/blockquote.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    module.exports = function blockquote2(state, startLine, endLine, silent) {\n      var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      if (state.src.charCodeAt(pos++) !== 62) {\n        return false;\n      }\n      if (silent) {\n        return true;\n      }\n      initial = offset = state.sCount[startLine] + 1;\n      if (state.src.charCodeAt(pos) === 32) {\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n        spaceAfterMarker = true;\n      } else if (state.src.charCodeAt(pos) === 9) {\n        spaceAfterMarker = true;\n        if ((state.bsCount[startLine] + offset) % 4 === 3) {\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n        } else {\n          adjustTab = true;\n        }\n      } else {\n        spaceAfterMarker = false;\n      }\n      oldBMarks = [state.bMarks[startLine]];\n      state.bMarks[startLine] = pos;\n      while (pos < max2) {\n        ch = state.src.charCodeAt(pos);\n        if (isSpace(ch)) {\n          if (ch === 9) {\n            offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n        pos++;\n      }\n      oldBSCount = [state.bsCount[startLine]];\n      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n      lastLineEmpty = pos >= max2;\n      oldSCount = [state.sCount[startLine]];\n      state.sCount[startLine] = offset - initial;\n      oldTShift = [state.tShift[startLine]];\n      state.tShift[startLine] = pos - state.bMarks[startLine];\n      terminatorRules = state.md.block.ruler.getRules(\"blockquote\");\n      oldParentType = state.parentType;\n      state.parentType = \"blockquote\";\n      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n        isOutdented = state.sCount[nextLine] < state.blkIndent;\n        pos = state.bMarks[nextLine] + state.tShift[nextLine];\n        max2 = state.eMarks[nextLine];\n        if (pos >= max2) {\n          break;\n        }\n        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {\n          initial = offset = state.sCount[nextLine] + 1;\n          if (state.src.charCodeAt(pos) === 32) {\n            pos++;\n            initial++;\n            offset++;\n            adjustTab = false;\n            spaceAfterMarker = true;\n          } else if (state.src.charCodeAt(pos) === 9) {\n            spaceAfterMarker = true;\n            if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n              pos++;\n              initial++;\n              offset++;\n              adjustTab = false;\n            } else {\n              adjustTab = true;\n            }\n          } else {\n            spaceAfterMarker = false;\n          }\n          oldBMarks.push(state.bMarks[nextLine]);\n          state.bMarks[nextLine] = pos;\n          while (pos < max2) {\n            ch = state.src.charCodeAt(pos);\n            if (isSpace(ch)) {\n              if (ch === 9) {\n                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n              } else {\n                offset++;\n              }\n            } else {\n              break;\n            }\n            pos++;\n          }\n          lastLineEmpty = pos >= max2;\n          oldBSCount.push(state.bsCount[nextLine]);\n          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n          oldSCount.push(state.sCount[nextLine]);\n          state.sCount[nextLine] = offset - initial;\n          oldTShift.push(state.tShift[nextLine]);\n          state.tShift[nextLine] = pos - state.bMarks[nextLine];\n          continue;\n        }\n        if (lastLineEmpty) {\n          break;\n        }\n        terminate = false;\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\n          if (terminatorRules[i](state, nextLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n        if (terminate) {\n          state.lineMax = nextLine;\n          if (state.blkIndent !== 0) {\n            oldBMarks.push(state.bMarks[nextLine]);\n            oldBSCount.push(state.bsCount[nextLine]);\n            oldTShift.push(state.tShift[nextLine]);\n            oldSCount.push(state.sCount[nextLine]);\n            state.sCount[nextLine] -= state.blkIndent;\n          }\n          break;\n        }\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] = -1;\n      }\n      oldIndent = state.blkIndent;\n      state.blkIndent = 0;\n      token = state.push(\"blockquote_open\", \"blockquote\", 1);\n      token.markup = \">\";\n      token.map = lines = [startLine, 0];\n      state.md.block.tokenize(state, startLine, nextLine);\n      token = state.push(\"blockquote_close\", \"blockquote\", -1);\n      token.markup = \">\";\n      state.lineMax = oldLineMax;\n      state.parentType = oldParentType;\n      lines[1] = state.line;\n      for (i = 0; i < oldTShift.length; i++) {\n        state.bMarks[i + startLine] = oldBMarks[i];\n        state.tShift[i + startLine] = oldTShift[i];\n        state.sCount[i + startLine] = oldSCount[i];\n        state.bsCount[i + startLine] = oldBSCount[i];\n      }\n      state.blkIndent = oldIndent;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/hr.js\nvar require_hr = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/hr.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    module.exports = function hr2(state, startLine, endLine, silent) {\n      var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      marker = state.src.charCodeAt(pos++);\n      if (marker !== 42 && marker !== 45 && marker !== 95) {\n        return false;\n      }\n      cnt = 1;\n      while (pos < max2) {\n        ch = state.src.charCodeAt(pos++);\n        if (ch !== marker && !isSpace(ch)) {\n          return false;\n        }\n        if (ch === marker) {\n          cnt++;\n        }\n      }\n      if (cnt < 3) {\n        return false;\n      }\n      if (silent) {\n        return true;\n      }\n      state.line = startLine + 1;\n      token = state.push(\"hr\", \"hr\", 0);\n      token.map = [startLine, state.line];\n      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/list.js\nvar require_list = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/list.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    function skipBulletListMarker(state, startLine) {\n      var marker, pos, max2, ch;\n      pos = state.bMarks[startLine] + state.tShift[startLine];\n      max2 = state.eMarks[startLine];\n      marker = state.src.charCodeAt(pos++);\n      if (marker !== 42 && marker !== 45 && marker !== 43) {\n        return -1;\n      }\n      if (pos < max2) {\n        ch = state.src.charCodeAt(pos);\n        if (!isSpace(ch)) {\n          return -1;\n        }\n      }\n      return pos;\n    }\n    function skipOrderedListMarker(state, startLine) {\n      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max2 = state.eMarks[startLine];\n      if (pos + 1 >= max2) {\n        return -1;\n      }\n      ch = state.src.charCodeAt(pos++);\n      if (ch < 48 || ch > 57) {\n        return -1;\n      }\n      for (; ; ) {\n        if (pos >= max2) {\n          return -1;\n        }\n        ch = state.src.charCodeAt(pos++);\n        if (ch >= 48 && ch <= 57) {\n          if (pos - start >= 10) {\n            return -1;\n          }\n          continue;\n        }\n        if (ch === 41 || ch === 46) {\n          break;\n        }\n        return -1;\n      }\n      if (pos < max2) {\n        ch = state.src.charCodeAt(pos);\n        if (!isSpace(ch)) {\n          return -1;\n        }\n      }\n      return pos;\n    }\n    function markTightParagraphs(state, idx) {\n      var i, l, level = state.level + 2;\n      for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n        if (state.tokens[i].level === level && state.tokens[i].type === \"paragraph_open\") {\n          state.tokens[i + 2].hidden = true;\n          state.tokens[i].hidden = true;\n          i += 2;\n        }\n      }\n    }\n    module.exports = function list2(state, startLine, endLine, silent) {\n      var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max2, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      if (!state.md.options.allowIndentation && state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {\n        return false;\n      }\n      if (silent && state.parentType === \"paragraph\") {\n        if (state.sCount[startLine] >= state.blkIndent) {\n          isTerminatingParagraph = true;\n        }\n      }\n      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n        isOrdered = true;\n        start = state.bMarks[startLine] + state.tShift[startLine];\n        markerValue = Number(state.src.slice(start, posAfterMarker - 1));\n        if (isTerminatingParagraph && markerValue !== 1)\n          return false;\n      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n        isOrdered = false;\n      } else {\n        return false;\n      }\n      if (isTerminatingParagraph) {\n        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])\n          return false;\n      }\n      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n      if (silent) {\n        return true;\n      }\n      listTokIdx = state.tokens.length;\n      if (isOrdered) {\n        token = state.push(\"ordered_list_open\", \"ol\", 1);\n        if (markerValue !== 1) {\n          token.attrs = [[\"start\", markerValue]];\n        }\n      } else {\n        token = state.push(\"bullet_list_open\", \"ul\", 1);\n      }\n      token.map = listLines = [startLine, 0];\n      token.markup = String.fromCharCode(markerCharCode);\n      nextLine = startLine;\n      prevEmptyEnd = false;\n      terminatorRules = state.md.block.ruler.getRules(\"list\");\n      oldParentType = state.parentType;\n      state.parentType = \"list\";\n      while (nextLine < endLine) {\n        pos = posAfterMarker;\n        max2 = state.eMarks[nextLine];\n        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n        while (pos < max2) {\n          ch = state.src.charCodeAt(pos);\n          if (ch === 9) {\n            offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n          } else if (ch === 32) {\n            offset++;\n          } else {\n            break;\n          }\n          pos++;\n        }\n        contentStart = pos;\n        if (contentStart >= max2) {\n          indentAfterMarker = 1;\n        } else {\n          indentAfterMarker = offset - initial;\n        }\n        if (!state.md.options.allowIndentation && indentAfterMarker > 4) {\n          indentAfterMarker = 1;\n        }\n        indent = initial + indentAfterMarker;\n        token = state.push(\"list_item_open\", \"li\", 1);\n        token.markup = String.fromCharCode(markerCharCode);\n        token.map = itemLines = [startLine, 0];\n        if (isOrdered) {\n          token.info = state.src.slice(start, posAfterMarker - 1);\n        }\n        oldTight = state.tight;\n        oldTShift = state.tShift[startLine];\n        oldSCount = state.sCount[startLine];\n        oldListIndent = state.listIndent;\n        state.listIndent = state.blkIndent;\n        state.blkIndent = indent;\n        state.tight = true;\n        state.tShift[startLine] = contentStart - state.bMarks[startLine];\n        state.sCount[startLine] = offset;\n        if (contentStart >= max2 && state.isEmpty(startLine + 1)) {\n          state.line = Math.min(state.line + 2, endLine);\n        } else {\n          state.md.block.tokenize(state, startLine, endLine, true);\n        }\n        if (!state.tight || prevEmptyEnd) {\n          tight = false;\n        }\n        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n        state.blkIndent = state.listIndent;\n        state.listIndent = oldListIndent;\n        state.tShift[startLine] = oldTShift;\n        state.sCount[startLine] = oldSCount;\n        state.tight = oldTight;\n        token = state.push(\"list_item_close\", \"li\", -1);\n        token.markup = String.fromCharCode(markerCharCode);\n        nextLine = startLine = state.line;\n        itemLines[1] = nextLine;\n        contentStart = state.bMarks[startLine];\n        if (nextLine >= endLine) {\n          break;\n        }\n        if (state.sCount[nextLine] < state.blkIndent) {\n          break;\n        }\n        if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n          break;\n        }\n        terminate = false;\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\n          if (terminatorRules[i](state, nextLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n        if (terminate) {\n          break;\n        }\n        if (isOrdered) {\n          posAfterMarker = skipOrderedListMarker(state, nextLine);\n          if (posAfterMarker < 0) {\n            break;\n          }\n          start = state.bMarks[nextLine] + state.tShift[nextLine];\n        } else {\n          posAfterMarker = skipBulletListMarker(state, nextLine);\n          if (posAfterMarker < 0) {\n            break;\n          }\n        }\n        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n          break;\n        }\n      }\n      if (isOrdered) {\n        token = state.push(\"ordered_list_close\", \"ol\", -1);\n      } else {\n        token = state.push(\"bullet_list_close\", \"ul\", -1);\n      }\n      token.markup = String.fromCharCode(markerCharCode);\n      listLines[1] = nextLine;\n      state.line = nextLine;\n      state.parentType = oldParentType;\n      if (tight) {\n        markTightParagraphs(state, listTokIdx);\n      }\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/reference.js\nvar require_reference = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/reference.js\"(exports, module) {\n    \"use strict\";\n    var normalizeReference = require_utils().normalizeReference;\n    var isSpace = require_utils().isSpace;\n    module.exports = function reference(state, startLine, _endLine, silent) {\n      var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine], nextLine = startLine + 1;\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      if (state.src.charCodeAt(pos) !== 91) {\n        return false;\n      }\n      while (++pos < max2) {\n        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {\n          if (pos + 1 === max2) {\n            return false;\n          }\n          if (state.src.charCodeAt(pos + 1) !== 58) {\n            return false;\n          }\n          break;\n        }\n      }\n      endLine = state.lineMax;\n      terminatorRules = state.md.block.ruler.getRules(\"reference\");\n      oldParentType = state.parentType;\n      state.parentType = \"reference\";\n      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {\n          continue;\n        }\n        if (state.sCount[nextLine] < 0) {\n          continue;\n        }\n        terminate = false;\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\n          if (terminatorRules[i](state, nextLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n        if (terminate) {\n          break;\n        }\n      }\n      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n      max2 = str.length;\n      for (pos = 1; pos < max2; pos++) {\n        ch = str.charCodeAt(pos);\n        if (ch === 91) {\n          return false;\n        } else if (ch === 93) {\n          labelEnd = pos;\n          break;\n        } else if (ch === 10) {\n          lines++;\n        } else if (ch === 92) {\n          pos++;\n          if (pos < max2 && str.charCodeAt(pos) === 10) {\n            lines++;\n          }\n        }\n      }\n      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {\n        return false;\n      }\n      for (pos = labelEnd + 2; pos < max2; pos++) {\n        ch = str.charCodeAt(pos);\n        if (ch === 10) {\n          lines++;\n        } else if (isSpace(ch)) {\n        } else {\n          break;\n        }\n      }\n      res = state.md.helpers.parseLinkDestination(str, pos, max2);\n      if (!res.ok) {\n        return false;\n      }\n      href = state.md.normalizeLink(res.str);\n      if (!state.md.validateLink(href)) {\n        return false;\n      }\n      pos = res.pos;\n      lines += res.lines;\n      destEndPos = pos;\n      destEndLineNo = lines;\n      start = pos;\n      for (; pos < max2; pos++) {\n        ch = str.charCodeAt(pos);\n        if (ch === 10) {\n          lines++;\n        } else if (isSpace(ch)) {\n        } else {\n          break;\n        }\n      }\n      res = state.md.helpers.parseLinkTitle(str, pos, max2);\n      if (pos < max2 && start !== pos && res.ok) {\n        title = res.str;\n        pos = res.pos;\n        lines += res.lines;\n      } else {\n        title = \"\";\n        pos = destEndPos;\n        lines = destEndLineNo;\n      }\n      while (pos < max2) {\n        ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) {\n          break;\n        }\n        pos++;\n      }\n      if (pos < max2 && str.charCodeAt(pos) !== 10) {\n        if (title) {\n          title = \"\";\n          pos = destEndPos;\n          lines = destEndLineNo;\n          while (pos < max2) {\n            ch = str.charCodeAt(pos);\n            if (!isSpace(ch)) {\n              break;\n            }\n            pos++;\n          }\n        }\n      }\n      if (pos < max2 && str.charCodeAt(pos) !== 10) {\n        return false;\n      }\n      label = normalizeReference(str.slice(1, labelEnd));\n      if (!label) {\n        return false;\n      }\n      if (silent) {\n        return true;\n      }\n      if (typeof state.env.references === \"undefined\") {\n        state.env.references = {};\n      }\n      if (typeof state.env.references[label] === \"undefined\") {\n        state.env.references[label] = { title, href };\n      }\n      state.parentType = oldParentType;\n      state.line = startLine + lines + 1;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/common/html_blocks.js\nvar require_html_blocks = __commonJS({\n  \"node_modules/markdown-it/lib/common/html_blocks.js\"(exports, module) {\n    \"use strict\";\n    module.exports = [\n      \"address\",\n      \"article\",\n      \"aside\",\n      \"base\",\n      \"basefont\",\n      \"blockquote\",\n      \"body\",\n      \"caption\",\n      \"center\",\n      \"col\",\n      \"colgroup\",\n      \"dd\",\n      \"details\",\n      \"dialog\",\n      \"dir\",\n      \"div\",\n      \"dl\",\n      \"dt\",\n      \"fieldset\",\n      \"figcaption\",\n      \"figure\",\n      \"footer\",\n      \"form\",\n      \"frame\",\n      \"frameset\",\n      \"h1\",\n      \"h2\",\n      \"h3\",\n      \"h4\",\n      \"h5\",\n      \"h6\",\n      \"head\",\n      \"header\",\n      \"hr\",\n      \"html\",\n      \"iframe\",\n      \"legend\",\n      \"li\",\n      \"link\",\n      \"main\",\n      \"menu\",\n      \"menuitem\",\n      \"nav\",\n      \"noframes\",\n      \"ol\",\n      \"optgroup\",\n      \"option\",\n      \"p\",\n      \"param\",\n      \"section\",\n      \"source\",\n      \"summary\",\n      \"table\",\n      \"tbody\",\n      \"td\",\n      \"tfoot\",\n      \"th\",\n      \"thead\",\n      \"title\",\n      \"tr\",\n      \"track\",\n      \"ul\"\n    ];\n  }\n});\n\n// node_modules/markdown-it/lib/common/html_re.js\nvar require_html_re = __commonJS({\n  \"node_modules/markdown-it/lib/common/html_re.js\"(exports, module) {\n    \"use strict\";\n    var attr_name = \"[a-zA-Z_:][a-zA-Z0-9:._-]*\";\n    var unquoted = \"[^\\\"'=<>`\\\\x00-\\\\x20]+\";\n    var single_quoted = \"'[^']*'\";\n    var double_quoted = '\"[^\"]*\"';\n    var attr_value = \"(?:\" + unquoted + \"|\" + single_quoted + \"|\" + double_quoted + \")\";\n    var attribute = \"(?:\\\\s+\" + attr_name + \"(?:\\\\s*=\\\\s*\" + attr_value + \")?)\";\n    var open_tag = \"<[A-Za-z][A-Za-z0-9\\\\-]*\" + attribute + \"*\\\\s*\\\\/?>\";\n    var close_tag = \"<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>\";\n    var comment2 = \"<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->\";\n    var processing = \"<[?][\\\\s\\\\S]*?[?]>\";\n    var declaration = \"<![A-Z]+\\\\s+[^>]*>\";\n    var cdata = \"<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\";\n    var HTML_TAG_RE = new RegExp(\"^(?:\" + open_tag + \"|\" + close_tag + \"|\" + comment2 + \"|\" + processing + \"|\" + declaration + \"|\" + cdata + \")\");\n    var HTML_OPEN_CLOSE_TAG_RE = new RegExp(\"^(?:\" + open_tag + \"|\" + close_tag + \")\");\n    module.exports.HTML_TAG_RE = HTML_TAG_RE;\n    module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/html_block.js\nvar require_html_block = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/html_block.js\"(exports, module) {\n    \"use strict\";\n    var block_names = require_html_blocks();\n    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;\n    var HTML_SEQUENCES = [\n      [/^<(script|pre|style|textarea)(?=(\\s|>|$))/i, /<\\/(script|pre|style|textarea)>/i, true],\n      [/^<!--/, /-->/, true],\n      [/^<\\?/, /\\?>/, true],\n      [/^<![A-Z]/, />/, true],\n      [/^<!\\[CDATA\\[/, /\\]\\]>/, true],\n      [new RegExp(\"^</?(\" + block_names.join(\"|\") + \")(?=(\\\\s|/?>|$))\", \"i\"), /^$/, true],\n      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + \"\\\\s*$\"), /^$/, false]\n    ];\n    module.exports = function html_block(state, startLine, endLine, silent) {\n      var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      if (!state.md.options.html) {\n        return false;\n      }\n      if (state.src.charCodeAt(pos) !== 60) {\n        return false;\n      }\n      lineText = state.src.slice(pos, max2);\n      for (i = 0; i < HTML_SEQUENCES.length; i++) {\n        if (HTML_SEQUENCES[i][0].test(lineText)) {\n          break;\n        }\n      }\n      if (i === HTML_SEQUENCES.length) {\n        return false;\n      }\n      if (silent) {\n        return HTML_SEQUENCES[i][2];\n      }\n      nextLine = startLine + 1;\n      if (!HTML_SEQUENCES[i][1].test(lineText)) {\n        for (; nextLine < endLine; nextLine++) {\n          if (state.sCount[nextLine] < state.blkIndent) {\n            break;\n          }\n          pos = state.bMarks[nextLine] + state.tShift[nextLine];\n          max2 = state.eMarks[nextLine];\n          lineText = state.src.slice(pos, max2);\n          if (HTML_SEQUENCES[i][1].test(lineText)) {\n            if (lineText.length !== 0) {\n              nextLine++;\n            }\n            break;\n          }\n        }\n      }\n      state.line = nextLine;\n      token = state.push(\"html_block\", \"\", 0);\n      token.map = [startLine, nextLine];\n      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/heading.js\nvar require_heading = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/heading.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    module.exports = function heading2(state, startLine, endLine, silent) {\n      var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      ch = state.src.charCodeAt(pos);\n      if (ch !== 35 || pos >= max2) {\n        return false;\n      }\n      level = 1;\n      ch = state.src.charCodeAt(++pos);\n      while (ch === 35 && pos < max2 && level <= 6) {\n        level++;\n        ch = state.src.charCodeAt(++pos);\n      }\n      if (level > 6 || pos < max2 && !isSpace(ch)) {\n        return false;\n      }\n      if (silent) {\n        return true;\n      }\n      max2 = state.skipSpacesBack(max2, pos);\n      tmp = state.skipCharsBack(max2, 35, pos);\n      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {\n        max2 = tmp;\n      }\n      state.line = startLine + 1;\n      token = state.push(\"heading_open\", \"h\" + String(level), 1);\n      token.markup = \"########\".slice(0, level);\n      token.map = [startLine, state.line];\n      token = state.push(\"inline\", \"\", 0);\n      token.content = state.src.slice(pos, max2).trim();\n      token.map = [startLine, state.line];\n      token.children = [];\n      token = state.push(\"heading_close\", \"h\" + String(level), -1);\n      token.markup = \"########\".slice(0, level);\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/lheading.js\nvar require_lheading = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/lheading.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function lheading(state, startLine, endLine) {\n      var content, terminate, i, l, token, pos, max2, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules(\"paragraph\");\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      oldParentType = state.parentType;\n      state.parentType = \"paragraph\";\n      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {\n          continue;\n        }\n        if (state.sCount[nextLine] >= state.blkIndent) {\n          pos = state.bMarks[nextLine] + state.tShift[nextLine];\n          max2 = state.eMarks[nextLine];\n          if (pos < max2) {\n            marker = state.src.charCodeAt(pos);\n            if (marker === 45 || marker === 61) {\n              pos = state.skipChars(pos, marker);\n              pos = state.skipSpaces(pos);\n              if (pos >= max2) {\n                level = marker === 61 ? 1 : 2;\n                break;\n              }\n            }\n          }\n        }\n        if (state.sCount[nextLine] < 0) {\n          continue;\n        }\n        terminate = false;\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\n          if (terminatorRules[i](state, nextLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n        if (terminate) {\n          break;\n        }\n      }\n      if (!level) {\n        return false;\n      }\n      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n      state.line = nextLine + 1;\n      token = state.push(\"heading_open\", \"h\" + String(level), 1);\n      token.markup = String.fromCharCode(marker);\n      token.map = [startLine, state.line];\n      token = state.push(\"inline\", \"\", 0);\n      token.content = content;\n      token.map = [startLine, state.line - 1];\n      token.children = [];\n      token = state.push(\"heading_close\", \"h\" + String(level), -1);\n      token.markup = String.fromCharCode(marker);\n      state.parentType = oldParentType;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/paragraph.js\nvar require_paragraph = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/paragraph.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function paragraph2(state, startLine) {\n      var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules(\"paragraph\"), endLine = state.lineMax;\n      oldParentType = state.parentType;\n      state.parentType = \"paragraph\";\n      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {\n          continue;\n        }\n        if (state.sCount[nextLine] < 0) {\n          continue;\n        }\n        terminate = false;\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\n          if (terminatorRules[i](state, nextLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n        if (terminate) {\n          break;\n        }\n      }\n      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n      state.line = nextLine;\n      token = state.push(\"paragraph_open\", \"p\", 1);\n      token.map = [startLine, state.line];\n      token = state.push(\"inline\", \"\", 0);\n      token.content = content;\n      token.map = [startLine, state.line];\n      token.children = [];\n      token = state.push(\"paragraph_close\", \"p\", -1);\n      state.parentType = oldParentType;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/state_block.js\nvar require_state_block = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/state_block.js\"(exports, module) {\n    \"use strict\";\n    var Token = require_token();\n    var isSpace = require_utils().isSpace;\n    function StateBlock(src, md, env, tokens) {\n      var ch, s2, start, pos, len, indent, offset, indent_found;\n      this.src = src;\n      this.md = md;\n      this.env = env;\n      this.tokens = tokens;\n      this.bMarks = [];\n      this.eMarks = [];\n      this.tShift = [];\n      this.sCount = [];\n      this.bsCount = [];\n      this.blkIndent = 0;\n      this.line = 0;\n      this.lineMax = 0;\n      this.tight = false;\n      this.ddIndent = -1;\n      this.listIndent = -1;\n      this.parentType = \"root\";\n      this.level = 0;\n      this.result = \"\";\n      s2 = this.src;\n      indent_found = false;\n      for (start = pos = indent = offset = 0, len = s2.length; pos < len; pos++) {\n        ch = s2.charCodeAt(pos);\n        if (!indent_found) {\n          if (isSpace(ch)) {\n            indent++;\n            if (ch === 9) {\n              offset += 4 - offset % 4;\n            } else {\n              offset++;\n            }\n            continue;\n          } else {\n            indent_found = true;\n          }\n        }\n        if (ch === 10 || pos === len - 1) {\n          if (ch !== 10) {\n            pos++;\n          }\n          this.bMarks.push(start);\n          this.eMarks.push(pos);\n          this.tShift.push(indent);\n          this.sCount.push(offset);\n          this.bsCount.push(0);\n          indent_found = false;\n          indent = 0;\n          offset = 0;\n          start = pos + 1;\n        }\n      }\n      this.bMarks.push(s2.length);\n      this.eMarks.push(s2.length);\n      this.tShift.push(0);\n      this.sCount.push(0);\n      this.bsCount.push(0);\n      this.lineMax = this.bMarks.length - 1;\n    }\n    StateBlock.prototype.push = function(type, tag, nesting) {\n      var token = new Token(type, tag, nesting);\n      token.block = true;\n      if (nesting < 0)\n        this.level--;\n      token.level = this.level;\n      if (nesting > 0)\n        this.level++;\n      this.tokens.push(token);\n      return token;\n    };\n    StateBlock.prototype.isEmpty = function isEmpty(line) {\n      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n    };\n    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n      for (var max2 = this.lineMax; from < max2; from++) {\n        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n          break;\n        }\n      }\n      return from;\n    };\n    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n      var ch;\n      for (var max2 = this.src.length; pos < max2; pos++) {\n        ch = this.src.charCodeAt(pos);\n        if (!isSpace(ch)) {\n          break;\n        }\n      }\n      return pos;\n    };\n    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n      if (pos <= min) {\n        return pos;\n      }\n      while (pos > min) {\n        if (!isSpace(this.src.charCodeAt(--pos))) {\n          return pos + 1;\n        }\n      }\n      return pos;\n    };\n    StateBlock.prototype.skipChars = function skipChars(pos, code2) {\n      for (var max2 = this.src.length; pos < max2; pos++) {\n        if (this.src.charCodeAt(pos) !== code2) {\n          break;\n        }\n      }\n      return pos;\n    };\n    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {\n      if (pos <= min) {\n        return pos;\n      }\n      while (pos > min) {\n        if (code2 !== this.src.charCodeAt(--pos)) {\n          return pos + 1;\n        }\n      }\n      return pos;\n    };\n    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n      var i, lineIndent, ch, first, last, queue, lineStart, line = begin;\n      if (begin >= end) {\n        return \"\";\n      }\n      queue = new Array(end - begin);\n      for (i = 0; line < end; line++, i++) {\n        lineIndent = 0;\n        lineStart = first = this.bMarks[line];\n        if (line + 1 < end || keepLastLF) {\n          last = this.eMarks[line] + 1;\n        } else {\n          last = this.eMarks[line];\n        }\n        while (first < last && lineIndent < indent) {\n          ch = this.src.charCodeAt(first);\n          if (isSpace(ch)) {\n            if (ch === 9) {\n              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n            } else {\n              lineIndent++;\n            }\n          } else if (first - lineStart < this.tShift[line]) {\n            lineIndent++;\n          } else {\n            break;\n          }\n          first++;\n        }\n        if (lineIndent > indent) {\n          queue[i] = new Array(lineIndent - indent + 1).join(\" \") + this.src.slice(first, last);\n        } else {\n          queue[i] = this.src.slice(first, last);\n        }\n      }\n      return queue.join(\"\");\n    };\n    StateBlock.prototype.Token = Token;\n    module.exports = StateBlock;\n  }\n});\n\n// node_modules/markdown-it/lib/parser_block.js\nvar require_parser_block = __commonJS({\n  \"node_modules/markdown-it/lib/parser_block.js\"(exports, module) {\n    \"use strict\";\n    var Ruler = require_ruler();\n    var _rules = [\n      [\"table\", require_table(), [\"paragraph\", \"reference\"]],\n      [\"code\", require_code()],\n      [\"fence\", require_fence(), [\"paragraph\", \"reference\", \"blockquote\", \"list\"]],\n      [\"blockquote\", require_blockquote(), [\"paragraph\", \"reference\", \"blockquote\", \"list\"]],\n      [\"hr\", require_hr(), [\"paragraph\", \"reference\", \"blockquote\", \"list\"]],\n      [\"list\", require_list(), [\"paragraph\", \"reference\", \"blockquote\"]],\n      [\"reference\", require_reference()],\n      [\"html_block\", require_html_block(), [\"paragraph\", \"reference\", \"blockquote\"]],\n      [\"heading\", require_heading(), [\"paragraph\", \"reference\", \"blockquote\"]],\n      [\"lheading\", require_lheading()],\n      [\"paragraph\", require_paragraph()]\n    ];\n    function ParserBlock() {\n      this.ruler = new Ruler();\n      for (var i = 0; i < _rules.length; i++) {\n        this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\n      }\n    }\n    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {\n      var ok, i, rules = this.ruler.getRules(\"\"), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;\n      while (line < endLine) {\n        state.line = line = state.skipEmptyLines(line);\n        if (line >= endLine) {\n          break;\n        }\n        if (state.sCount[line] < state.blkIndent) {\n          break;\n        }\n        if (state.level >= maxNesting) {\n          state.line = endLine;\n          break;\n        }\n        for (i = 0; i < len; i++) {\n          ok = rules[i](state, line, endLine, false);\n          if (ok) {\n            break;\n          }\n        }\n        state.tight = !hasEmptyLines;\n        if (state.isEmpty(state.line - 1)) {\n          hasEmptyLines = true;\n        }\n        line = state.line;\n        if (line < endLine && state.isEmpty(line)) {\n          hasEmptyLines = true;\n          line++;\n          state.line = line;\n        }\n      }\n    };\n    ParserBlock.prototype.parse = function(src, md, env, outTokens) {\n      var state;\n      if (!src) {\n        return;\n      }\n      state = new this.State(src, md, env, outTokens);\n      this.tokenize(state, state.line, state.lineMax);\n    };\n    ParserBlock.prototype.State = require_state_block();\n    module.exports = ParserBlock;\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/text.js\nvar require_text = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/text.js\"(exports, module) {\n    \"use strict\";\n    function isTerminatorChar(ch) {\n      switch (ch) {\n        case 10:\n        case 33:\n        case 35:\n        case 36:\n        case 37:\n        case 38:\n        case 42:\n        case 43:\n        case 45:\n        case 58:\n        case 60:\n        case 61:\n        case 62:\n        case 64:\n        case 91:\n        case 92:\n        case 93:\n        case 94:\n        case 95:\n        case 96:\n        case 123:\n        case 125:\n        case 126:\n          return true;\n        default:\n          return false;\n      }\n    }\n    module.exports = function text2(state, silent) {\n      var pos = state.pos;\n      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n        pos++;\n      }\n      if (pos === state.pos) {\n        return false;\n      }\n      if (!silent) {\n        state.pending += state.src.slice(state.pos, pos);\n      }\n      state.pos = pos;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/newline.js\nvar require_newline = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/newline.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    module.exports = function newline(state, silent) {\n      var pmax, max2, ws, pos = state.pos;\n      if (state.src.charCodeAt(pos) !== 10) {\n        return false;\n      }\n      pmax = state.pending.length - 1;\n      max2 = state.posMax;\n      if (!silent) {\n        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {\n          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {\n            ws = pmax - 1;\n            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)\n              ws--;\n            state.pending = state.pending.slice(0, ws);\n            state.push(\"hardbreak\", \"br\", 0);\n          } else {\n            state.pending = state.pending.slice(0, -1);\n            state.push(\"softbreak\", \"br\", 0);\n          }\n        } else {\n          state.push(\"softbreak\", \"br\", 0);\n        }\n      }\n      pos++;\n      while (pos < max2 && isSpace(state.src.charCodeAt(pos))) {\n        pos++;\n      }\n      state.pos = pos;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/escape.js\nvar require_escape = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/escape.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    var ESCAPED = [];\n    for (i = 0; i < 256; i++) {\n      ESCAPED.push(0);\n    }\n    var i;\n    \"\\\\!\\\"#$%&'()*+,./:;<=>?@[]^_`{|}~-\".split(\"\").forEach(function(ch) {\n      ESCAPED[ch.charCodeAt(0)] = 1;\n    });\n    module.exports = function escape(state, silent) {\n      var ch, pos = state.pos, max2 = state.posMax;\n      if (state.src.charCodeAt(pos) !== 92) {\n        return false;\n      }\n      pos++;\n      if (pos < max2) {\n        ch = state.src.charCodeAt(pos);\n        if (ch < 256 && ESCAPED[ch] !== 0) {\n          if (!silent) {\n            state.pending += state.src[pos];\n          }\n          state.pos += 2;\n          return true;\n        }\n        if (ch === 10) {\n          if (!silent) {\n            state.push(\"hardbreak\", \"br\", 0);\n          }\n          pos++;\n          while (pos < max2) {\n            ch = state.src.charCodeAt(pos);\n            if (!isSpace(ch)) {\n              break;\n            }\n            pos++;\n          }\n          state.pos = pos;\n          return true;\n        }\n      }\n      if (!silent) {\n        state.pending += \"\\\\\";\n      }\n      state.pos++;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/backticks.js\nvar require_backticks = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/backticks.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function backtick(state, silent) {\n      var start, max2, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);\n      if (ch !== 96) {\n        return false;\n      }\n      start = pos;\n      pos++;\n      max2 = state.posMax;\n      while (pos < max2 && state.src.charCodeAt(pos) === 96) {\n        pos++;\n      }\n      marker = state.src.slice(start, pos);\n      openerLength = marker.length;\n      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {\n        if (!silent)\n          state.pending += marker;\n        state.pos += openerLength;\n        return true;\n      }\n      matchStart = matchEnd = pos;\n      while ((matchStart = state.src.indexOf(\"`\", matchEnd)) !== -1) {\n        matchEnd = matchStart + 1;\n        while (matchEnd < max2 && state.src.charCodeAt(matchEnd) === 96) {\n          matchEnd++;\n        }\n        closerLength = matchEnd - matchStart;\n        if (closerLength === openerLength) {\n          if (!silent) {\n            token = state.push(\"code_inline\", \"code\", 0);\n            token.markup = marker;\n            token.content = state.src.slice(pos, matchStart).replace(/\\n/g, \" \").replace(/^ (.+) $/, \"$1\");\n          }\n          state.pos = matchEnd;\n          return true;\n        }\n        state.backticks[closerLength] = matchStart;\n      }\n      state.backticksScanned = true;\n      if (!silent)\n        state.pending += marker;\n      state.pos += openerLength;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/strikethrough.js\nvar require_strikethrough = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/strikethrough.js\"(exports, module) {\n    \"use strict\";\n    module.exports.tokenize = function strikethrough(state, silent) {\n      var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);\n      if (silent) {\n        return false;\n      }\n      if (marker !== 126) {\n        return false;\n      }\n      scanned = state.scanDelims(state.pos, true);\n      len = scanned.length;\n      ch = String.fromCharCode(marker);\n      if (len < 2) {\n        return false;\n      }\n      if (len % 2) {\n        token = state.push(\"text\", \"\", 0);\n        token.content = ch;\n        len--;\n      }\n      for (i = 0; i < len; i += 2) {\n        token = state.push(\"text\", \"\", 0);\n        token.content = ch + ch;\n        state.delimiters.push({\n          marker,\n          length: 0,\n          token: state.tokens.length - 1,\n          end: -1,\n          open: scanned.can_open,\n          close: scanned.can_close\n        });\n      }\n      state.pos += scanned.length;\n      return true;\n    };\n    function postProcess(state, delimiters) {\n      var i, j, startDelim, endDelim, token, loneMarkers = [], max2 = delimiters.length;\n      for (i = 0; i < max2; i++) {\n        startDelim = delimiters[i];\n        if (startDelim.marker !== 126) {\n          continue;\n        }\n        if (startDelim.end === -1) {\n          continue;\n        }\n        endDelim = delimiters[startDelim.end];\n        token = state.tokens[startDelim.token];\n        token.type = \"s_open\";\n        token.tag = \"s\";\n        token.nesting = 1;\n        token.markup = \"~~\";\n        token.content = \"\";\n        token = state.tokens[endDelim.token];\n        token.type = \"s_close\";\n        token.tag = \"s\";\n        token.nesting = -1;\n        token.markup = \"~~\";\n        token.content = \"\";\n        if (state.tokens[endDelim.token - 1].type === \"text\" && state.tokens[endDelim.token - 1].content === \"~\") {\n          loneMarkers.push(endDelim.token - 1);\n        }\n      }\n      while (loneMarkers.length) {\n        i = loneMarkers.pop();\n        j = i + 1;\n        while (j < state.tokens.length && state.tokens[j].type === \"s_close\") {\n          j++;\n        }\n        j--;\n        if (i !== j) {\n          token = state.tokens[j];\n          state.tokens[j] = state.tokens[i];\n          state.tokens[i] = token;\n        }\n      }\n    }\n    module.exports.postProcess = function strikethrough(state) {\n      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;\n      postProcess(state, state.delimiters);\n      for (curr = 0; curr < max2; curr++) {\n        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n          postProcess(state, tokens_meta[curr].delimiters);\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/emphasis.js\nvar require_emphasis = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/emphasis.js\"(exports, module) {\n    \"use strict\";\n    module.exports.tokenize = function emphasis(state, silent) {\n      var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);\n      if (silent) {\n        return false;\n      }\n      if (marker !== 95 && marker !== 42) {\n        return false;\n      }\n      scanned = state.scanDelims(state.pos, marker === 42);\n      for (i = 0; i < scanned.length; i++) {\n        token = state.push(\"text\", \"\", 0);\n        token.content = String.fromCharCode(marker);\n        state.delimiters.push({\n          marker,\n          length: scanned.length,\n          token: state.tokens.length - 1,\n          end: -1,\n          open: scanned.can_open,\n          close: scanned.can_close\n        });\n      }\n      state.pos += scanned.length;\n      return true;\n    };\n    function postProcess(state, delimiters) {\n      var i, startDelim, endDelim, token, ch, isStrong, max2 = delimiters.length;\n      for (i = max2 - 1; i >= 0; i--) {\n        startDelim = delimiters[i];\n        if (startDelim.marker !== 95 && startDelim.marker !== 42) {\n          continue;\n        }\n        if (startDelim.end === -1) {\n          continue;\n        }\n        endDelim = delimiters[startDelim.end];\n        isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;\n        ch = String.fromCharCode(startDelim.marker);\n        token = state.tokens[startDelim.token];\n        token.type = isStrong ? \"strong_open\" : \"em_open\";\n        token.tag = isStrong ? \"strong\" : \"em\";\n        token.nesting = 1;\n        token.markup = isStrong ? ch + ch : ch;\n        token.content = \"\";\n        token = state.tokens[endDelim.token];\n        token.type = isStrong ? \"strong_close\" : \"em_close\";\n        token.tag = isStrong ? \"strong\" : \"em\";\n        token.nesting = -1;\n        token.markup = isStrong ? ch + ch : ch;\n        token.content = \"\";\n        if (isStrong) {\n          state.tokens[delimiters[i - 1].token].content = \"\";\n          state.tokens[delimiters[startDelim.end + 1].token].content = \"\";\n          i--;\n        }\n      }\n    }\n    module.exports.postProcess = function emphasis(state) {\n      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;\n      postProcess(state, state.delimiters);\n      for (curr = 0; curr < max2; curr++) {\n        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n          postProcess(state, tokens_meta[curr].delimiters);\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/link.js\nvar require_link = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/link.js\"(exports, module) {\n    \"use strict\";\n    var normalizeReference = require_utils().normalizeReference;\n    var isSpace = require_utils().isSpace;\n    module.exports = function link2(state, silent) {\n      var attrs, code2, label, labelEnd, labelStart, pos, res, ref, token, href = \"\", title = \"\", oldPos = state.pos, max2 = state.posMax, start = state.pos, parseReference = true;\n      if (state.src.charCodeAt(state.pos) !== 91) {\n        return false;\n      }\n      labelStart = state.pos + 1;\n      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);\n      if (labelEnd < 0) {\n        return false;\n      }\n      pos = labelEnd + 1;\n      if (pos < max2 && state.src.charCodeAt(pos) === 40) {\n        parseReference = false;\n        pos++;\n        for (; pos < max2; pos++) {\n          code2 = state.src.charCodeAt(pos);\n          if (!isSpace(code2) && code2 !== 10) {\n            break;\n          }\n        }\n        if (pos >= max2) {\n          return false;\n        }\n        start = pos;\n        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n        if (res.ok) {\n          href = state.md.normalizeLink(res.str);\n          if (state.md.validateLink(href)) {\n            pos = res.pos;\n          } else {\n            href = \"\";\n          }\n          start = pos;\n          for (; pos < max2; pos++) {\n            code2 = state.src.charCodeAt(pos);\n            if (!isSpace(code2) && code2 !== 10) {\n              break;\n            }\n          }\n          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n          if (pos < max2 && start !== pos && res.ok) {\n            title = res.str;\n            pos = res.pos;\n            for (; pos < max2; pos++) {\n              code2 = state.src.charCodeAt(pos);\n              if (!isSpace(code2) && code2 !== 10) {\n                break;\n              }\n            }\n          }\n        }\n        if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {\n          parseReference = true;\n        }\n        pos++;\n      }\n      if (parseReference) {\n        if (typeof state.env.references === \"undefined\") {\n          return false;\n        }\n        if (pos < max2 && state.src.charCodeAt(pos) === 91) {\n          start = pos + 1;\n          pos = state.md.helpers.parseLinkLabel(state, pos);\n          if (pos >= 0) {\n            label = state.src.slice(start, pos++);\n          } else {\n            pos = labelEnd + 1;\n          }\n        } else {\n          pos = labelEnd + 1;\n        }\n        if (!label) {\n          label = state.src.slice(labelStart, labelEnd);\n        }\n        ref = state.env.references[normalizeReference(label)];\n        if (!ref) {\n          state.pos = oldPos;\n          return false;\n        }\n        href = ref.href;\n        title = ref.title;\n      }\n      if (!silent) {\n        state.pos = labelStart;\n        state.posMax = labelEnd;\n        token = state.push(\"link_open\", \"a\", 1);\n        token.attrs = attrs = [[\"href\", href]];\n        if (title) {\n          attrs.push([\"title\", title]);\n        }\n        state.md.inline.tokenize(state);\n        token = state.push(\"link_close\", \"a\", -1);\n      }\n      state.pos = pos;\n      state.posMax = max2;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/image.js\nvar require_image = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/image.js\"(exports, module) {\n    \"use strict\";\n    var normalizeReference = require_utils().normalizeReference;\n    var isSpace = require_utils().isSpace;\n    module.exports = function image2(state, silent) {\n      var attrs, code2, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = \"\", oldPos = state.pos, max2 = state.posMax;\n      if (state.src.charCodeAt(state.pos) !== 33) {\n        return false;\n      }\n      if (state.src.charCodeAt(state.pos + 1) !== 91) {\n        return false;\n      }\n      labelStart = state.pos + 2;\n      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n      if (labelEnd < 0) {\n        return false;\n      }\n      pos = labelEnd + 1;\n      if (pos < max2 && state.src.charCodeAt(pos) === 40) {\n        pos++;\n        for (; pos < max2; pos++) {\n          code2 = state.src.charCodeAt(pos);\n          if (!isSpace(code2) && code2 !== 10) {\n            break;\n          }\n        }\n        if (pos >= max2) {\n          return false;\n        }\n        start = pos;\n        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n        if (res.ok) {\n          href = state.md.normalizeLink(res.str);\n          if (state.md.validateLink(href)) {\n            pos = res.pos;\n          } else {\n            href = \"\";\n          }\n        }\n        start = pos;\n        for (; pos < max2; pos++) {\n          code2 = state.src.charCodeAt(pos);\n          if (!isSpace(code2) && code2 !== 10) {\n            break;\n          }\n        }\n        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n        if (pos < max2 && start !== pos && res.ok) {\n          title = res.str;\n          pos = res.pos;\n          for (; pos < max2; pos++) {\n            code2 = state.src.charCodeAt(pos);\n            if (!isSpace(code2) && code2 !== 10) {\n              break;\n            }\n          }\n        } else {\n          title = \"\";\n        }\n        if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {\n          state.pos = oldPos;\n          return false;\n        }\n        pos++;\n      } else {\n        if (typeof state.env.references === \"undefined\") {\n          return false;\n        }\n        if (pos < max2 && state.src.charCodeAt(pos) === 91) {\n          start = pos + 1;\n          pos = state.md.helpers.parseLinkLabel(state, pos);\n          if (pos >= 0) {\n            label = state.src.slice(start, pos++);\n          } else {\n            pos = labelEnd + 1;\n          }\n        } else {\n          pos = labelEnd + 1;\n        }\n        if (!label) {\n          label = state.src.slice(labelStart, labelEnd);\n        }\n        ref = state.env.references[normalizeReference(label)];\n        if (!ref) {\n          state.pos = oldPos;\n          return false;\n        }\n        href = ref.href;\n        title = ref.title;\n      }\n      if (!silent) {\n        content = state.src.slice(labelStart, labelEnd);\n        state.md.inline.parse(content, state.md, state.env, tokens = []);\n        token = state.push(\"image\", \"img\", 0);\n        token.attrs = attrs = [[\"src\", href], [\"alt\", \"\"]];\n        token.children = tokens;\n        token.content = content;\n        if (title) {\n          attrs.push([\"title\", title]);\n        }\n      }\n      state.pos = pos;\n      state.posMax = max2;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/autolink.js\nvar require_autolink = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/autolink.js\"(exports, module) {\n    \"use strict\";\n    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;\n    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\\-]{1,31}):([^<>\\x00-\\x20]*)$/;\n    module.exports = function autolink(state, silent) {\n      var url, fullUrl, token, ch, start, max2, pos = state.pos;\n      if (state.src.charCodeAt(pos) !== 60) {\n        return false;\n      }\n      start = state.pos;\n      max2 = state.posMax;\n      for (; ; ) {\n        if (++pos >= max2)\n          return false;\n        ch = state.src.charCodeAt(pos);\n        if (ch === 60)\n          return false;\n        if (ch === 62)\n          break;\n      }\n      url = state.src.slice(start + 1, pos);\n      if (AUTOLINK_RE.test(url)) {\n        fullUrl = state.md.normalizeLink(url);\n        if (!state.md.validateLink(fullUrl)) {\n          return false;\n        }\n        if (!silent) {\n          token = state.push(\"link_open\", \"a\", 1);\n          token.attrs = [[\"href\", fullUrl]];\n          token.markup = \"autolink\";\n          token.info = \"auto\";\n          token = state.push(\"text\", \"\", 0);\n          token.content = state.md.normalizeLinkText(url);\n          token = state.push(\"link_close\", \"a\", -1);\n          token.markup = \"autolink\";\n          token.info = \"auto\";\n        }\n        state.pos += url.length + 2;\n        return true;\n      }\n      if (EMAIL_RE.test(url)) {\n        fullUrl = state.md.normalizeLink(\"mailto:\" + url);\n        if (!state.md.validateLink(fullUrl)) {\n          return false;\n        }\n        if (!silent) {\n          token = state.push(\"link_open\", \"a\", 1);\n          token.attrs = [[\"href\", fullUrl]];\n          token.markup = \"autolink\";\n          token.info = \"auto\";\n          token = state.push(\"text\", \"\", 0);\n          token.content = state.md.normalizeLinkText(url);\n          token = state.push(\"link_close\", \"a\", -1);\n          token.markup = \"autolink\";\n          token.info = \"auto\";\n        }\n        state.pos += url.length + 2;\n        return true;\n      }\n      return false;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/html_inline.js\nvar require_html_inline = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/html_inline.js\"(exports, module) {\n    \"use strict\";\n    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;\n    function isLetter(ch) {\n      var lc = ch | 32;\n      return lc >= 97 && lc <= 122;\n    }\n    module.exports = function html_inline(state, silent) {\n      var ch, match, max2, token, pos = state.pos;\n      if (!state.md.options.html) {\n        return false;\n      }\n      max2 = state.posMax;\n      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max2) {\n        return false;\n      }\n      ch = state.src.charCodeAt(pos + 1);\n      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {\n        return false;\n      }\n      match = state.src.slice(pos).match(HTML_TAG_RE);\n      if (!match) {\n        return false;\n      }\n      if (!silent) {\n        token = state.push(\"html_inline\", \"\", 0);\n        token.content = state.src.slice(pos, pos + match[0].length);\n      }\n      state.pos += match[0].length;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/entity.js\nvar require_entity = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/entity.js\"(exports, module) {\n    \"use strict\";\n    var entities = require_entities2();\n    var has = require_utils().has;\n    var isValidEntityCode = require_utils().isValidEntityCode;\n    var fromCodePoint = require_utils().fromCodePoint;\n    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;\n    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;\n    module.exports = function entity(state, silent) {\n      var ch, code2, match, pos = state.pos, max2 = state.posMax;\n      if (state.src.charCodeAt(pos) !== 38) {\n        return false;\n      }\n      if (pos + 1 < max2) {\n        ch = state.src.charCodeAt(pos + 1);\n        if (ch === 35) {\n          match = state.src.slice(pos).match(DIGITAL_RE);\n          if (match) {\n            if (!silent) {\n              code2 = match[1][0].toLowerCase() === \"x\" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n              state.pending += isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);\n            }\n            state.pos += match[0].length;\n            return true;\n          }\n        } else {\n          match = state.src.slice(pos).match(NAMED_RE);\n          if (match) {\n            if (has(entities, match[1])) {\n              if (!silent) {\n                state.pending += entities[match[1]];\n              }\n              state.pos += match[0].length;\n              return true;\n            }\n          }\n        }\n      }\n      if (!silent) {\n        state.pending += \"&\";\n      }\n      state.pos++;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/balance_pairs.js\nvar require_balance_pairs = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/balance_pairs.js\"(exports, module) {\n    \"use strict\";\n    function processDelimiters(state, delimiters) {\n      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max2 = delimiters.length;\n      if (!max2)\n        return;\n      var headerIdx = 0;\n      var lastTokenIdx = -2;\n      var jumps = [];\n      for (closerIdx = 0; closerIdx < max2; closerIdx++) {\n        closer = delimiters[closerIdx];\n        jumps.push(0);\n        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n          headerIdx = closerIdx;\n        }\n        lastTokenIdx = closer.token;\n        closer.length = closer.length || 0;\n        if (!closer.close)\n          continue;\n        if (!openersBottom.hasOwnProperty(closer.marker)) {\n          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];\n        }\n        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];\n        openerIdx = headerIdx - jumps[headerIdx] - 1;\n        newMinOpenerIdx = openerIdx;\n        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n          opener = delimiters[openerIdx];\n          if (opener.marker !== closer.marker)\n            continue;\n          if (opener.open && opener.end < 0) {\n            isOddMatch = false;\n            if (opener.close || closer.open) {\n              if ((opener.length + closer.length) % 3 === 0) {\n                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n                  isOddMatch = true;\n                }\n              }\n            }\n            if (!isOddMatch) {\n              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;\n              jumps[closerIdx] = closerIdx - openerIdx + lastJump;\n              jumps[openerIdx] = lastJump;\n              closer.open = false;\n              opener.end = closerIdx;\n              opener.close = false;\n              newMinOpenerIdx = -1;\n              lastTokenIdx = -2;\n              break;\n            }\n          }\n        }\n        if (newMinOpenerIdx !== -1) {\n          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;\n        }\n      }\n    }\n    module.exports = function link_pairs(state) {\n      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;\n      processDelimiters(state, state.delimiters);\n      for (curr = 0; curr < max2; curr++) {\n        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n          processDelimiters(state, tokens_meta[curr].delimiters);\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/text_collapse.js\nvar require_text_collapse = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/text_collapse.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function text_collapse(state) {\n      var curr, last, level = 0, tokens = state.tokens, max2 = state.tokens.length;\n      for (curr = last = 0; curr < max2; curr++) {\n        if (tokens[curr].nesting < 0)\n          level--;\n        tokens[curr].level = level;\n        if (tokens[curr].nesting > 0)\n          level++;\n        if (tokens[curr].type === \"text\" && curr + 1 < max2 && tokens[curr + 1].type === \"text\") {\n          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n        } else {\n          if (curr !== last) {\n            tokens[last] = tokens[curr];\n          }\n          last++;\n        }\n      }\n      if (curr !== last) {\n        tokens.length = last;\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/state_inline.js\nvar require_state_inline = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/state_inline.js\"(exports, module) {\n    \"use strict\";\n    var Token = require_token();\n    var isWhiteSpace = require_utils().isWhiteSpace;\n    var isPunctChar = require_utils().isPunctChar;\n    var isMdAsciiPunct = require_utils().isMdAsciiPunct;\n    function StateInline(src, md, env, outTokens) {\n      this.src = src;\n      this.env = env;\n      this.md = md;\n      this.tokens = outTokens;\n      this.tokens_meta = Array(outTokens.length);\n      this.pos = 0;\n      this.posMax = this.src.length;\n      this.level = 0;\n      this.pending = \"\";\n      this.pendingLevel = 0;\n      this.cache = {};\n      this.delimiters = [];\n      this._prev_delimiters = [];\n      this.backticks = {};\n      this.backticksScanned = false;\n    }\n    StateInline.prototype.pushPending = function() {\n      var token = new Token(\"text\", \"\", 0);\n      token.content = this.pending;\n      token.level = this.pendingLevel;\n      this.tokens.push(token);\n      this.pending = \"\";\n      return token;\n    };\n    StateInline.prototype.push = function(type, tag, nesting) {\n      if (this.pending) {\n        this.pushPending();\n      }\n      var token = new Token(type, tag, nesting);\n      var token_meta = null;\n      if (nesting < 0) {\n        this.level--;\n        this.delimiters = this._prev_delimiters.pop();\n      }\n      token.level = this.level;\n      if (nesting > 0) {\n        this.level++;\n        this._prev_delimiters.push(this.delimiters);\n        this.delimiters = [];\n        token_meta = { delimiters: this.delimiters };\n      }\n      this.pendingLevel = this.level;\n      this.tokens.push(token);\n      this.tokens_meta.push(token_meta);\n      return token;\n    };\n    StateInline.prototype.scanDelims = function(start, canSplitWord) {\n      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max2 = this.posMax, marker = this.src.charCodeAt(start);\n      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;\n      while (pos < max2 && this.src.charCodeAt(pos) === marker) {\n        pos++;\n      }\n      count = pos - start;\n      nextChar = pos < max2 ? this.src.charCodeAt(pos) : 32;\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n      isLastWhiteSpace = isWhiteSpace(lastChar);\n      isNextWhiteSpace = isWhiteSpace(nextChar);\n      if (isNextWhiteSpace) {\n        left_flanking = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          left_flanking = false;\n        }\n      }\n      if (isLastWhiteSpace) {\n        right_flanking = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          right_flanking = false;\n        }\n      }\n      if (!canSplitWord) {\n        can_open = left_flanking && (!right_flanking || isLastPunctChar);\n        can_close = right_flanking && (!left_flanking || isNextPunctChar);\n      } else {\n        can_open = left_flanking;\n        can_close = right_flanking;\n      }\n      return {\n        can_open,\n        can_close,\n        length: count\n      };\n    };\n    StateInline.prototype.Token = Token;\n    module.exports = StateInline;\n  }\n});\n\n// node_modules/markdown-it/lib/parser_inline.js\nvar require_parser_inline = __commonJS({\n  \"node_modules/markdown-it/lib/parser_inline.js\"(exports, module) {\n    \"use strict\";\n    var Ruler = require_ruler();\n    var _rules = [\n      [\"text\", require_text()],\n      [\"newline\", require_newline()],\n      [\"escape\", require_escape()],\n      [\"backticks\", require_backticks()],\n      [\"strikethrough\", require_strikethrough().tokenize],\n      [\"emphasis\", require_emphasis().tokenize],\n      [\"link\", require_link()],\n      [\"image\", require_image()],\n      [\"autolink\", require_autolink()],\n      [\"html_inline\", require_html_inline()],\n      [\"entity\", require_entity()]\n    ];\n    var _rules2 = [\n      [\"balance_pairs\", require_balance_pairs()],\n      [\"strikethrough\", require_strikethrough().postProcess],\n      [\"emphasis\", require_emphasis().postProcess],\n      [\"text_collapse\", require_text_collapse()]\n    ];\n    function ParserInline() {\n      var i;\n      this.ruler = new Ruler();\n      for (i = 0; i < _rules.length; i++) {\n        this.ruler.push(_rules[i][0], _rules[i][1]);\n      }\n      this.ruler2 = new Ruler();\n      for (i = 0; i < _rules2.length; i++) {\n        this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n      }\n    }\n    ParserInline.prototype.skipToken = function(state) {\n      var ok, i, pos = state.pos, rules = this.ruler.getRules(\"\"), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;\n      if (typeof cache[pos] !== \"undefined\") {\n        state.pos = cache[pos];\n        return;\n      }\n      if (state.level < maxNesting) {\n        for (i = 0; i < len; i++) {\n          state.level++;\n          ok = rules[i](state, true);\n          state.level--;\n          if (ok) {\n            break;\n          }\n        }\n      } else {\n        state.pos = state.posMax;\n      }\n      if (!ok) {\n        state.pos++;\n      }\n      cache[pos] = state.pos;\n    };\n    ParserInline.prototype.tokenize = function(state) {\n      var ok, i, rules = this.ruler.getRules(\"\"), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;\n      while (state.pos < end) {\n        if (state.level < maxNesting) {\n          for (i = 0; i < len; i++) {\n            ok = rules[i](state, false);\n            if (ok) {\n              break;\n            }\n          }\n        }\n        if (ok) {\n          if (state.pos >= end) {\n            break;\n          }\n          continue;\n        }\n        state.pending += state.src[state.pos++];\n      }\n      if (state.pending) {\n        state.pushPending();\n      }\n    };\n    ParserInline.prototype.parse = function(str, md, env, outTokens) {\n      var i, rules, len;\n      var state = new this.State(str, md, env, outTokens);\n      this.tokenize(state);\n      rules = this.ruler2.getRules(\"\");\n      len = rules.length;\n      for (i = 0; i < len; i++) {\n        rules[i](state);\n      }\n    };\n    ParserInline.prototype.State = require_state_inline();\n    module.exports = ParserInline;\n  }\n});\n\n// node_modules/linkify-it/lib/re.js\nvar require_re = __commonJS({\n  \"node_modules/linkify-it/lib/re.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function(opts) {\n      var re = {};\n      re.src_Any = require_regex2().source;\n      re.src_Cc = require_regex3().source;\n      re.src_Z = require_regex5().source;\n      re.src_P = require_regex().source;\n      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join(\"|\");\n      re.src_ZCc = [re.src_Z, re.src_Cc].join(\"|\");\n      var text_separators = \"[><\\uFF5C]\";\n      re.src_pseudo_letter = \"(?:(?!\" + text_separators + \"|\" + re.src_ZPCc + \")\" + re.src_Any + \")\";\n      re.src_ip4 = \"(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\";\n      re.src_auth = \"(?:(?:(?!\" + re.src_ZCc + \"|[@/\\\\[\\\\]()]).)+@)?\";\n      re.src_port = \"(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?\";\n      re.src_host_terminator = \"(?=$|\" + text_separators + \"|\" + re.src_ZPCc + \")(?!-|_|:\\\\d|\\\\.-|\\\\.(?!$|\" + re.src_ZPCc + \"))\";\n      re.src_path = \"(?:[/?#](?:(?!\" + re.src_ZCc + \"|\" + text_separators + `|[()[\\\\]{}.,\"'?!\\\\-;]).|\\\\[(?:(?!` + re.src_ZCc + \"|\\\\]).)*\\\\]|\\\\((?:(?!\" + re.src_ZCc + \"|[)]).)*\\\\)|\\\\{(?:(?!\" + re.src_ZCc + '|[}]).)*\\\\}|\\\\\"(?:(?!' + re.src_ZCc + `|[\"]).)+\\\\\"|\\\\'(?:(?!` + re.src_ZCc + \"|[']).)+\\\\'|\\\\'(?=\" + re.src_pseudo_letter + \"|[-]).|\\\\.{2,}[a-zA-Z0-9%/&]|\\\\.(?!\" + re.src_ZCc + \"|[.]).|\" + (opts && opts[\"---\"] ? \"\\\\-(?!--(?:[^-]|$))(?:-*)|\" : \"\\\\-+|\") + \",(?!\" + re.src_ZCc + \").|;(?!\" + re.src_ZCc + \").|\\\\!+(?!\" + re.src_ZCc + \"|[!]).|\\\\?(?!\" + re.src_ZCc + \"|[?]).)+|\\\\/)?\";\n      re.src_email_name = '[\\\\-;:&=\\\\+\\\\$,\\\\.a-zA-Z0-9_][\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]*';\n      re.src_xn = \"xn--[a-z0-9\\\\-]{1,59}\";\n      re.src_domain_root = \"(?:\" + re.src_xn + \"|\" + re.src_pseudo_letter + \"{1,63})\";\n      re.src_domain = \"(?:\" + re.src_xn + \"|(?:\" + re.src_pseudo_letter + \")|(?:\" + re.src_pseudo_letter + \"(?:-|\" + re.src_pseudo_letter + \"){0,61}\" + re.src_pseudo_letter + \"))\";\n      re.src_host = \"(?:(?:(?:(?:\" + re.src_domain + \")\\\\.)*\" + re.src_domain + \"))\";\n      re.tpl_host_fuzzy = \"(?:\" + re.src_ip4 + \"|(?:(?:(?:\" + re.src_domain + \")\\\\.)+(?:%TLDS%)))\";\n      re.tpl_host_no_ip_fuzzy = \"(?:(?:(?:\" + re.src_domain + \")\\\\.)+(?:%TLDS%))\";\n      re.src_host_strict = re.src_host + re.src_host_terminator;\n      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;\n      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;\n      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;\n      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;\n      re.tpl_host_fuzzy_test = \"localhost|www\\\\.|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:\" + re.src_ZPCc + \"|>|$))\";\n      re.tpl_email_fuzzy = \"(^|\" + text_separators + '|\"|\\\\(|' + re.src_ZCc + \")(\" + re.src_email_name + \"@\" + re.tpl_host_fuzzy_strict + \")\";\n      re.tpl_link_fuzzy = \"(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uFF5C]|\" + re.src_ZPCc + \"))((?![$+<=>^`|\\uFF5C])\" + re.tpl_host_port_fuzzy_strict + re.src_path + \")\";\n      re.tpl_link_no_ip_fuzzy = \"(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uFF5C]|\" + re.src_ZPCc + \"))((?![$+<=>^`|\\uFF5C])\" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + \")\";\n      return re;\n    };\n  }\n});\n\n// node_modules/linkify-it/index.js\nvar require_linkify_it = __commonJS({\n  \"node_modules/linkify-it/index.js\"(exports, module) {\n    \"use strict\";\n    function assign(obj) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n      sources.forEach(function(source) {\n        if (!source) {\n          return;\n        }\n        Object.keys(source).forEach(function(key) {\n          obj[key] = source[key];\n        });\n      });\n      return obj;\n    }\n    function _class(obj) {\n      return Object.prototype.toString.call(obj);\n    }\n    function isString(obj) {\n      return _class(obj) === \"[object String]\";\n    }\n    function isObject(obj) {\n      return _class(obj) === \"[object Object]\";\n    }\n    function isRegExp(obj) {\n      return _class(obj) === \"[object RegExp]\";\n    }\n    function isFunction2(obj) {\n      return _class(obj) === \"[object Function]\";\n    }\n    function escapeRE(str) {\n      return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"\\\\$&\");\n    }\n    var defaultOptions = {\n      fuzzyLink: true,\n      fuzzyEmail: true,\n      fuzzyIP: false\n    };\n    function isOptionsObj(obj) {\n      return Object.keys(obj || {}).reduce(function(acc, k) {\n        return acc || defaultOptions.hasOwnProperty(k);\n      }, false);\n    }\n    var defaultSchemas = {\n      \"http:\": {\n        validate: function(text2, pos, self) {\n          var tail = text2.slice(pos);\n          if (!self.re.http) {\n            self.re.http = new RegExp(\"^\\\\/\\\\/\" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, \"i\");\n          }\n          if (self.re.http.test(tail)) {\n            return tail.match(self.re.http)[0].length;\n          }\n          return 0;\n        }\n      },\n      \"https:\": \"http:\",\n      \"ftp:\": \"http:\",\n      \"//\": {\n        validate: function(text2, pos, self) {\n          var tail = text2.slice(pos);\n          if (!self.re.no_http) {\n            self.re.no_http = new RegExp(\"^\" + self.re.src_auth + \"(?:localhost|(?:(?:\" + self.re.src_domain + \")\\\\.)+\" + self.re.src_domain_root + \")\" + self.re.src_port + self.re.src_host_terminator + self.re.src_path, \"i\");\n          }\n          if (self.re.no_http.test(tail)) {\n            if (pos >= 3 && text2[pos - 3] === \":\") {\n              return 0;\n            }\n            if (pos >= 3 && text2[pos - 3] === \"/\") {\n              return 0;\n            }\n            return tail.match(self.re.no_http)[0].length;\n          }\n          return 0;\n        }\n      },\n      \"mailto:\": {\n        validate: function(text2, pos, self) {\n          var tail = text2.slice(pos);\n          if (!self.re.mailto) {\n            self.re.mailto = new RegExp(\"^\" + self.re.src_email_name + \"@\" + self.re.src_host_strict, \"i\");\n          }\n          if (self.re.mailto.test(tail)) {\n            return tail.match(self.re.mailto)[0].length;\n          }\n          return 0;\n        }\n      }\n    };\n    var tlds_2ch_src_re = \"a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]\";\n    var tlds_default = \"biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\\u0440\\u0444\".split(\"|\");\n    function resetScanCache(self) {\n      self.__index__ = -1;\n      self.__text_cache__ = \"\";\n    }\n    function createValidator(re) {\n      return function(text2, pos) {\n        var tail = text2.slice(pos);\n        if (re.test(tail)) {\n          return tail.match(re)[0].length;\n        }\n        return 0;\n      };\n    }\n    function createNormalizer() {\n      return function(match, self) {\n        self.normalize(match);\n      };\n    }\n    function compile(self) {\n      var re = self.re = require_re()(self.__opts__);\n      var tlds = self.__tlds__.slice();\n      self.onCompile();\n      if (!self.__tlds_replaced__) {\n        tlds.push(tlds_2ch_src_re);\n      }\n      tlds.push(re.src_xn);\n      re.src_tlds = tlds.join(\"|\");\n      function untpl(tpl) {\n        return tpl.replace(\"%TLDS%\", re.src_tlds);\n      }\n      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), \"i\");\n      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), \"i\");\n      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), \"i\");\n      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), \"i\");\n      var aliases = [];\n      self.__compiled__ = {};\n      function schemaError(name, val) {\n        throw new Error('(LinkifyIt) Invalid schema \"' + name + '\": ' + val);\n      }\n      Object.keys(self.__schemas__).forEach(function(name) {\n        var val = self.__schemas__[name];\n        if (val === null) {\n          return;\n        }\n        var compiled = { validate: null, link: null };\n        self.__compiled__[name] = compiled;\n        if (isObject(val)) {\n          if (isRegExp(val.validate)) {\n            compiled.validate = createValidator(val.validate);\n          } else if (isFunction2(val.validate)) {\n            compiled.validate = val.validate;\n          } else {\n            schemaError(name, val);\n          }\n          if (isFunction2(val.normalize)) {\n            compiled.normalize = val.normalize;\n          } else if (!val.normalize) {\n            compiled.normalize = createNormalizer();\n          } else {\n            schemaError(name, val);\n          }\n          return;\n        }\n        if (isString(val)) {\n          aliases.push(name);\n          return;\n        }\n        schemaError(name, val);\n      });\n      aliases.forEach(function(alias) {\n        if (!self.__compiled__[self.__schemas__[alias]]) {\n          return;\n        }\n        self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;\n        self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;\n      });\n      self.__compiled__[\"\"] = { validate: null, normalize: createNormalizer() };\n      var slist = Object.keys(self.__compiled__).filter(function(name) {\n        return name.length > 0 && self.__compiled__[name];\n      }).map(escapeRE).join(\"|\");\n      self.re.schema_test = RegExp(\"(^|(?!_)(?:[><\\uFF5C]|\" + re.src_ZPCc + \"))(\" + slist + \")\", \"i\");\n      self.re.schema_search = RegExp(\"(^|(?!_)(?:[><\\uFF5C]|\" + re.src_ZPCc + \"))(\" + slist + \")\", \"ig\");\n      self.re.pretest = RegExp(\"(\" + self.re.schema_test.source + \")|(\" + self.re.host_fuzzy_test.source + \")|@\", \"i\");\n      resetScanCache(self);\n    }\n    function Match(self, shift) {\n      var start = self.__index__, end = self.__last_index__, text2 = self.__text_cache__.slice(start, end);\n      this.schema = self.__schema__.toLowerCase();\n      this.index = start + shift;\n      this.lastIndex = end + shift;\n      this.raw = text2;\n      this.text = text2;\n      this.url = text2;\n    }\n    function createMatch(self, shift) {\n      var match = new Match(self, shift);\n      self.__compiled__[match.schema].normalize(match, self);\n      return match;\n    }\n    function LinkifyIt(schemas, options) {\n      if (!(this instanceof LinkifyIt)) {\n        return new LinkifyIt(schemas, options);\n      }\n      if (!options) {\n        if (isOptionsObj(schemas)) {\n          options = schemas;\n          schemas = {};\n        }\n      }\n      this.__opts__ = assign({}, defaultOptions, options);\n      this.__index__ = -1;\n      this.__last_index__ = -1;\n      this.__schema__ = \"\";\n      this.__text_cache__ = \"\";\n      this.__schemas__ = assign({}, defaultSchemas, schemas);\n      this.__compiled__ = {};\n      this.__tlds__ = tlds_default;\n      this.__tlds_replaced__ = false;\n      this.re = {};\n      compile(this);\n    }\n    LinkifyIt.prototype.add = function add(schema, definition) {\n      this.__schemas__[schema] = definition;\n      compile(this);\n      return this;\n    };\n    LinkifyIt.prototype.set = function set(options) {\n      this.__opts__ = assign(this.__opts__, options);\n      return this;\n    };\n    LinkifyIt.prototype.test = function test(text2) {\n      this.__text_cache__ = text2;\n      this.__index__ = -1;\n      if (!text2.length) {\n        return false;\n      }\n      var m, ml, me, len, shift, next, re, tld_pos, at_pos;\n      if (this.re.schema_test.test(text2)) {\n        re = this.re.schema_search;\n        re.lastIndex = 0;\n        while ((m = re.exec(text2)) !== null) {\n          len = this.testSchemaAt(text2, m[2], re.lastIndex);\n          if (len) {\n            this.__schema__ = m[2];\n            this.__index__ = m.index + m[1].length;\n            this.__last_index__ = m.index + m[0].length + len;\n            break;\n          }\n        }\n      }\n      if (this.__opts__.fuzzyLink && this.__compiled__[\"http:\"]) {\n        tld_pos = text2.search(this.re.host_fuzzy_test);\n        if (tld_pos >= 0) {\n          if (this.__index__ < 0 || tld_pos < this.__index__) {\n            if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {\n              shift = ml.index + ml[1].length;\n              if (this.__index__ < 0 || shift < this.__index__) {\n                this.__schema__ = \"\";\n                this.__index__ = shift;\n                this.__last_index__ = ml.index + ml[0].length;\n              }\n            }\n          }\n        }\n      }\n      if (this.__opts__.fuzzyEmail && this.__compiled__[\"mailto:\"]) {\n        at_pos = text2.indexOf(\"@\");\n        if (at_pos >= 0) {\n          if ((me = text2.match(this.re.email_fuzzy)) !== null) {\n            shift = me.index + me[1].length;\n            next = me.index + me[0].length;\n            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {\n              this.__schema__ = \"mailto:\";\n              this.__index__ = shift;\n              this.__last_index__ = next;\n            }\n          }\n        }\n      }\n      return this.__index__ >= 0;\n    };\n    LinkifyIt.prototype.pretest = function pretest(text2) {\n      return this.re.pretest.test(text2);\n    };\n    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {\n      if (!this.__compiled__[schema.toLowerCase()]) {\n        return 0;\n      }\n      return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);\n    };\n    LinkifyIt.prototype.match = function match(text2) {\n      var shift = 0, result = [];\n      if (this.__index__ >= 0 && this.__text_cache__ === text2) {\n        result.push(createMatch(this, shift));\n        shift = this.__last_index__;\n      }\n      var tail = shift ? text2.slice(shift) : text2;\n      while (this.test(tail)) {\n        result.push(createMatch(this, shift));\n        tail = tail.slice(this.__last_index__);\n        shift += this.__last_index__;\n      }\n      if (result.length) {\n        return result;\n      }\n      return null;\n    };\n    LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {\n      list2 = Array.isArray(list2) ? list2 : [list2];\n      if (!keepOld) {\n        this.__tlds__ = list2.slice();\n        this.__tlds_replaced__ = true;\n        compile(this);\n        return this;\n      }\n      this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {\n        return el !== arr[idx - 1];\n      }).reverse();\n      compile(this);\n      return this;\n    };\n    LinkifyIt.prototype.normalize = function normalize(match) {\n      if (!match.schema) {\n        match.url = \"http://\" + match.url;\n      }\n      if (match.schema === \"mailto:\" && !/^mailto:/i.test(match.url)) {\n        match.url = \"mailto:\" + match.url;\n      }\n    };\n    LinkifyIt.prototype.onCompile = function onCompile() {\n    };\n    module.exports = LinkifyIt;\n  }\n});\n\n// node_modules/punycode/punycode.js\nvar require_punycode = __commonJS({\n  \"node_modules/punycode/punycode.js\"(exports, module) {\n    \"use strict\";\n    var maxInt = 2147483647;\n    var base = 36;\n    var tMin = 1;\n    var tMax = 26;\n    var skew = 38;\n    var damp = 700;\n    var initialBias = 72;\n    var initialN = 128;\n    var delimiter = \"-\";\n    var regexPunycode = /^xn--/;\n    var regexNonASCII = /[^\\0-\\x7E]/;\n    var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\n    var errors = {\n      \"overflow\": \"Overflow: input needs wider integers to process\",\n      \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n      \"invalid-input\": \"Invalid input\"\n    };\n    var baseMinusTMin = base - tMin;\n    var floor = Math.floor;\n    var stringFromCharCode = String.fromCharCode;\n    function error2(type) {\n      throw new RangeError(errors[type]);\n    }\n    function map(array, fn) {\n      const result = [];\n      let length = array.length;\n      while (length--) {\n        result[length] = fn(array[length]);\n      }\n      return result;\n    }\n    function mapDomain(string, fn) {\n      const parts = string.split(\"@\");\n      let result = \"\";\n      if (parts.length > 1) {\n        result = parts[0] + \"@\";\n        string = parts[1];\n      }\n      string = string.replace(regexSeparators, \".\");\n      const labels = string.split(\".\");\n      const encoded = map(labels, fn).join(\".\");\n      return result + encoded;\n    }\n    function ucs2decode(string) {\n      const output = [];\n      let counter = 0;\n      const length = string.length;\n      while (counter < length) {\n        const value = string.charCodeAt(counter++);\n        if (value >= 55296 && value <= 56319 && counter < length) {\n          const extra = string.charCodeAt(counter++);\n          if ((extra & 64512) == 56320) {\n            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);\n          } else {\n            output.push(value);\n            counter--;\n          }\n        } else {\n          output.push(value);\n        }\n      }\n      return output;\n    }\n    var ucs2encode = (array) => String.fromCodePoint(...array);\n    var basicToDigit = function(codePoint) {\n      if (codePoint - 48 < 10) {\n        return codePoint - 22;\n      }\n      if (codePoint - 65 < 26) {\n        return codePoint - 65;\n      }\n      if (codePoint - 97 < 26) {\n        return codePoint - 97;\n      }\n      return base;\n    };\n    var digitToBasic = function(digit, flag) {\n      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    };\n    var adapt = function(delta, numPoints, firstTime) {\n      let k = 0;\n      delta = firstTime ? floor(delta / damp) : delta >> 1;\n      delta += floor(delta / numPoints);\n      for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n        delta = floor(delta / baseMinusTMin);\n      }\n      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    };\n    var decode = function(input) {\n      const output = [];\n      const inputLength = input.length;\n      let i = 0;\n      let n = initialN;\n      let bias = initialBias;\n      let basic = input.lastIndexOf(delimiter);\n      if (basic < 0) {\n        basic = 0;\n      }\n      for (let j = 0; j < basic; ++j) {\n        if (input.charCodeAt(j) >= 128) {\n          error2(\"not-basic\");\n        }\n        output.push(input.charCodeAt(j));\n      }\n      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {\n        let oldi = i;\n        for (let w = 1, k = base; ; k += base) {\n          if (index >= inputLength) {\n            error2(\"invalid-input\");\n          }\n          const digit = basicToDigit(input.charCodeAt(index++));\n          if (digit >= base || digit > floor((maxInt - i) / w)) {\n            error2(\"overflow\");\n          }\n          i += digit * w;\n          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n          if (digit < t) {\n            break;\n          }\n          const baseMinusT = base - t;\n          if (w > floor(maxInt / baseMinusT)) {\n            error2(\"overflow\");\n          }\n          w *= baseMinusT;\n        }\n        const out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi == 0);\n        if (floor(i / out) > maxInt - n) {\n          error2(\"overflow\");\n        }\n        n += floor(i / out);\n        i %= out;\n        output.splice(i++, 0, n);\n      }\n      return String.fromCodePoint(...output);\n    };\n    var encode = function(input) {\n      const output = [];\n      input = ucs2decode(input);\n      let inputLength = input.length;\n      let n = initialN;\n      let delta = 0;\n      let bias = initialBias;\n      for (const currentValue of input) {\n        if (currentValue < 128) {\n          output.push(stringFromCharCode(currentValue));\n        }\n      }\n      let basicLength = output.length;\n      let handledCPCount = basicLength;\n      if (basicLength) {\n        output.push(delimiter);\n      }\n      while (handledCPCount < inputLength) {\n        let m = maxInt;\n        for (const currentValue of input) {\n          if (currentValue >= n && currentValue < m) {\n            m = currentValue;\n          }\n        }\n        const handledCPCountPlusOne = handledCPCount + 1;\n        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n          error2(\"overflow\");\n        }\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n        for (const currentValue of input) {\n          if (currentValue < n && ++delta > maxInt) {\n            error2(\"overflow\");\n          }\n          if (currentValue == n) {\n            let q = delta;\n            for (let k = base; ; k += base) {\n              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n              if (q < t) {\n                break;\n              }\n              const qMinusT = q - t;\n              const baseMinusT = base - t;\n              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n              q = floor(qMinusT / baseMinusT);\n            }\n            output.push(stringFromCharCode(digitToBasic(q, 0)));\n            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n            delta = 0;\n            ++handledCPCount;\n          }\n        }\n        ++delta;\n        ++n;\n      }\n      return output.join(\"\");\n    };\n    var toUnicode = function(input) {\n      return mapDomain(input, function(string) {\n        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n      });\n    };\n    var toASCII = function(input) {\n      return mapDomain(input, function(string) {\n        return regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\n      });\n    };\n    var punycode = {\n      \"version\": \"2.1.0\",\n      \"ucs2\": {\n        \"decode\": ucs2decode,\n        \"encode\": ucs2encode\n      },\n      \"decode\": decode,\n      \"encode\": encode,\n      \"toASCII\": toASCII,\n      \"toUnicode\": toUnicode\n    };\n    module.exports = punycode;\n  }\n});\n\n// node_modules/markdown-it/lib/presets/default.js\nvar require_default = __commonJS({\n  \"node_modules/markdown-it/lib/presets/default.js\"(exports, module) {\n    \"use strict\";\n    module.exports = {\n      options: {\n        html: false,\n        xhtmlOut: false,\n        breaks: false,\n        langPrefix: \"language-\",\n        linkify: false,\n        typographer: false,\n        quotes: \"\\u201C\\u201D\\u2018\\u2019\",\n        highlight: null,\n        maxNesting: 100\n      },\n      components: {\n        core: {},\n        block: {},\n        inline: {}\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/presets/zero.js\nvar require_zero = __commonJS({\n  \"node_modules/markdown-it/lib/presets/zero.js\"(exports, module) {\n    \"use strict\";\n    module.exports = {\n      options: {\n        html: false,\n        xhtmlOut: false,\n        breaks: false,\n        langPrefix: \"language-\",\n        linkify: false,\n        typographer: false,\n        quotes: \"\\u201C\\u201D\\u2018\\u2019\",\n        highlight: null,\n        maxNesting: 20\n      },\n      components: {\n        core: {\n          rules: [\n            \"normalize\",\n            \"block\",\n            \"inline\"\n          ]\n        },\n        block: {\n          rules: [\n            \"paragraph\"\n          ]\n        },\n        inline: {\n          rules: [\n            \"text\"\n          ],\n          rules2: [\n            \"balance_pairs\",\n            \"text_collapse\"\n          ]\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/presets/commonmark.js\nvar require_commonmark = __commonJS({\n  \"node_modules/markdown-it/lib/presets/commonmark.js\"(exports, module) {\n    \"use strict\";\n    module.exports = {\n      options: {\n        html: true,\n        xhtmlOut: true,\n        breaks: false,\n        langPrefix: \"language-\",\n        linkify: false,\n        typographer: false,\n        quotes: \"\\u201C\\u201D\\u2018\\u2019\",\n        highlight: null,\n        maxNesting: 20\n      },\n      components: {\n        core: {\n          rules: [\n            \"normalize\",\n            \"block\",\n            \"inline\"\n          ]\n        },\n        block: {\n          rules: [\n            \"blockquote\",\n            \"code\",\n            \"fence\",\n            \"heading\",\n            \"hr\",\n            \"html_block\",\n            \"lheading\",\n            \"list\",\n            \"reference\",\n            \"paragraph\"\n          ]\n        },\n        inline: {\n          rules: [\n            \"autolink\",\n            \"backticks\",\n            \"emphasis\",\n            \"entity\",\n            \"escape\",\n            \"html_inline\",\n            \"image\",\n            \"link\",\n            \"newline\",\n            \"text\"\n          ],\n          rules2: [\n            \"balance_pairs\",\n            \"emphasis\",\n            \"text_collapse\"\n          ]\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/index.js\nvar require_lib = __commonJS({\n  \"node_modules/markdown-it/lib/index.js\"(exports, module) {\n    \"use strict\";\n    var utils = require_utils();\n    var helpers = require_helpers();\n    var Renderer = require_renderer();\n    var ParserCore = require_parser_core();\n    var ParserBlock = require_parser_block();\n    var ParserInline = require_parser_inline();\n    var LinkifyIt = require_linkify_it();\n    var mdurl = require_mdurl();\n    var punycode = require_punycode();\n    var config = {\n      default: require_default(),\n      zero: require_zero(),\n      commonmark: require_commonmark()\n    };\n    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;\n    var GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/;\n    function validateLink(url) {\n      var str = url.trim().toLowerCase();\n      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;\n    }\n    var RECODE_HOSTNAME_FOR = [\"http:\", \"https:\", \"mailto:\"];\n    function normalizeLink(url) {\n      var parsed = mdurl.parse(url, true);\n      if (parsed.hostname) {\n        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n          try {\n            parsed.hostname = punycode.toASCII(parsed.hostname);\n          } catch (er) {\n          }\n        }\n      }\n      return mdurl.encode(mdurl.format(parsed));\n    }\n    function normalizeLinkText(url) {\n      var parsed = mdurl.parse(url, true);\n      if (parsed.hostname) {\n        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n          try {\n            parsed.hostname = punycode.toUnicode(parsed.hostname);\n          } catch (er) {\n          }\n        }\n      }\n      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + \"%\");\n    }\n    function MarkdownIt3(presetName, options) {\n      if (!(this instanceof MarkdownIt3)) {\n        return new MarkdownIt3(presetName, options);\n      }\n      if (!options) {\n        if (!utils.isString(presetName)) {\n          options = presetName || {};\n          presetName = \"default\";\n        }\n      }\n      this.inline = new ParserInline();\n      this.block = new ParserBlock();\n      this.core = new ParserCore();\n      this.renderer = new Renderer();\n      this.linkify = new LinkifyIt();\n      this.validateLink = validateLink;\n      this.normalizeLink = normalizeLink;\n      this.normalizeLinkText = normalizeLinkText;\n      this.utils = utils;\n      this.helpers = utils.assign({}, helpers);\n      this.options = {};\n      this.configure(presetName);\n      if (options) {\n        this.set(options);\n      }\n    }\n    MarkdownIt3.prototype.set = function(options) {\n      utils.assign(this.options, options);\n      return this;\n    };\n    MarkdownIt3.prototype.configure = function(presets) {\n      var self = this, presetName;\n      if (utils.isString(presets)) {\n        presetName = presets;\n        presets = config[presetName];\n        if (!presets) {\n          throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name');\n        }\n      }\n      if (!presets) {\n        throw new Error(\"Wrong `markdown-it` preset, can't be empty\");\n      }\n      if (presets.options) {\n        self.set(presets.options);\n      }\n      if (presets.components) {\n        Object.keys(presets.components).forEach(function(name) {\n          if (presets.components[name].rules) {\n            self[name].ruler.enableOnly(presets.components[name].rules);\n          }\n          if (presets.components[name].rules2) {\n            self[name].ruler2.enableOnly(presets.components[name].rules2);\n          }\n        });\n      }\n      return this;\n    };\n    MarkdownIt3.prototype.enable = function(list2, ignoreInvalid) {\n      var result = [];\n      if (!Array.isArray(list2)) {\n        list2 = [list2];\n      }\n      [\"core\", \"block\", \"inline\"].forEach(function(chain) {\n        result = result.concat(this[chain].ruler.enable(list2, true));\n      }, this);\n      result = result.concat(this.inline.ruler2.enable(list2, true));\n      var missed = list2.filter(function(name) {\n        return result.indexOf(name) < 0;\n      });\n      if (missed.length && !ignoreInvalid) {\n        throw new Error(\"MarkdownIt. Failed to enable unknown rule(s): \" + missed);\n      }\n      return this;\n    };\n    MarkdownIt3.prototype.disable = function(list2, ignoreInvalid) {\n      var result = [];\n      if (!Array.isArray(list2)) {\n        list2 = [list2];\n      }\n      [\"core\", \"block\", \"inline\"].forEach(function(chain) {\n        result = result.concat(this[chain].ruler.disable(list2, true));\n      }, this);\n      result = result.concat(this.inline.ruler2.disable(list2, true));\n      var missed = list2.filter(function(name) {\n        return result.indexOf(name) < 0;\n      });\n      if (missed.length && !ignoreInvalid) {\n        throw new Error(\"MarkdownIt. Failed to disable unknown rule(s): \" + missed);\n      }\n      return this;\n    };\n    MarkdownIt3.prototype.use = function(plugin4) {\n      var args = [this].concat(Array.prototype.slice.call(arguments, 1));\n      plugin4.apply(plugin4, args);\n      return this;\n    };\n    MarkdownIt3.prototype.parse = function(src, env) {\n      if (typeof src !== \"string\") {\n        throw new Error(\"Input data should be a String\");\n      }\n      var state = new this.core.State(src, this, env);\n      this.core.process(state);\n      return state.tokens;\n    };\n    MarkdownIt3.prototype.render = function(src, env) {\n      env = env || {};\n      return this.renderer.render(this.parse(src, env), this.options, env);\n    };\n    MarkdownIt3.prototype.parseInline = function(src, env) {\n      var state = new this.core.State(src, this, env);\n      state.inlineMode = true;\n      this.core.process(state);\n      return state.tokens;\n    };\n    MarkdownIt3.prototype.renderInline = function(src, env) {\n      env = env || {};\n      return this.renderer.render(this.parseInline(src, env), this.options, env);\n    };\n    module.exports = MarkdownIt3;\n  }\n});\n\n// node_modules/markdown-it/index.js\nvar require_markdown_it = __commonJS({\n  \"node_modules/markdown-it/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = require_lib();\n  }\n});\n\n// src/ast/base.ts\nvar base_exports = {};\n__export(base_exports, {\n  getAstValues: () => getAstValues,\n  isAst: () => isAst,\n  isFunction: () => isFunction,\n  isVariable: () => isVariable,\n  resolve: () => resolve\n});\nfunction isAst(value) {\n  return !!value?.$$mdtype;\n}\nfunction isFunction(value) {\n  return !!(value?.$$mdtype === \"Function\");\n}\nfunction isVariable(value) {\n  return !!(value?.$$mdtype === \"Variable\");\n}\nfunction* getAstValues(value) {\n  if (value == null || typeof value !== \"object\")\n    return;\n  if (Array.isArray(value))\n    for (const v of value)\n      yield* getAstValues(v);\n  if (isAst(value))\n    yield value;\n  if (Object.getPrototypeOf(value) !== Object.prototype)\n    return;\n  for (const v of Object.values(value))\n    yield* getAstValues(v);\n}\nfunction resolve(value, config = {}) {\n  if (value == null || typeof value !== \"object\")\n    return value;\n  if (Array.isArray(value))\n    return value.map((item2) => resolve(item2, config));\n  if (isAst(value) && value?.resolve instanceof Function)\n    return value.resolve(config);\n  if (Object.getPrototypeOf(value) !== Object.prototype)\n    return value;\n  const output = {};\n  for (const [k, v] of Object.entries(value))\n    output[k] = resolve(v, config);\n  return output;\n}\n\n// src/tag.ts\nvar Tag = class {\n  constructor(name = \"div\", attributes = {}, children = []) {\n    this.$$mdtype = \"Tag\";\n    this.name = name;\n    this.attributes = attributes;\n    this.children = children;\n  }\n};\nTag.isTag = (tag) => {\n  return !!(tag?.$$mdtype === \"Tag\");\n};\n\n// src/schema-types/class.ts\nvar Class = class {\n  validate(value, _config, key) {\n    if (typeof value === \"string\" || typeof value === \"object\")\n      return [];\n    return [\n      {\n        id: \"attribute-type-invalid\",\n        level: \"error\",\n        message: `Attribute '${key}' must be type 'string | object'`\n      }\n    ];\n  }\n  transform(value) {\n    if (!value || typeof value === \"string\")\n      return value;\n    const classes = [];\n    for (const [k, v] of Object.entries(value ?? {}))\n      if (v)\n        classes.push(k);\n    return classes.join(\" \");\n  }\n};\n\n// src/schema-types/id.ts\nvar Id = class {\n  validate(value) {\n    if (typeof value === \"string\" && value.match(/^[a-zA-Z]/))\n      return [];\n    return [\n      {\n        id: \"attribute-value-invalid\",\n        level: \"error\",\n        message: \"The 'id' attribute must start with a letter\"\n      }\n    ];\n  }\n};\n\n// src/utils.ts\nvar import_tag = __toModule(require_tag());\n\n// src/ast/variable.ts\nvar Variable = class {\n  constructor(path = []) {\n    this.$$mdtype = \"Variable\";\n    this.path = path;\n  }\n  resolve({ variables } = {}) {\n    return variables instanceof Function ? variables(this.path) : this.path.reduce((obj = {}, key) => obj[key], variables);\n  }\n};\n\n// src/ast/function.ts\nvar Function2 = class {\n  constructor(name, parameters) {\n    this.$$mdtype = \"Function\";\n    this.name = name;\n    this.parameters = parameters;\n  }\n  resolve(config = {}) {\n    const fn = config?.functions?.[this.name];\n    if (!fn)\n      return null;\n    const parameters = resolve(this.parameters, config);\n    return fn.transform?.(parameters, config);\n  }\n};\n\n// src/utils.ts\nvar STATES;\n(function(STATES2) {\n  STATES2[STATES2[\"normal\"] = 0] = \"normal\";\n  STATES2[STATES2[\"string\"] = 1] = \"string\";\n  STATES2[STATES2[\"escape\"] = 2] = \"escape\";\n})(STATES || (STATES = {}));\nvar OPEN = \"{%\";\nvar CLOSE = \"%}\";\nvar IDENTIFIER_REGEX = /^[a-zA-Z0-9_-]+$/;\nfunction isIdentifier(s2) {\n  return typeof s2 === \"string\" && IDENTIFIER_REGEX.test(s2);\n}\nfunction isPromise(a) {\n  return a && typeof a === \"object\" && typeof a.then === \"function\";\n}\nfunction findTagEnd(content, start = 0) {\n  let state = 0;\n  for (let pos = start; pos < content.length; pos++) {\n    const char = content[pos];\n    switch (state) {\n      case 1:\n        switch (char) {\n          case '\"':\n            state = 0;\n            break;\n          case \"\\\\\":\n            state = 2;\n            break;\n        }\n        break;\n      case 2:\n        state = 1;\n        break;\n      case 0:\n        if (char === '\"')\n          state = 1;\n        else if (content.startsWith(CLOSE, pos))\n          return pos;\n    }\n  }\n  return null;\n}\nfunction parseTag(content, line, contentStart) {\n  try {\n    return (0, import_tag.parse)(content, { Variable, Function: Function2 });\n  } catch (error2) {\n    if (!(error2 instanceof import_tag.SyntaxError))\n      throw error2;\n    const {\n      message,\n      location: { start, end }\n    } = error2;\n    const location = {\n      start: { line, character: start.offset + contentStart },\n      end: { line: line + 1, character: end.offset + contentStart }\n    };\n    return { type: \"error\", meta: { error: { message, location } } };\n  }\n}\nfunction parseTags(content, firstLine = 0) {\n  let line = firstLine + 1;\n  const output = [];\n  let start = 0;\n  for (let pos = 0; pos < content.length; pos++) {\n    if (content[pos] === \"\\n\") {\n      line++;\n      continue;\n    }\n    if (!content.startsWith(OPEN, pos))\n      continue;\n    const end = findTagEnd(content, pos);\n    if (end == null) {\n      pos = pos + OPEN.length;\n      continue;\n    }\n    const text2 = content.slice(pos, end + CLOSE.length);\n    const inner = content.slice(pos + OPEN.length, end);\n    const lineStart = content.lastIndexOf(\"\\n\", pos);\n    const lineEnd = content.indexOf(\"\\n\", end);\n    const lineContent = content.slice(lineStart, lineEnd);\n    const tag = parseTag(inner.trim(), line, pos - lineStart);\n    const precedingTextEnd = lineContent.trim() === text2 ? lineStart : pos;\n    const precedingText = content.slice(start, precedingTextEnd);\n    output.push({\n      type: \"text\",\n      start,\n      end: pos - 1,\n      content: precedingText\n    });\n    output.push({\n      map: [line, line + 1],\n      position: {\n        start: pos - lineStart,\n        end: pos - lineStart + text2.length\n      },\n      start: pos,\n      end: pos + text2.length - 1,\n      info: text2,\n      ...tag\n    });\n    start = end + CLOSE.length;\n    pos = start - 1;\n  }\n  output.push({\n    type: \"text\",\n    start,\n    end: content.length - 1,\n    content: content.slice(start)\n  });\n  return output;\n}\n\n// src/transformer.ts\nvar globalAttributes = {\n  class: { type: Class, render: true },\n  id: { type: Id, render: true }\n};\nvar transformer_default = {\n  findSchema(node2, { nodes = {}, tags = {} } = {}) {\n    return node2.tag ? tags[node2.tag] : nodes[node2.type];\n  },\n  attributes(node2, config = {}) {\n    const schema = this.findSchema(node2, config) ?? {};\n    const output = {};\n    const attrs = { ...globalAttributes, ...schema.attributes };\n    for (const [key, attr] of Object.entries(attrs)) {\n      if (attr.render == false)\n        continue;\n      const name = typeof attr.render === \"string\" ? attr.render : key;\n      let value = node2.attributes[key];\n      if (typeof attr.type === \"function\") {\n        const instance = new attr.type();\n        if (instance.transform) {\n          value = instance.transform(value, config);\n        }\n      }\n      value = value === void 0 ? attr.default : value;\n      if (value === void 0)\n        continue;\n      output[name] = value;\n    }\n    if (schema.slots) {\n      for (const [key, slot2] of Object.entries(schema.slots)) {\n        if (slot2.render === false)\n          continue;\n        const name = typeof slot2.render === \"string\" ? slot2.render : key;\n        if (node2.slots[key])\n          output[name] = this.node(node2.slots[key], config);\n      }\n    }\n    return output;\n  },\n  children(node2, config = {}) {\n    const children = node2.children.flatMap((child) => this.node(child, config));\n    if (children.some(isPromise)) {\n      return Promise.all(children);\n    }\n    return children;\n  },\n  node(node2, config = {}) {\n    const schema = this.findSchema(node2, config) ?? {};\n    if (schema && schema.transform instanceof Function)\n      return schema.transform(node2, config);\n    const children = this.children(node2, config);\n    if (!schema || !schema.render)\n      return children;\n    const attributes = this.attributes(node2, config);\n    if (isPromise(attributes) || isPromise(children)) {\n      return Promise.all([attributes, children]).then((values) => new Tag(schema.render, ...values));\n    }\n    return new Tag(schema.render, attributes, children);\n  }\n};\n\n// src/ast/node.ts\nvar Node = class {\n  constructor(type = \"node\", attributes = {}, children = [], tag) {\n    this.$$mdtype = \"Node\";\n    this.errors = [];\n    this.lines = [];\n    this.inline = false;\n    this.attributes = attributes;\n    this.children = children;\n    this.type = type;\n    this.tag = tag;\n    this.annotations = [];\n    this.slots = {};\n  }\n  *walk() {\n    for (const child of [...Object.values(this.slots), ...this.children]) {\n      yield child;\n      yield* child.walk();\n    }\n  }\n  push(node2) {\n    this.children.push(node2);\n  }\n  resolve(config = {}) {\n    return Object.assign(new Node(), this, {\n      children: this.children.map((child) => child.resolve(config)),\n      attributes: resolve(this.attributes, config),\n      slots: Object.fromEntries(Object.entries(this.slots).map(([name, slot2]) => [\n        name,\n        slot2.resolve(config)\n      ]))\n    });\n  }\n  findSchema(config = {}) {\n    return transformer_default.findSchema(this, config);\n  }\n  transformAttributes(config = {}) {\n    return transformer_default.attributes(this, config);\n  }\n  transformChildren(config) {\n    return transformer_default.children(this, config);\n  }\n  transform(config) {\n    return transformer_default.node(this, config);\n  }\n};\n\n// src/ast/index.ts\nvar AstTypes = {\n  Function: Function2,\n  Node,\n  Variable\n};\nfunction reviver(_, value) {\n  if (!value)\n    return value;\n  const klass = AstTypes[value.$$mdtype];\n  return klass ? Object.assign(new klass(), value) : value;\n}\nfunction fromJSON(text2) {\n  return JSON.parse(text2, reviver);\n}\nvar ast_default = {\n  ...AstTypes,\n  ...base_exports,\n  fromJSON\n};\n\n// src/formatter.ts\nvar SPACE = \" \";\nvar SEP = \", \";\nvar NL = \"\\n\";\nvar OL = \".\";\nvar UL = \"-\";\nvar MAX_TAG_OPENING_WIDTH = 80;\nvar WRAPPING_TYPES = [\"strong\", \"em\", \"s\"];\nvar max = (a, b) => Math.max(a, b);\nvar increment = (o, n = 2) => ({\n  ...o,\n  indent: (o.indent || 0) + n\n});\nfunction* formatChildren(a, options) {\n  for (const child of a.children) {\n    yield* formatValue(child, options);\n  }\n}\nfunction* formatInline(g) {\n  yield [...g].join(\"\").trim();\n}\nfunction* formatTableRow(items) {\n  yield `| ${items.join(\" | \")} |`;\n}\nfunction formatScalar(v) {\n  if (v === void 0) {\n    return void 0;\n  }\n  if (ast_default.isAst(v)) {\n    return format(v);\n  }\n  if (v === null) {\n    return \"null\";\n  }\n  if (Array.isArray(v)) {\n    return \"[\" + v.map(formatScalar).join(SEP) + \"]\";\n  }\n  if (typeof v === \"object\") {\n    return \"{\" + Object.entries(v).map(([key, value]) => `${isIdentifier(key) ? key : `\"${key}\"`}: ${formatScalar(value)}`).join(SEP) + \"}\";\n  }\n  return JSON.stringify(v);\n}\nfunction formatAnnotationValue(a) {\n  const formattedValue = formatScalar(a.value);\n  if (formattedValue === void 0)\n    return void 0;\n  if (a.name === \"primary\")\n    return formattedValue;\n  if (a.name === \"id\" && typeof a.value === \"string\" && isIdentifier(a.value))\n    return \"#\" + a.value;\n  if (a.type === \"class\" && isIdentifier(a.name))\n    return \".\" + a.name;\n  return `${a.name}=${formattedValue}`;\n}\nfunction* formatAttributes(n) {\n  for (const [key, value] of Object.entries(n.attributes)) {\n    if (key === \"class\" && typeof value === \"object\" && !ast_default.isAst(value))\n      for (const name of Object.keys(value)) {\n        yield formatAnnotationValue({ type: \"class\", name, value });\n      }\n    else\n      yield formatAnnotationValue({ type: \"attribute\", name: key, value });\n  }\n}\nfunction* formatAnnotations(n) {\n  if (n.annotations.length) {\n    yield OPEN + SPACE;\n    yield n.annotations.map(formatAnnotationValue).join(SPACE);\n    yield SPACE + CLOSE;\n  }\n}\nfunction* formatVariable(v) {\n  yield \"$\";\n  yield v.path.map((p, i) => {\n    if (i === 0)\n      return p;\n    if (isIdentifier(p))\n      return \".\" + p;\n    if (typeof p === \"number\")\n      return `[${p}]`;\n    return `[\"${p}\"]`;\n  }).join(\"\");\n}\nfunction* formatFunction(f) {\n  yield f.name;\n  yield \"(\";\n  yield Object.values(f.parameters).map(formatScalar).join(SEP);\n  yield \")\";\n}\nfunction* trimStart(g) {\n  let n;\n  do {\n    const { value, done } = g.next();\n    if (done)\n      return;\n    n = value.trimStart();\n  } while (!n.length);\n  yield n;\n  yield* g;\n}\nfunction* escapeMarkdownCharacters(s2, characters) {\n  yield s2.replace(characters, \"\\\\$&\").replace(new RegExp(\"\\xA0\", \"g\"), \"&nbsp;\");\n}\nfunction* formatNode(n, o = {}) {\n  const no = { ...o, parent: n };\n  const indent = SPACE.repeat(no.indent || 0);\n  switch (n.type) {\n    case \"document\": {\n      if (n.attributes.frontmatter && n.attributes.frontmatter.length) {\n        yield \"---\" + NL + n.attributes.frontmatter + NL + \"---\" + NL + NL;\n      }\n      yield* trimStart(formatChildren(n, no));\n      break;\n    }\n    case \"heading\": {\n      yield NL;\n      yield indent;\n      yield \"#\".repeat(n.attributes.level || 1);\n      yield SPACE;\n      yield* trimStart(formatChildren(n, no));\n      yield* formatAnnotations(n);\n      yield NL;\n      break;\n    }\n    case \"paragraph\": {\n      yield NL;\n      yield* formatChildren(n, no);\n      yield* formatAnnotations(n);\n      yield NL;\n      break;\n    }\n    case \"inline\": {\n      yield indent;\n      yield* formatChildren(n, no);\n      break;\n    }\n    case \"image\": {\n      yield \"!\";\n      yield \"[\";\n      yield* formatValue(n.attributes.alt, no);\n      yield \"]\";\n      yield \"(\";\n      yield* typeof n.attributes.src === \"string\" ? escapeMarkdownCharacters(n.attributes.src, /[()]/g) : formatValue(n.attributes.src, no);\n      if (n.attributes.title) {\n        yield SPACE + `\"${n.attributes.title}\"`;\n      }\n      yield \")\";\n      break;\n    }\n    case \"link\": {\n      const children = [...formatChildren(n, no)].join(\"\");\n      if (children === n.attributes.href && !n.attributes.title) {\n        yield `<${n.attributes.href}>`;\n        break;\n      }\n      yield \"[\";\n      yield children;\n      yield \"]\";\n      yield \"(\";\n      yield* typeof n.attributes.href === \"string\" ? escapeMarkdownCharacters(n.attributes.href, /[()]/g) : formatValue(n.attributes.href, no);\n      if (n.attributes.title) {\n        yield SPACE + `\"${n.attributes.title}\"`;\n      }\n      yield \")\";\n      break;\n    }\n    case \"text\": {\n      const { content } = n.attributes;\n      if (ast_default.isAst(content)) {\n        yield OPEN + SPACE;\n        yield* formatValue(content, no);\n        yield SPACE + CLOSE;\n      } else {\n        if (o.parent && WRAPPING_TYPES.includes(o.parent.type)) {\n          yield* escapeMarkdownCharacters(content, /[*_~]/g);\n        } else {\n          yield* escapeMarkdownCharacters(content, /^\\*|#+\\s|^>/);\n        }\n      }\n      break;\n    }\n    case \"blockquote\": {\n      const prefix = \">\" + SPACE;\n      yield n.children.map((child) => format(child, no).trimStart()).map((d) => NL + indent + prefix + d).join(indent + prefix);\n      break;\n    }\n    case \"hr\": {\n      yield NL;\n      yield indent;\n      yield \"---\";\n      yield NL;\n      break;\n    }\n    case \"fence\": {\n      yield NL;\n      yield indent;\n      const innerFence = n.attributes.content.match(/`{3,}/g) || [];\n      const innerFenceLength = innerFence.map((s2) => s2.length).reduce(max, 0);\n      const boundary = \"`\".repeat(innerFenceLength ? innerFenceLength + 1 : 3);\n      const needsNlBeforeEndBoundary = !n.attributes.content.endsWith(NL);\n      yield boundary;\n      if (n.attributes.language)\n        yield n.attributes.language;\n      if (n.annotations.length)\n        yield SPACE;\n      yield* formatAnnotations(n);\n      yield NL;\n      yield indent;\n      yield n.attributes.content.split(NL).join(NL + indent);\n      if (needsNlBeforeEndBoundary) {\n        yield NL;\n      }\n      yield boundary;\n      yield NL;\n      break;\n    }\n    case \"tag\": {\n      if (!n.inline) {\n        yield NL;\n        yield indent;\n      }\n      const open = OPEN + SPACE;\n      const attributes = [...formatAttributes(n)].filter((v) => v !== void 0);\n      const tag = [open + n.tag, ...attributes];\n      const inlineTag = tag.join(SPACE);\n      const isLongTagOpening = inlineTag.length + open.length * 2 > (o.maxTagOpeningWidth || MAX_TAG_OPENING_WIDTH);\n      yield (!n.inline && isLongTagOpening ? tag.join(NL + SPACE.repeat(open.length) + indent) : inlineTag) + SPACE + (n.children.length ? \"\" : \"/\") + CLOSE;\n      if (n.children.length) {\n        yield* formatChildren(n, no.allowIndentation ? increment(no) : no);\n        if (!n.inline) {\n          yield indent;\n        }\n        yield OPEN + SPACE + \"/\" + n.tag + SPACE + CLOSE;\n      }\n      if (!n.inline) {\n        yield NL;\n      }\n      break;\n    }\n    case \"list\": {\n      const isLoose = n.children.some((n2) => n2.children.some((c) => c.type === \"paragraph\"));\n      for (let i = 0; i < n.children.length; i++) {\n        const prefix = (() => {\n          if (!n.attributes.ordered)\n            return n.attributes.marker ?? UL;\n          let number = \"1\";\n          const startNumber = n.attributes.start ?? 1;\n          if (i === 0)\n            number = startNumber.toString();\n          if (o.orderedListMode === \"increment\") {\n            number = (parseInt(startNumber) + i).toString();\n          }\n          return `${number}${n.attributes.marker ?? OL}`;\n        })();\n        let d = format(n.children[i], increment(no, prefix.length + 1));\n        if (!isLoose || i === n.children.length - 1) {\n          d = d.trim();\n        }\n        yield NL + indent + prefix + \" \" + d;\n      }\n      yield NL;\n      break;\n    }\n    case \"item\": {\n      for (let i = 0; i < n.children.length; i++) {\n        yield* formatValue(n.children[i], no);\n        if (i === 0)\n          yield* formatAnnotations(n);\n      }\n      break;\n    }\n    case \"strong\": {\n      yield n.attributes.marker ?? \"**\";\n      yield* formatInline(formatChildren(n, no));\n      yield n.attributes.marker ?? \"**\";\n      break;\n    }\n    case \"em\": {\n      yield n.attributes.marker ?? \"*\";\n      yield* formatInline(formatChildren(n, no));\n      yield n.attributes.marker ?? \"*\";\n      break;\n    }\n    case \"code\": {\n      yield \"`\";\n      yield* formatInline(formatValue(n.attributes.content, no));\n      yield \"`\";\n      break;\n    }\n    case \"s\": {\n      yield \"~~\";\n      yield* formatInline(formatChildren(n, no));\n      yield \"~~\";\n      break;\n    }\n    case \"hardbreak\": {\n      yield \"\\\\\" + NL;\n      yield indent;\n      break;\n    }\n    case \"softbreak\": {\n      yield NL;\n      yield indent;\n      break;\n    }\n    case \"table\": {\n      const table3 = [...formatChildren(n, increment(no))];\n      if (o.parent && o.parent.type === \"tag\" && o.parent.tag === \"table\") {\n        for (let i = 0; i < table3.length; i++) {\n          const row = table3[i];\n          if (typeof row === \"string\") {\n            if (row.trim().length) {\n              yield NL;\n              yield row;\n            }\n          } else {\n            if (i !== 0) {\n              yield NL;\n              yield indent + \"---\";\n            }\n            for (const d of row) {\n              yield NL + indent + UL + \" \" + d;\n            }\n          }\n        }\n        yield NL;\n      } else {\n        const widths = [];\n        for (const row of table3) {\n          for (let i = 0; i < row.length; i++) {\n            widths[i] = widths[i] ? Math.max(widths[i], row[i].length) : row[i].length;\n          }\n        }\n        const [head, ...rows] = table3;\n        yield NL;\n        yield* formatTableRow(head.map((cell, i) => cell + SPACE.repeat(widths[i] - cell.length)));\n        yield NL;\n        yield* formatTableRow(head.map((cell, i) => \"-\".repeat(widths[i])));\n        yield NL;\n        for (const row of rows) {\n          yield* formatTableRow(row.map((cell, i) => cell + SPACE.repeat(widths[i] - cell.length)));\n          yield NL;\n        }\n      }\n      break;\n    }\n    case \"thead\": {\n      const [head] = [...formatChildren(n, no)];\n      yield head || [];\n      break;\n    }\n    case \"tr\": {\n      yield [...formatChildren(n, no)];\n      break;\n    }\n    case \"td\":\n    case \"th\": {\n      yield [...formatChildren(n, no), ...formatAnnotations(n)].join(\"\").trim();\n      break;\n    }\n    case \"tbody\": {\n      yield* formatChildren(n, no);\n      break;\n    }\n    case \"comment\": {\n      yield \"<!-- \" + n.attributes.content + \" -->\\n\";\n      break;\n    }\n    case \"error\":\n    case \"node\":\n      break;\n  }\n}\nfunction* formatValue(v, o = {}) {\n  switch (typeof v) {\n    case \"undefined\":\n      break;\n    case \"boolean\":\n    case \"number\":\n    case \"string\": {\n      yield v.toString();\n      break;\n    }\n    case \"object\": {\n      if (v === null)\n        break;\n      if (Array.isArray(v)) {\n        for (const n of v)\n          yield* formatValue(n, o);\n        break;\n      }\n      switch (v.$$mdtype) {\n        case \"Function\": {\n          yield* formatFunction(v);\n          break;\n        }\n        case \"Node\":\n          yield* formatNode(v, o);\n          break;\n        case \"Variable\": {\n          yield* formatVariable(v);\n          break;\n        }\n        default:\n          throw new Error(`Unimplemented: \"${v.$$mdtype}\"`);\n      }\n      break;\n    }\n  }\n}\nfunction format(v, options) {\n  let doc = \"\";\n  for (const s2 of formatValue(v, options))\n    doc += s2;\n  return doc.trimStart();\n}\n\n// src/schema-types/conditional.ts\nvar ConditionalAttributeType = class {\n  validate(value, _config, key) {\n    if (typeof value === \"boolean\" || value === null || value === void 0 || typeof value === \"object\") {\n      return [];\n    }\n    return [\n      {\n        id: \"attribute-type-invalid\",\n        level: \"error\",\n        message: `Attribute '${key}' must be type 'boolean | object' (null or undefined are also allowed)`\n      }\n    ];\n  }\n};\n\n// src/tags/conditional.ts\nfunction truthy(value) {\n  return value !== false && value !== void 0 && value !== null;\n}\nfunction renderConditions(node2) {\n  const conditions = [\n    { condition: node2.attributes.primary, children: [] }\n  ];\n  for (const child of node2.children) {\n    if (child.type === \"tag\" && child.tag === \"else\")\n      conditions.push({\n        condition: \"primary\" in child.attributes ? child.attributes.primary : true,\n        children: []\n      });\n    else\n      conditions[conditions.length - 1].children.push(child);\n  }\n  return conditions;\n}\nvar tagIf = {\n  attributes: {\n    primary: { type: ConditionalAttributeType, render: false }\n  },\n  transform(node2, config) {\n    const conditions = renderConditions(node2);\n    for (const { condition, children } of conditions)\n      if (truthy(condition)) {\n        const nodes = children.flatMap((child) => child.transform(config));\n        if (nodes.some(isPromise)) {\n          return Promise.all(nodes).then((nodes2) => nodes2.flat());\n        }\n        return nodes;\n      }\n    return [];\n  }\n};\nvar tagElse = {\n  selfClosing: true,\n  attributes: {\n    primary: { type: ConditionalAttributeType, render: false }\n  }\n};\n\n// src/functions/index.ts\nvar and = {\n  transform(parameters) {\n    return Object.values(parameters).every((x) => truthy(x));\n  }\n};\nvar or = {\n  transform(parameters) {\n    return Object.values(parameters).find((x) => truthy(x)) !== void 0;\n  }\n};\nvar not = {\n  parameters: {\n    0: { required: true }\n  },\n  transform(parameters) {\n    return !truthy(parameters[0]);\n  }\n};\nvar equals = {\n  transform(parameters) {\n    const values = Object.values(parameters);\n    return values.every((v) => v === values[0]);\n  }\n};\nvar debug = {\n  transform(parameters) {\n    return JSON.stringify(parameters[0], null, 2);\n  }\n};\nvar defaultFn = {\n  transform(parameters) {\n    return parameters[0] === void 0 ? parameters[1] : parameters[0];\n  }\n};\nvar functions_default = { and, or, not, equals, default: defaultFn, debug };\n\n// src/transforms/table.ts\nfunction convertToRow(node2, cellType = \"td\") {\n  node2.type = \"tr\";\n  node2.attributes = {};\n  for (const cell of node2.children)\n    cell.type = cellType;\n  return node2;\n}\nfunction transform(document2) {\n  for (const node2 of document2.walk()) {\n    if (node2.type !== \"tag\" || node2.tag !== \"table\")\n      continue;\n    const [first, ...rest] = node2.children;\n    if (!first || first.type === \"table\")\n      continue;\n    const table3 = new ast_default.Node(\"table\", node2.attributes, [\n      new ast_default.Node(\"thead\"),\n      new ast_default.Node(\"tbody\")\n    ]);\n    const [thead2, tbody2] = table3.children;\n    if (first.type === \"list\")\n      thead2.push(convertToRow(first, \"th\"));\n    for (const row of rest) {\n      if (row.type === \"list\")\n        convertToRow(row);\n      else if (row.type === \"tag\" && row.tag === \"if\") {\n        const children = [];\n        for (const child of row.children) {\n          if (child.type === \"hr\")\n            continue;\n          if (child.type === \"list\")\n            convertToRow(child);\n          children.push(child);\n        }\n        row.children = children;\n      } else\n        continue;\n      tbody2.push(row);\n    }\n    node2.children = [table3];\n  }\n}\n\n// src/transforms/index.ts\nvar transforms_default = [transform];\n\n// src/parser.ts\nvar mappings = {\n  ordered_list: \"list\",\n  bullet_list: \"list\",\n  code_inline: \"code\",\n  list_item: \"item\",\n  variable: \"text\"\n};\nfunction annotate(node2, attributes) {\n  for (const attribute of attributes) {\n    node2.annotations.push(attribute);\n    const { name, value, type } = attribute;\n    if (type === \"attribute\") {\n      if (node2.attributes[name] !== void 0)\n        node2.errors.push({\n          id: \"duplicate-attribute\",\n          level: \"warning\",\n          message: `Attribute '${name}' already set`\n        });\n      node2.attributes[name] = value;\n    } else if (type === \"class\")\n      if (node2.attributes.class)\n        node2.attributes.class[name] = value;\n      else\n        node2.attributes.class = { [name]: value };\n  }\n}\nfunction handleAttrs(token, type) {\n  switch (type) {\n    case \"heading\":\n      return { level: Number(token.tag.replace(\"h\", \"\")) };\n    case \"list\": {\n      const attrs = token.attrs ? Object.fromEntries(token.attrs) : void 0;\n      const ordered = token.type.startsWith(\"ordered\");\n      return ordered && attrs?.start ? { ordered: true, start: attrs.start, marker: token.markup } : { ordered, marker: token.markup };\n    }\n    case \"link\": {\n      const attrs = Object.fromEntries(token.attrs);\n      return attrs.title ? { href: attrs.href, title: attrs.title } : { href: attrs.href };\n    }\n    case \"image\": {\n      const attrs = Object.fromEntries(token.attrs);\n      return attrs.title ? { alt: token.content, src: attrs.src, title: attrs.title } : { alt: token.content, src: attrs.src };\n    }\n    case \"em\":\n    case \"strong\":\n      return { marker: token.markup };\n    case \"text\":\n    case \"code\":\n    case \"comment\":\n      return { content: (token.meta || {}).variable || token.content };\n    case \"fence\": {\n      const [language] = token.info.split(\" \", 1);\n      return language === \"\" || language === OPEN ? { content: token.content } : { content: token.content, language };\n    }\n    case \"td\":\n    case \"th\": {\n      if (token.attrs) {\n        const attrs = Object.fromEntries(token.attrs);\n        let align;\n        if (attrs.style) {\n          if (attrs.style.includes(\"left\")) {\n            align = \"left\";\n          } else if (attrs.style.includes(\"center\")) {\n            align = \"center\";\n          } else if (attrs.style.includes(\"right\")) {\n            align = \"right\";\n          }\n        }\n        if (align) {\n          return { align };\n        }\n      }\n      return {};\n    }\n    default:\n      return {};\n  }\n}\nfunction handleToken(token, nodes, file, handleSlots, addLocation, inlineParent) {\n  if (token.type === \"frontmatter\") {\n    nodes[0].attributes.frontmatter = token.content;\n    return;\n  }\n  if (token.hidden || token.type === \"text\" && token.content === \"\")\n    return;\n  const errors = token.errors || [];\n  const parent = nodes[nodes.length - 1];\n  const { tag, attributes, error: error2 } = token.meta || {};\n  if (token.type === \"annotation\") {\n    if (inlineParent)\n      return annotate(inlineParent, attributes);\n    return parent.errors.push({\n      id: \"no-inline-annotations\",\n      level: \"error\",\n      message: `Can't apply inline annotations to '${parent.type}'`\n    });\n  }\n  let typeName = token.type.replace(/_(open|close)$/, \"\");\n  if (mappings[typeName])\n    typeName = mappings[typeName];\n  if (typeName === \"error\") {\n    const { message, location } = error2;\n    errors.push({ id: \"parse-error\", level: \"critical\", message, location });\n  }\n  if (token.nesting < 0) {\n    if (parent.type === typeName && parent.tag === tag) {\n      if (parent.lines && token.map)\n        parent.lines.push(...token.map);\n      return nodes.pop();\n    }\n    errors.push({\n      id: \"missing-opening\",\n      level: \"critical\",\n      message: `Node '${typeName}' is missing opening`\n    });\n  }\n  const attrs = handleAttrs(token, typeName);\n  const node2 = new Node(typeName, attrs, void 0, tag || void 0);\n  const { position = {} } = token;\n  node2.errors = errors;\n  if (addLocation !== false) {\n    node2.lines = token.map || parent.lines || [];\n    node2.location = {\n      file,\n      start: {\n        line: node2.lines[0],\n        character: position.start\n      },\n      end: {\n        line: node2.lines[1],\n        character: position.end\n      }\n    };\n  }\n  if (inlineParent)\n    node2.inline = true;\n  if (attributes && [\"tag\", \"fence\", \"image\"].includes(typeName))\n    annotate(node2, attributes);\n  if (handleSlots && tag === \"slot\" && typeof node2.attributes.primary === \"string\")\n    parent.slots[node2.attributes.primary] = node2;\n  else\n    parent.push(node2);\n  if (token.nesting > 0)\n    nodes.push(node2);\n  if (!Array.isArray(token.children))\n    return;\n  if (node2.type === \"inline\")\n    inlineParent = parent;\n  nodes.push(node2);\n  const isLeafNode = typeName === \"image\";\n  if (!isLeafNode) {\n    for (const child of token.children)\n      handleToken(child, nodes, file, handleSlots, addLocation, inlineParent);\n  }\n  nodes.pop();\n}\nfunction parser(tokens, args) {\n  const doc = new Node(\"document\");\n  const nodes = [doc];\n  if (typeof args === \"string\")\n    args = { file: args };\n  for (const token of tokens)\n    handleToken(token, nodes, args?.file, args?.slots, args?.location);\n  if (nodes.length > 1)\n    for (const node2 of nodes.slice(1))\n      node2.errors.push({\n        id: \"missing-closing\",\n        level: \"critical\",\n        message: `Node '${node2.tag || node2.type}' is missing closing`\n      });\n  for (const transform3 of transforms_default)\n    transform3(doc);\n  return doc;\n}\n\n// src/schema.ts\nvar schema_exports = {};\n__export(schema_exports, {\n  blockquote: () => blockquote,\n  code: () => code,\n  comment: () => comment,\n  document: () => document,\n  em: () => em,\n  error: () => error,\n  fence: () => fence,\n  hardbreak: () => hardbreak,\n  heading: () => heading,\n  hr: () => hr,\n  image: () => image,\n  inline: () => inline,\n  item: () => item,\n  link: () => link,\n  list: () => list,\n  node: () => node,\n  paragraph: () => paragraph,\n  s: () => s,\n  softbreak: () => softbreak,\n  strong: () => strong,\n  table: () => table,\n  tbody: () => tbody,\n  td: () => td,\n  text: () => text,\n  th: () => th,\n  thead: () => thead,\n  tr: () => tr\n});\nvar document = {\n  render: \"article\",\n  children: [\n    \"heading\",\n    \"paragraph\",\n    \"image\",\n    \"table\",\n    \"tag\",\n    \"fence\",\n    \"blockquote\",\n    \"comment\",\n    \"list\",\n    \"hr\"\n  ],\n  attributes: {\n    frontmatter: { render: false }\n  }\n};\nvar heading = {\n  children: [\"inline\"],\n  attributes: {\n    level: { type: Number, render: false, required: true }\n  },\n  transform(node2, config) {\n    return new Tag(`h${node2.attributes[\"level\"]}`, node2.transformAttributes(config), node2.transformChildren(config));\n  }\n};\nvar paragraph = {\n  render: \"p\",\n  children: [\"inline\"]\n};\nvar image = {\n  render: \"img\",\n  attributes: {\n    src: { type: String, required: true },\n    alt: { type: String },\n    title: { type: String }\n  }\n};\nvar fence = {\n  render: \"pre\",\n  attributes: {\n    content: { type: String, render: false, required: true },\n    language: { type: String, render: \"data-language\" },\n    process: { type: Boolean, render: false, default: true }\n  },\n  transform(node2, config) {\n    const attributes = node2.transformAttributes(config);\n    const children = node2.children.length ? node2.transformChildren(config) : [node2.attributes.content];\n    return new Tag(\"pre\", attributes, children);\n  }\n};\nvar blockquote = {\n  render: \"blockquote\",\n  children: [\n    \"heading\",\n    \"paragraph\",\n    \"image\",\n    \"table\",\n    \"tag\",\n    \"fence\",\n    \"blockquote\",\n    \"list\",\n    \"hr\"\n  ]\n};\nvar item = {\n  render: \"li\",\n  children: [\n    \"inline\",\n    \"heading\",\n    \"paragraph\",\n    \"image\",\n    \"table\",\n    \"tag\",\n    \"fence\",\n    \"blockquote\",\n    \"list\",\n    \"hr\"\n  ]\n};\nvar list = {\n  children: [\"item\"],\n  attributes: {\n    ordered: { type: Boolean, render: false, required: true },\n    start: { type: Number },\n    marker: { type: String, render: false }\n  },\n  transform(node2, config) {\n    return new Tag(node2.attributes.ordered ? \"ol\" : \"ul\", node2.transformAttributes(config), node2.transformChildren(config));\n  }\n};\nvar hr = {\n  render: \"hr\"\n};\nvar table = {\n  render: \"table\"\n};\nvar td = {\n  render: \"td\",\n  children: [\n    \"inline\",\n    \"heading\",\n    \"paragraph\",\n    \"image\",\n    \"table\",\n    \"tag\",\n    \"fence\",\n    \"blockquote\",\n    \"list\",\n    \"hr\"\n  ],\n  attributes: {\n    align: { type: String },\n    colspan: { type: Number, render: \"colSpan\" },\n    rowspan: { type: Number, render: \"rowSpan\" }\n  }\n};\nvar th = {\n  render: \"th\",\n  attributes: {\n    width: { type: String },\n    align: { type: String },\n    colspan: { type: Number, render: \"colSpan\" },\n    rowspan: { type: Number, render: \"rowSpan\" }\n  }\n};\nvar tr = {\n  render: \"tr\",\n  children: [\"th\", \"td\"]\n};\nvar tbody = {\n  render: \"tbody\",\n  children: [\"tr\", \"tag\"]\n};\nvar thead = {\n  render: \"thead\",\n  children: [\"tr\"]\n};\nvar strong = {\n  render: \"strong\",\n  children: [\"em\", \"s\", \"link\", \"code\", \"text\", \"tag\"],\n  attributes: {\n    marker: { type: String, render: false }\n  }\n};\nvar em = {\n  render: \"em\",\n  children: [\"strong\", \"s\", \"link\", \"code\", \"text\", \"tag\"],\n  attributes: {\n    marker: { type: String, render: false }\n  }\n};\nvar s = {\n  render: \"s\",\n  children: [\"strong\", \"em\", \"link\", \"code\", \"text\", \"tag\"]\n};\nvar inline = {\n  children: [\n    \"strong\",\n    \"em\",\n    \"s\",\n    \"code\",\n    \"text\",\n    \"tag\",\n    \"link\",\n    \"image\",\n    \"hardbreak\",\n    \"softbreak\",\n    \"comment\"\n  ]\n};\nvar link = {\n  render: \"a\",\n  children: [\"strong\", \"em\", \"s\", \"code\", \"text\", \"tag\"],\n  attributes: {\n    href: { type: String, required: true },\n    title: { type: String }\n  }\n};\nvar code = {\n  render: \"code\",\n  attributes: {\n    content: { type: String, render: false, required: true }\n  },\n  transform(node2, config) {\n    const attributes = node2.transformAttributes(config);\n    return new Tag(\"code\", attributes, [node2.attributes.content]);\n  }\n};\nvar text = {\n  attributes: {\n    content: { type: String, required: true }\n  },\n  transform(node2) {\n    return node2.attributes.content;\n  }\n};\nvar hardbreak = {\n  render: \"br\"\n};\nvar softbreak = {\n  transform() {\n    return \" \";\n  }\n};\nvar comment = {\n  attributes: {\n    content: { type: String, required: true }\n  }\n};\nvar error = {};\nvar node = {};\n\n// src/renderers/html.ts\nvar import_markdown_it = __toModule(require_markdown_it());\nvar { escapeHtml } = (0, import_markdown_it.default)().utils;\nvar voidElements = new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\"\n]);\nfunction render(node2) {\n  if (typeof node2 === \"string\" || typeof node2 === \"number\")\n    return escapeHtml(String(node2));\n  if (Array.isArray(node2))\n    return node2.map(render).join(\"\");\n  if (node2 === null || typeof node2 !== \"object\" || !Tag.isTag(node2))\n    return \"\";\n  const { name, attributes, children = [] } = node2;\n  if (!name)\n    return render(children);\n  let output = `<${name}`;\n  for (const [k, v] of Object.entries(attributes ?? {}))\n    output += ` ${k.toLowerCase()}=\"${escapeHtml(String(v))}\"`;\n  output += \">\";\n  if (voidElements.has(name))\n    return output;\n  if (children.length)\n    output += render(children);\n  output += `</${name}>`;\n  return output;\n}\n\n// src/renderers/react/react.ts\nfunction tagName(name, components) {\n  return typeof name !== \"string\" ? name : name[0] !== name[0].toUpperCase() ? name : components instanceof Function ? components(name) : components[name];\n}\nfunction dynamic(node2, React, { components = {}, resolveTagName = tagName } = {}) {\n  function deepRender2(value) {\n    if (value == null || typeof value !== \"object\")\n      return value;\n    if (Array.isArray(value))\n      return value.map((item2) => deepRender2(item2));\n    if (value.$$mdtype === \"Tag\")\n      return render3(value);\n    if (typeof value !== \"object\")\n      return value;\n    const output = {};\n    for (const [k, v] of Object.entries(value))\n      output[k] = deepRender2(v);\n    return output;\n  }\n  function render3(node3) {\n    if (Array.isArray(node3))\n      return React.createElement(React.Fragment, null, ...node3.map(render3));\n    if (node3 === null || typeof node3 !== \"object\" || !Tag.isTag(node3))\n      return node3;\n    const {\n      name,\n      attributes: { class: className, ...attrs } = {},\n      children = []\n    } = node3;\n    if (className)\n      attrs.className = className;\n    return React.createElement(resolveTagName(name, components), Object.keys(attrs).length == 0 ? null : deepRender2(attrs), ...children.map(render3));\n  }\n  return render3(node2);\n}\n\n// src/renderers/react/static.ts\nfunction tagName2(name, components) {\n  return typeof name !== \"string\" ? \"Fragment\" : name[0] !== name[0].toUpperCase() ? name : components instanceof Function ? components(name) : components[name];\n}\nfunction renderArray(children) {\n  return children.map(render2).join(\", \");\n}\nfunction deepRender(value) {\n  if (value == null || typeof value !== \"object\")\n    return JSON.stringify(value);\n  if (Array.isArray(value))\n    return `[${value.map((item2) => deepRender(item2)).join(\", \")}]`;\n  if (value.$$mdtype === \"Tag\")\n    return render2(value);\n  if (typeof value !== \"object\")\n    return JSON.stringify(value);\n  const object = Object.entries(value).map(([k, v]) => [JSON.stringify(k), deepRender(v)].join(\": \")).join(\", \");\n  return `{${object}}`;\n}\nfunction render2(node2) {\n  if (Array.isArray(node2))\n    return `React.createElement(React.Fragment, null, ${renderArray(node2)})`;\n  if (node2 === null || typeof node2 !== \"object\" || !Tag.isTag(node2))\n    return JSON.stringify(node2);\n  const {\n    name,\n    attributes: { class: className, ...attrs } = {},\n    children = []\n  } = node2;\n  if (className)\n    attrs.className = className;\n  return `React.createElement(\n    tagName(${JSON.stringify(name)}, components),\n    ${Object.keys(attrs).length == 0 ? \"null\" : deepRender(attrs)},\n    ${renderArray(children)})`;\n}\nfunction reactStatic(node2, { resolveTagName = tagName2 } = {}) {\n  if (resolveTagName.name !== \"tagName\") {\n    throw new Error(\"resolveTagName must be named tagName\");\n  }\n  return `\n  (({components = {}} = {}) => {\n    ${resolveTagName}\n    return ${render2(node2)};\n  })\n`;\n}\n\n// src/renderers/index.ts\nvar renderers_default = { html: render, react: dynamic, reactStatic };\n\n// src/tags/partial.ts\nvar PartialFile = class {\n  validate(file, config) {\n    const { partials = {} } = config;\n    const partial2 = partials[file];\n    if (!partial2)\n      return [\n        {\n          id: \"attribute-value-invalid\",\n          level: \"error\",\n          message: `Partial \\`${file}\\` not found. The 'file' attribute must be set in \\`config.partials\\``\n        }\n      ];\n    return [];\n  }\n};\nvar partial = {\n  inline: false,\n  selfClosing: true,\n  attributes: {\n    file: { type: PartialFile, render: false, required: true },\n    variables: { type: Object, render: false }\n  },\n  transform(node2, config) {\n    const { partials = {} } = config;\n    const { file, variables } = node2.attributes;\n    const partial2 = partials[file];\n    if (!partial2)\n      return null;\n    const scopedConfig = {\n      ...config,\n      variables: {\n        ...config.variables,\n        ...variables,\n        [\"$$partial:filename\"]: file\n      }\n    };\n    const transformChildren = (part) => part.resolve(scopedConfig).transformChildren(scopedConfig);\n    return Array.isArray(partial2) ? partial2.flatMap(transformChildren) : transformChildren(partial2);\n  }\n};\n\n// src/tags/table.ts\nvar table2 = {\n  children: [\"table\"],\n  inline: false\n};\n\n// src/tags/slot.ts\nvar slot = {\n  attributes: {\n    primary: { type: String, required: true }\n  }\n};\n\n// src/tags/index.ts\nvar tags_default = {\n  else: tagElse,\n  if: tagIf,\n  partial,\n  slot,\n  table: table2\n};\n\n// src/tokenizer/index.ts\nvar import_lib = __toModule(require_lib());\n\n// src/tokenizer/plugins/annotations.ts\nvar import_tag7 = __toModule(require_tag());\nfunction createToken(state, content, contentStart) {\n  try {\n    const { type, meta, nesting = 0 } = (0, import_tag7.parse)(content, { Variable, Function: Function2 });\n    const token = state.push(type, \"\", nesting);\n    token.info = content;\n    token.meta = meta;\n    if (!state.delimiters) {\n      state.delimiters = [];\n    }\n    return token;\n  } catch (error2) {\n    if (!(error2 instanceof import_tag7.SyntaxError))\n      throw error2;\n    const {\n      message,\n      location: { start, end }\n    } = error2;\n    const location = contentStart ? {\n      start: { offset: start.offset + contentStart },\n      end: { offset: end.offset + contentStart }\n    } : null;\n    const token = state.push(\"error\", \"\", 0);\n    token.meta = { error: { message, location } };\n    return token;\n  }\n}\nfunction block(state, startLine, endLine, silent) {\n  const start = state.bMarks[startLine] + state.tShift[startLine];\n  const finish = state.eMarks[startLine];\n  if (!state.src.startsWith(OPEN, start))\n    return false;\n  const tagEnd = findTagEnd(state.src, start);\n  const lastPossible = state.src.slice(0, finish).trim().length;\n  if (!tagEnd || tagEnd < lastPossible - CLOSE.length)\n    return false;\n  const contentStart = start + OPEN.length;\n  const content = state.src.slice(contentStart, tagEnd).trim();\n  const lines = state.src.slice(start, tagEnd + CLOSE.length).split(\"\\n\").length;\n  if (content[0] === \"$\")\n    return false;\n  if (silent)\n    return true;\n  const token = createToken(state, content, contentStart);\n  token.map = [startLine, startLine + lines];\n  state.line += lines;\n  return true;\n}\nfunction inline2(state, silent) {\n  if (!state.src.startsWith(OPEN, state.pos))\n    return false;\n  const tagEnd = findTagEnd(state.src, state.pos);\n  if (!tagEnd)\n    return false;\n  const content = state.src.slice(state.pos + OPEN.length, tagEnd);\n  if (!silent)\n    createToken(state, content.trim());\n  state.pos = tagEnd + CLOSE.length;\n  return true;\n}\nfunction core(state) {\n  let token;\n  for (token of state.tokens) {\n    if (token.type !== \"fence\")\n      continue;\n    if (token.info.includes(OPEN)) {\n      const start = token.info.indexOf(OPEN);\n      const end = findTagEnd(token.info, start);\n      const content = token.info.slice(start + OPEN.length, end);\n      try {\n        const { meta } = (0, import_tag7.parse)(content.trim(), { Variable, Function: Function2 });\n        token.meta = meta;\n      } catch (error2) {\n        if (!(error2 instanceof import_tag7.SyntaxError))\n          throw error2;\n        if (!token.errors)\n          token.errors = [];\n        token.errors.push({\n          id: \"fence-tag-error\",\n          level: \"error\",\n          message: `Syntax error in fence tag: ${error2.message}`\n        });\n      }\n    }\n    if (token?.meta?.attributes?.find((attr) => attr.name === \"process\" && !attr.value))\n      continue;\n    token.children = parseTags(token.content, token.map[0]);\n  }\n}\nfunction plugin(md) {\n  md.block.ruler.before(\"paragraph\", \"annotations\", block, {\n    alt: [\"paragraph\", \"blockquote\"]\n  });\n  md.inline.ruler.push(\"containers\", inline2);\n  md.core.ruler.push(\"annotations\", core);\n}\n\n// src/tokenizer/plugins/frontmatter.ts\nvar fence2 = \"---\";\nfunction getLine(state, n) {\n  return state.src.slice(state.bMarks[n], state.eMarks[n]).trim();\n}\nfunction findClose(state, endLine) {\n  for (let line = 1; line < endLine; line++)\n    if (getLine(state, line) === fence2)\n      return line;\n}\nfunction block2(state, startLine, endLine, silent) {\n  if (startLine != 0 || getLine(state, 0) != fence2)\n    return false;\n  const close = findClose(state, endLine);\n  if (!close)\n    return false;\n  if (silent)\n    return true;\n  const token = state.push(\"frontmatter\", \"\", 0);\n  token.content = state.src.slice(state.eMarks[0], state.bMarks[close]).trim();\n  token.map = [0, close];\n  token.hidden = true;\n  state.line = close + 1;\n  return true;\n}\nfunction plugin2(md) {\n  md.block.ruler.before(\"hr\", \"frontmatter\", block2);\n}\n\n// src/tokenizer/plugins/comments.ts\nvar OPEN2 = \"<!--\";\nvar CLOSE2 = \"-->\";\nfunction block3(state, startLine, endLine, silent) {\n  const start = state.bMarks[startLine] + state.tShift[startLine];\n  if (!state.src.startsWith(OPEN2, start))\n    return false;\n  const close = state.src.indexOf(CLOSE2, start);\n  if (close === -1)\n    return false;\n  if (silent)\n    return true;\n  const content = state.src.slice(start + OPEN2.length, close);\n  const lines = content.split(\"\\n\").length;\n  const token = state.push(\"comment\", \"\", 0);\n  token.content = content.trim();\n  token.map = [startLine, startLine + lines];\n  state.line += lines;\n  return true;\n}\nfunction inline3(state, silent) {\n  if (!state.src.startsWith(OPEN2, state.pos))\n    return false;\n  const close = state.src.indexOf(CLOSE2, state.pos);\n  if (close === -1)\n    return false;\n  if (silent)\n    return true;\n  const content = state.src.slice(state.pos + OPEN2.length, close);\n  const token = state.push(\"comment\", \"\", 0);\n  token.content = content.trim();\n  state.pos = close + CLOSE2.length;\n  return true;\n}\nfunction plugin3(md) {\n  md.block.ruler.before(\"table\", \"comment\", block3, { alt: [\"paragraph\"] });\n  md.inline.ruler.push(\"comment\", inline3);\n}\n\n// src/tokenizer/index.ts\nvar Tokenizer = class {\n  constructor(config = {}) {\n    this.parser = new import_lib.default(config);\n    this.parser.use(plugin, \"annotations\", {});\n    this.parser.use(plugin2, \"frontmatter\", {});\n    this.parser.disable([\n      \"lheading\",\n      \"code\"\n    ]);\n    if (config.allowComments)\n      this.parser.use(plugin3, \"comments\", {});\n  }\n  tokenize(content) {\n    return this.parser.parse(content.toString(), {});\n  }\n};\n\n// src/validator.ts\nvar TypeMappings = {\n  String,\n  Number,\n  Array,\n  Object,\n  Boolean\n};\nfunction validateType(type, value, config, key) {\n  if (!type)\n    return true;\n  if (ast_default.isFunction(value) && config.validation?.validateFunctions) {\n    const schema = config.functions?.[value.name];\n    return !schema?.returns ? true : Array.isArray(schema.returns) ? schema.returns.find((t) => t === type) !== void 0 : schema.returns === type;\n  }\n  if (ast_default.isAst(value))\n    return true;\n  if (Array.isArray(type))\n    return type.some((t) => validateType(t, value, config, key));\n  if (typeof type === \"string\")\n    type = TypeMappings[type];\n  if (typeof type === \"function\") {\n    const instance = new type();\n    if (instance.validate) {\n      return instance.validate(value, config, key);\n    }\n  }\n  return value != null && value.constructor === type;\n}\nfunction typeToString(type) {\n  if (typeof type === \"string\")\n    return type;\n  if (Array.isArray(type))\n    return type.map(typeToString).join(\" | \");\n  return type.name;\n}\nfunction validateFunction(fn, config) {\n  const schema = config.functions?.[fn.name];\n  const errors = [];\n  if (!schema)\n    return [\n      {\n        id: \"function-undefined\",\n        level: \"critical\",\n        message: `Undefined function: '${fn.name}'`\n      }\n    ];\n  if (schema.validate)\n    errors.push(...schema.validate(fn, config));\n  if (schema.parameters) {\n    for (const [key, value] of Object.entries(fn.parameters)) {\n      const param = schema.parameters?.[key];\n      if (!param) {\n        errors.push({\n          id: \"parameter-undefined\",\n          level: \"error\",\n          message: `Invalid parameter: '${key}'`\n        });\n        continue;\n      }\n      if (ast_default.isAst(value) && !ast_default.isFunction(value))\n        continue;\n      if (param.type) {\n        const valid = validateType(param.type, value, config, key);\n        if (valid === false) {\n          errors.push({\n            id: \"parameter-type-invalid\",\n            level: \"error\",\n            message: `Parameter '${key}' of '${fn.name}' must be type of '${typeToString(param.type)}'`\n          });\n        } else if (Array.isArray(valid)) {\n          errors.push(...valid);\n        }\n      }\n    }\n  }\n  for (const [key, { required }] of Object.entries(schema.parameters ?? {}))\n    if (required && fn.parameters[key] === void 0)\n      errors.push({\n        id: \"parameter-missing-required\",\n        level: \"error\",\n        message: `Missing required parameter: '${key}'`\n      });\n  return errors;\n}\nfunction displayMatches(matches, n) {\n  if (matches.length <= n)\n    return JSON.stringify(matches);\n  const items = matches.slice(0, n).map((item2) => JSON.stringify(item2));\n  return `[${items.join(\",\")}, ... ${matches.length - n} more]`;\n}\nfunction validator(node2, config) {\n  const schema = node2.findSchema(config);\n  const errors = [...node2.errors || []];\n  if (!schema) {\n    errors.push({\n      id: node2.tag ? \"tag-undefined\" : \"node-undefined\",\n      level: \"critical\",\n      message: node2.tag ? `Undefined tag: '${node2.tag}'` : `Undefined node: '${node2.type}'`\n    });\n    return errors;\n  }\n  if (schema.inline != void 0 && node2.inline !== schema.inline)\n    errors.push({\n      id: \"tag-placement-invalid\",\n      level: \"critical\",\n      message: `'${node2.tag}' tag should be ${schema.inline ? \"inline\" : \"block\"}`\n    });\n  if (schema.selfClosing && node2.children.length > 0)\n    errors.push({\n      id: \"tag-selfclosing-has-children\",\n      level: \"critical\",\n      message: `'${node2.tag}' tag should be self-closing`\n    });\n  const attributes = {\n    ...globalAttributes,\n    ...schema.attributes\n  };\n  for (const key of Object.keys(node2.slots)) {\n    const slot2 = schema.slots?.[key];\n    if (!slot2)\n      errors.push({\n        id: \"slot-undefined\",\n        level: \"error\",\n        message: `Invalid slot: '${key}'`\n      });\n  }\n  for (let [key, value] of Object.entries(node2.attributes)) {\n    const attrib = attributes[key];\n    if (!attrib) {\n      errors.push({\n        id: \"attribute-undefined\",\n        level: \"error\",\n        message: `Invalid attribute: '${key}'`\n      });\n      continue;\n    }\n    let { type, matches, errorLevel } = attrib;\n    if (ast_default.isAst(value)) {\n      if (ast_default.isFunction(value) && config.validation?.validateFunctions)\n        errors.push(...validateFunction(value, config));\n      else if (ast_default.isVariable(value) && config.variables) {\n        let missing = false;\n        let variables = config.variables;\n        for (const key2 of value.path) {\n          if (!Object.prototype.hasOwnProperty.call(variables, key2)) {\n            missing = true;\n            break;\n          }\n          variables = variables[key2];\n        }\n        if (missing) {\n          errors.push({\n            id: \"variable-undefined\",\n            level: \"error\",\n            message: `Undefined variable: '${value.path.join(\".\")}'`\n          });\n        }\n      } else\n        continue;\n    }\n    value = value;\n    if (type) {\n      const valid = validateType(type, value, config, key);\n      if (valid === false) {\n        errors.push({\n          id: \"attribute-type-invalid\",\n          level: errorLevel || \"error\",\n          message: `Attribute '${key}' must be type of '${typeToString(type)}'`\n        });\n      }\n      if (Array.isArray(valid)) {\n        errors.push(...valid);\n      }\n    }\n    if (typeof matches === \"function\")\n      matches = matches(config);\n    if (Array.isArray(matches) && !matches.includes(value))\n      errors.push({\n        id: \"attribute-value-invalid\",\n        level: errorLevel || \"error\",\n        message: `Attribute '${key}' must match one of ${displayMatches(matches, 8)}. Got '${value}' instead.`\n      });\n    if (matches instanceof RegExp && !matches.test(value))\n      errors.push({\n        id: \"attribute-value-invalid\",\n        level: errorLevel || \"error\",\n        message: `Attribute '${key}' must match ${matches}. Got '${value}' instead.`\n      });\n    if (typeof attrib.validate === \"function\") {\n      const attribErrors = attrib.validate(value, config, key);\n      if (Array.isArray(attribErrors))\n        errors.push(...attribErrors);\n    }\n  }\n  for (const [key, { required }] of Object.entries(attributes))\n    if (required && node2.attributes[key] === void 0)\n      errors.push({\n        id: \"attribute-missing-required\",\n        level: \"error\",\n        message: `Missing required attribute: '${key}'`\n      });\n  if (schema.slots) {\n    for (const [key, { required }] of Object.entries(schema.slots))\n      if (required && node2.slots[key] === void 0)\n        errors.push({\n          id: \"slot-missing-required\",\n          level: \"error\",\n          message: `Missing required slot: '${key}'`\n        });\n  }\n  for (const { type } of node2.children) {\n    if (schema.children && type !== \"error\" && !schema.children.includes(type))\n      errors.push({\n        id: \"child-invalid\",\n        level: \"warning\",\n        message: `Can't nest '${type}' in '${node2.tag || node2.type}'`\n      });\n  }\n  if (schema.validate) {\n    const schemaErrors = schema.validate(node2, config);\n    if (isPromise(schemaErrors)) {\n      return schemaErrors.then((e) => errors.concat(e));\n    }\n    errors.push(...schemaErrors);\n  }\n  return errors;\n}\nfunction* walkWithParents(node2, parents = []) {\n  yield [node2, parents];\n  for (const child of [...Object.values(node2.slots), ...node2.children])\n    yield* walkWithParents(child, [...parents, node2]);\n}\nfunction validateTree(content, config) {\n  const output = [...walkWithParents(content)].map(([node2, parents]) => {\n    const { type, lines, location } = node2;\n    const updatedConfig = {\n      ...config,\n      validation: { ...config.validation, parents }\n    };\n    const errors = validator(node2, updatedConfig);\n    if (isPromise(errors)) {\n      return errors.then((e) => e.map((error2) => ({ type, lines, location, error: error2 })));\n    }\n    return errors.map((error2) => ({ type, lines, location, error: error2 }));\n  });\n  if (output.some(isPromise)) {\n    return Promise.all(output).then((o) => o.flat());\n  }\n  return output.flat();\n}\n\n// index.ts\nvar tokenizer = new Tokenizer();\nfunction mergeConfig(config = {}) {\n  return {\n    ...config,\n    tags: {\n      ...tags_default,\n      ...config.tags\n    },\n    nodes: {\n      ...schema_exports,\n      ...config.nodes\n    },\n    functions: {\n      ...functions_default,\n      ...config.functions\n    }\n  };\n}\nfunction parse3(content, args) {\n  if (typeof content === \"string\")\n    content = tokenizer.tokenize(content);\n  return parser(content, args);\n}\nfunction resolve2(content, config) {\n  if (Array.isArray(content))\n    return content.flatMap((child) => child.resolve(config));\n  return content.resolve(config);\n}\nfunction transform2(nodes, options) {\n  const config = mergeConfig(options);\n  const content = resolve2(nodes, config);\n  if (Array.isArray(content))\n    return content.flatMap((child) => child.transform(config));\n  return content.transform(config);\n}\nfunction validate(content, options) {\n  const config = mergeConfig(options);\n  return validateTree(content, config);\n}\nfunction createElement(name, attributes = {}, ...children) {\n  return { name, attributes, children };\n}\nvar Markdoc = class {\n  constructor(config) {\n    this.parse = parse3;\n    this.resolve = (content) => resolve2(content, this.config);\n    this.transform = (content) => transform2(content, this.config);\n    this.validate = (content) => validate(content, this.config);\n    this.config = config;\n  }\n};\nMarkdoc.nodes = schema_exports;\nMarkdoc.tags = tags_default;\nMarkdoc.functions = functions_default;\nMarkdoc.globalAttributes = globalAttributes;\nMarkdoc.renderers = renderers_default;\nMarkdoc.transforms = transforms_default;\nMarkdoc.Ast = ast_default;\nMarkdoc.Tag = Tag;\nMarkdoc.Tokenizer = Tokenizer;\nMarkdoc.parseTags = parseTags;\nMarkdoc.transformer = transformer_default;\nMarkdoc.validator = validator;\nMarkdoc.parse = parse3;\nMarkdoc.transform = transform2;\nMarkdoc.validate = validate;\nMarkdoc.createElement = createElement;\nMarkdoc.truthy = truthy;\nMarkdoc.format = format;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWFya2RvYy9tYXJrZG9jL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0EscURBQXFELGFBQWE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0dBQWdHO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLG9FQUFvRSw4Q0FBOEMsSUFBSSxpQ0FBaUM7QUFDeFA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlCQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBLGlCQUFpQix3Q0FBd0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNQQUFzUCxNQUFNLFlBQVksTUFBTSw4b0JBQThvQixNQUFNLGFBQWEsTUFBTSxtTUFBbU0sTUFBTSxhQUFhLE1BQU0sK3FCQUErcUIsTUFBTSxZQUFZLE1BQU0scW1CQUFxbUIsTUFBTSxhQUFhLE1BQU0scTNCQUFxM0IsTUFBTSxxekJBQXF6QixNQUFNLDA3QkFBMDdCLE1BQU0sZ05BQWdOLE1BQU0sYUFBYSxNQUFNLGdsQ0FBZ2xDLE1BQU0sWUFBWSxNQUFNLHlnQkFBeWdCLE1BQU0sYUFBYSxNQUFNLCtsQ0FBK2xDLE1BQU0sYUFBYSxNQUFNLCtnQkFBK2dCLE1BQU0sWUFBWSxNQUFNLDBkQUEwZCxNQUFNLGFBQWEsTUFBTSx3MEJBQXcwQixNQUFNLFlBQVksTUFBTSwyS0FBMkssTUFBTSxhQUFhLE1BQU0sc2FBQXNhLE1BQU0sdWdCQUF1Z0IsTUFBTSxZQUFZLE1BQU0sd1JBQXdSLE1BQU0sYUFBYSxNQUFNLCtNQUErTSxNQUFNLGlyQkFBaXJCLE1BQU0sa0xBQWtMLE1BQU0seUVBQXlFLE1BQU0sMlZBQTJWLE1BQU0sOHVCQUE4dUIsTUFBTSxhQUFhLE1BQU0sOEVBQThFLE1BQU0sb1RBQW9ULE1BQU0sWUFBWSxNQUFNLDhCQUE4QixNQUFNLGFBQWEsTUFBTSxhQUFhLE1BQU0sYUFBYSxNQUFNLHdNQUF3TSxNQUFNLFlBQVksTUFBTSwrRkFBK0YsTUFBTSxhQUFhLE1BQU0sYUFBYSxNQUFNLGFBQWEsTUFBTSxpbEJBQWlsQix3S0FBd0ssNGtEQUE0a0QsTUFBTSxZQUFZLE1BQU0seTFCQUF5MUIsTUFBTSxhQUFhLE1BQU0sK1VBQStVLE1BQU0sKzBCQUErMEIsTUFBTSxZQUFZLE1BQU0sMFFBQTBRLE1BQU0sYUFBYSxNQUFNLDJCQUEyQixNQUFNLGkrQkFBaStCLE1BQU0sWUFBWSxNQUFNLHkyQkFBeTJCLE1BQU0sNm1FQUE2bUUsTUFBTSxhQUFhLE1BQU0sbzRDQUFvNEMsTUFBTSxZQUFZLE1BQU0sNlZBQTZWLE1BQU0sYUFBYSxNQUFNLHVVQUF1VSxNQUFNLGdoQkFBZ2hCLE1BQU0sWUFBWSxNQUFNLCtjQUErYyxNQUFNLHFzQkFBcXNCLE1BQU0sYUFBYSxNQUFNLDREQUE0RCxNQUFNLFlBQVksTUFBTSw2QkFBNkIsTUFBTSwrQ0FBK0MsTUFBTSxhQUFhLE1BQU0sb3RCQUFvdEIsd0tBQXdLLDRYQUE0WCxNQUFNLGlyQ0FBaXJDLE1BQU0scU1BQXFNLE1BQU0sZ3dCQUFnd0IsbUZBQW1GLE1BQU0sWUFBWSxNQUFNLG95QkFBb3lCLE1BQU0sYUFBYSxNQUFNLHlrQkFBeWtCLE1BQU0sYUFBYSxNQUFNLG9yREFBb3JELE1BQU0sWUFBWSxNQUFNLGtrQkFBa2tCLE1BQU0sYUFBYSxNQUFNLGlhQUFpYSxNQUFNLGFBQWEsTUFBTSwwZkFBMGYsTUFBTSxZQUFZLE1BQU0seVlBQXlZLE1BQU0sYUFBYSxNQUFNLDhrQkFBOGtCLE1BQU0sYUFBYSxNQUFNLGsrQkFBaytCLE1BQU0sWUFBWSxNQUFNLDRFQUE0RSxNQUFNLGFBQWEsTUFBTSwrQ0FBK0MsTUFBTSxhQUFhLE1BQU0sMlFBQTJRLE1BQU0sWUFBWSxNQUFNLGFBQWEsTUFBTSxhQUFhLE1BQU0sMkRBQTJELE1BQU0sYUFBYSxNQUFNLDhFQUE4RSxNQUFNLFlBQVksTUFBTSw4SkFBOEosTUFBTSxhQUFhLE1BQU0sbUZBQW1GLE1BQU0sYUFBYSxNQUFNLGdQQUFnUCxNQUFNLFlBQVksTUFBTSw2Q0FBNkMsTUFBTSxhQUFhLE1BQU0sYUFBYSxNQUFNLGFBQWEsTUFBTSw0UkFBNFIsTUFBTSwrRUFBK0UsTUFBTSw2QkFBNkIsTUFBTSxhQUFhLE1BQU07QUFDeGl1QztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVyxFQUFFO0FBQ2pEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsRUFBRTtBQUMxQztBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGNBQWMsRUFBRTtBQUNqRSxzQ0FBc0MsS0FBSyxFQUFFO0FBQzdDO0FBQ0Esa0RBQWtELElBQUksT0FBTyxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsR0FBRywwREFBMEQsR0FBRyx5QkFBeUIsR0FBRztBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvQkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0RBQWdEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0RBQWdEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsV0FBVztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLHNEQUFzRCxtQ0FBbUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXLEVBQUU7QUFDckM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRSxnQ0FBZ0MsS0FBSyw2Q0FBNkMsS0FBSztBQUMxSSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJLE9BQU8sSUFBSSxHQUFHO0FBQ3pELHFDQUFxQyxLQUFLLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SDtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsRUFBRTtBQUNwRTtBQUNBLHlDQUF5QyxFQUFFLGNBQWMsRUFBRSxrQ0FBa0MsSUFBSTtBQUNqRztBQUNBLHVGQUF1RixVQUFVLHFGQUFxRiwyQkFBMkIsUUFBUSw0SEFBNEgsR0FBRyw4SUFBOEk7QUFDdGUsZ0NBQWdDLDZCQUE2QjtBQUM3RCxtQ0FBbUMsS0FBSztBQUN4Qyw4RUFBOEUsS0FBSztBQUNuRiwrSUFBK0ksS0FBSztBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELElBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVksSUFBSTtBQUM1Qiw0RkFBNEY7QUFDNUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QixhQUFhO0FBQ2IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQkFBK0I7QUFDM0UsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLE1BQU07QUFDTjtBQUNBLGVBQWUsOENBQThDO0FBQzdELGFBQWE7QUFDYjtBQUNBLGFBQWEsdUJBQXVCLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLFFBQVE7QUFDUjtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsY0FBYyxJQUFJO0FBQ2xEO0FBQ0EsR0FBRztBQUNILCtCQUErQjtBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtDQUErQyw4QkFBOEIsSUFBSSxHQUFHLElBQUksb0JBQW9CLGlCQUFpQjtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyxHQUFHLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0QkFBNEI7QUFDbEU7QUFDQTtBQUNBLG9DQUFvQyxxQ0FBcUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixFQUFFO0FBQ25CLGdCQUFnQixFQUFFO0FBQ2xCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQSw4QkFBOEI7QUFDOUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEdBQUc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxFQUFFLDBCQUEwQjtBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QyxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBEQUEwRCxJQUFJO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1Q0FBdUMsSUFBSTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseURBQXlELElBQUk7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQSxzREFBc0QseUJBQXlCLElBQUk7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsWUFBWTtBQUNqRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDLGtCQUFrQix5REFBeUQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekMsV0FBVyxjQUFjO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBNkM7QUFDNUQsZ0JBQWdCLHVDQUF1QztBQUN2RCxlQUFlO0FBQ2YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhDQUE4QztBQUM3RCxhQUFhLGNBQWM7QUFDM0IsY0FBYztBQUNkLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixlQUFlLGlDQUFpQztBQUNoRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLGNBQWM7QUFDM0IsZUFBZSxpQ0FBaUM7QUFDaEQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBLG1CQUFtQixLQUFLO0FBQ3hCLHNEQUFzRDtBQUN0RCxrQkFBa0IsZ0JBQWdCLElBQUksc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWUsNkJBQTZCLElBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QixJQUFJO0FBQ3JEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBbUQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkJBQTZCLElBQUk7QUFDbkQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkMsTUFBTSw0REFBNEQ7QUFDbEUsTUFBTSxzQkFBc0I7QUFDNUI7QUFDQSw4QkFBOEIsNEJBQTRCLElBQUk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlCQUFpQixJQUFJO0FBQzFCLE1BQU07QUFDTixhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0RBQWtEO0FBQzlELGlCQUFpQjtBQUNqQixHQUFHO0FBQ0g7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQixvQ0FBb0MsK0JBQStCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLE1BQU07QUFDTjtBQUNBLGVBQWUscUNBQXFDO0FBQ3BELGFBQWE7QUFDYixNQUFNO0FBQ047QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPLDJDQUEyQywrQkFBK0I7QUFDakc7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZUFBZTtBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0JBQW9CO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDZDQUE2QztBQUM3Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSSxRQUFRLFFBQVEscUJBQXFCLHlCQUF5QjtBQUNyRyxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVSwyQ0FBMkM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0IsUUFBUSxvQkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVLHlCQUF5QixXQUFXO0FBQzVGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVSxrQkFBa0IsbUNBQW1DO0FBQ2xGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEUsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJLHFCQUFxQixtQkFBbUI7QUFDN0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSSxzQkFBc0IsMkJBQTJCLFNBQVMsTUFBTTtBQUNuRyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSSxlQUFlLFFBQVEsU0FBUyxNQUFNO0FBQ3pFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JELE9BQU87QUFDUDtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQsU0FBUztBQUNUO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEtBQUssUUFBUSx3QkFBd0I7QUFDckUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxzQ0FBc0M7QUFDM0Y7QUFDQSxxQ0FBcUMsc0NBQXNDO0FBQzNFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVCRSIsInNvdXJjZXMiOlsiL1VzZXJzL21heGx1bmQvcHJvamVjdHMvZmxvemUvZG9jcy9ub2RlX21vZHVsZXMvQG1hcmtkb2MvbWFya2RvYy9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW09iamVjdC5rZXlzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZSA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlKTtcbn07XG5cbi8vIHNyYy9ncmFtbWFyL3RhZy5qc1xudmFyIHJlcXVpcmVfdGFnID0gX19jb21tb25KUyh7XG4gIFwic3JjL2dyYW1tYXIvdGFnLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgICAgIGZ1bmN0aW9uIEMoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICAgIH1cbiAgICAgIEMucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBDKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZyRTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIGxvY2F0aW9uKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgICAgdGhpcy5mb3VuZCA9IGZvdW5kO1xuICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgdGhpcy5uYW1lID0gXCJTeW50YXhFcnJvclwiO1xuICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHBlZyRTeW50YXhFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHBlZyRzdWJjbGFzcyhwZWckU3ludGF4RXJyb3IsIEVycm9yKTtcbiAgICBwZWckU3ludGF4RXJyb3IuYnVpbGRNZXNzYWdlID0gZnVuY3Rpb24oZXhwZWN0ZWQsIGZvdW5kLCBsb2NhdGlvbikge1xuICAgICAgdmFyIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOUyA9IHtcbiAgICAgICAgbGl0ZXJhbDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gJ1wiJyArIGxpdGVyYWxFc2NhcGUoZXhwZWN0YXRpb24udGV4dCkgKyAnXCInO1xuICAgICAgICB9LFxuICAgICAgICBjbGFzczogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICB2YXIgZXNjYXBlZFBhcnRzID0gZXhwZWN0YXRpb24ucGFydHMubWFwKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBhcnQpID8gY2xhc3NFc2NhcGUocGFydFswXSkgKyBcIi1cIiArIGNsYXNzRXNjYXBlKHBhcnRbMV0pIDogY2xhc3NFc2NhcGUocGFydCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIFwiW1wiICsgKGV4cGVjdGF0aW9uLmludmVydGVkID8gXCJeXCIgOiBcIlwiKSArIGVzY2FwZWRQYXJ0cyArIFwiXVwiO1xuICAgICAgICB9LFxuICAgICAgICBhbnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBcImFueSBjaGFyYWN0ZXJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgICAgfSxcbiAgICAgICAgb3RoZXI6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uLmRlc2NyaXB0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBub3Q6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIFwibm90IFwiICsgZGVzY3JpYmVFeHBlY3RhdGlvbihleHBlY3RhdGlvbi5leHBlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBoZXgoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaXRlcmFsRXNjYXBlKHMyKSB7XG4gICAgICAgIHJldHVybiBzMi5yZXBsYWNlKC9cXFxcL2csIFwiXFxcXFxcXFxcIikucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcMC9nLCBcIlxcXFwwXCIpLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpLnJlcGxhY2UoL1tcXHgwMC1cXHgwRl0vZywgZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgICByZXR1cm4gXCJcXFxceDBcIiArIGhleChjaCk7XG4gICAgICAgIH0pLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgICAgIHJldHVybiBcIlxcXFx4XCIgKyBoZXgoY2gpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNsYXNzRXNjYXBlKHMyKSB7XG4gICAgICAgIHJldHVybiBzMi5yZXBsYWNlKC9cXFxcL2csIFwiXFxcXFxcXFxcIikucmVwbGFjZSgvXFxdL2csIFwiXFxcXF1cIikucmVwbGFjZSgvXFxeL2csIFwiXFxcXF5cIikucmVwbGFjZSgvLS9nLCBcIlxcXFwtXCIpLnJlcGxhY2UoL1xcMC9nLCBcIlxcXFwwXCIpLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpLnJlcGxhY2UoL1tcXHgwMC1cXHgwRl0vZywgZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgICByZXR1cm4gXCJcXFxceDBcIiArIGhleChjaCk7XG4gICAgICAgIH0pLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgICAgIHJldHVybiBcIlxcXFx4XCIgKyBoZXgoY2gpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGRlc2NyaWJlRXhwZWN0YXRpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOU1tleHBlY3RhdGlvbi50eXBlXShleHBlY3RhdGlvbik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGVkKGV4cGVjdGVkMikge1xuICAgICAgICB2YXIgZGVzY3JpcHRpb25zID0gZXhwZWN0ZWQyLm1hcChkZXNjcmliZUV4cGVjdGF0aW9uKTtcbiAgICAgICAgdmFyIGksIGo7XG4gICAgICAgIGRlc2NyaXB0aW9ucy5zb3J0KCk7XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDEsIGogPSAxOyBpIDwgZGVzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRpb25zW2kgLSAxXSAhPT0gZGVzY3JpcHRpb25zW2ldKSB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uc1tqXSA9IGRlc2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkZXNjcmlwdGlvbnMubGVuZ3RoID0gajtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zWzBdO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF0gKyBcIiBvciBcIiArIGRlc2NyaXB0aW9uc1sxXTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9ucy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpICsgXCIsIG9yIFwiICsgZGVzY3JpcHRpb25zW2Rlc2NyaXB0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVzY3JpYmVGb3VuZChmb3VuZDIpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kMiA/ICdcIicgKyBsaXRlcmFsRXNjYXBlKGZvdW5kMikgKyAnXCInIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkgKyBcIiBidXQgXCIgKyBkZXNjcmliZUZvdW5kKGZvdW5kKSArIFwiIGZvdW5kLlwiO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuICAgICAgdmFyIHBlZyRGQUlMRUQgPSB7fTtcbiAgICAgIHZhciBwZWckc3RhcnRSdWxlRnVuY3Rpb25zID0geyBUb3A6IHBlZyRwYXJzZVRvcCB9O1xuICAgICAgdmFyIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRwYXJzZVRvcDtcbiAgICAgIHZhciBwZWckYzAgPSBcIi9cIjtcbiAgICAgIHZhciBwZWckYzEgPSBcIi5cIjtcbiAgICAgIHZhciBwZWckYzIgPSBcIiNcIjtcbiAgICAgIHZhciBwZWckYzMgPSBcIj1cIjtcbiAgICAgIHZhciBwZWckYzQgPSBcIihcIjtcbiAgICAgIHZhciBwZWckYzUgPSBcIilcIjtcbiAgICAgIHZhciBwZWckYzYgPSBcIixcIjtcbiAgICAgIHZhciBwZWckYzcgPSBcIltcIjtcbiAgICAgIHZhciBwZWckYzggPSBcIl1cIjtcbiAgICAgIHZhciBwZWckYzkgPSBcIm51bGxcIjtcbiAgICAgIHZhciBwZWckYzEwID0gXCJ0cnVlXCI7XG4gICAgICB2YXIgcGVnJGMxMSA9IFwiZmFsc2VcIjtcbiAgICAgIHZhciBwZWckYzEyID0gXCJ7XCI7XG4gICAgICB2YXIgcGVnJGMxMyA9IFwifVwiO1xuICAgICAgdmFyIHBlZyRjMTQgPSBcIjpcIjtcbiAgICAgIHZhciBwZWckYzE1ID0gXCItXCI7XG4gICAgICB2YXIgcGVnJGMxNiA9ICdcIic7XG4gICAgICB2YXIgcGVnJGMxNyA9IFwiXFxcXFwiO1xuICAgICAgdmFyIHBlZyRjMTggPSBcIm5cIjtcbiAgICAgIHZhciBwZWckYzE5ID0gXCJyXCI7XG4gICAgICB2YXIgcGVnJGMyMCA9IFwidFwiO1xuICAgICAgdmFyIHBlZyRyMCA9IC9eWyRAXS87XG4gICAgICB2YXIgcGVnJHIxID0gL15bMC05XS87XG4gICAgICB2YXIgcGVnJHIyID0gL15bXlxcMC1cXHgxRlwiXFxcXF0vO1xuICAgICAgdmFyIHBlZyRyMyA9IC9eW2EtekEtWjAtOV9cXC1dLztcbiAgICAgIHZhciBwZWckcjQgPSAvXlsgXFxuXFx0XS87XG4gICAgICB2YXIgcGVnJGUwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi9cIiwgZmFsc2UpO1xuICAgICAgdmFyIHBlZyRlMSA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwidGFnIG5hbWVcIik7XG4gICAgICB2YXIgcGVnJGUyID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJjbGFzc1wiKTtcbiAgICAgIHZhciBwZWckZTMgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcImlkXCIpO1xuICAgICAgdmFyIHBlZyRlNCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI9XCIsIGZhbHNlKTtcbiAgICAgIHZhciBwZWckZTUgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKFwiLCBmYWxzZSk7XG4gICAgICB2YXIgcGVnJGU2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIilcIiwgZmFsc2UpO1xuICAgICAgdmFyIHBlZyRlNyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIsXCIsIGZhbHNlKTtcbiAgICAgIHZhciBwZWckZTggPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcInZhcmlhYmxlXCIpO1xuICAgICAgdmFyIHBlZyRlOSA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwibnVsbFwiKTtcbiAgICAgIHZhciBwZWckZTEwID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJib29sZWFuXCIpO1xuICAgICAgdmFyIHBlZyRlMTEgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiW1wiLCBmYWxzZSk7XG4gICAgICB2YXIgcGVnJGUxMiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJdXCIsIGZhbHNlKTtcbiAgICAgIHZhciBwZWckZTEzID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIntcIiwgZmFsc2UpO1xuICAgICAgdmFyIHBlZyRlMTQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwifVwiLCBmYWxzZSk7XG4gICAgICB2YXIgcGVnJGUxNSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI6XCIsIGZhbHNlKTtcbiAgICAgIHZhciBwZWckZTE2ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJudW1iZXJcIik7XG4gICAgICB2YXIgcGVnJGUxNyA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwic3RyaW5nXCIpO1xuICAgICAgdmFyIHBlZyRlMTggPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcImlkZW50aWZpZXJcIik7XG4gICAgICB2YXIgcGVnJGUxOSA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwid2hpdGVzcGFjZVwiKTtcbiAgICAgIHZhciBwZWckZjAgPSBmdW5jdGlvbih2YXJpYWJsZSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInZhcmlhYmxlXCIsIG1ldGE6IHsgdmFyaWFibGUgfSB9O1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjEgPSBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiYW5ub3RhdGlvblwiLCBtZXRhOiB7IGF0dHJpYnV0ZXMgfSB9O1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjIgPSBmdW5jdGlvbih0YWcsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGYzID0gZnVuY3Rpb24odGFnLCBwcmltYXJ5LCBhdHRyaWJ1dGVzLCBjbG9zZSkge1xuICAgICAgICBpZiAocHJpbWFyeSkge1xuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IFtdO1xuICAgICAgICAgIGF0dHJpYnV0ZXMudW5zaGlmdCh7XG4gICAgICAgICAgICB0eXBlOiBcImF0dHJpYnV0ZVwiLFxuICAgICAgICAgICAgbmFtZTogXCJwcmltYXJ5XCIsXG4gICAgICAgICAgICB2YWx1ZTogcHJpbWFyeVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt0eXBlLCBuZXN0aW5nXSA9IGNsb3NlID8gW1widGFnXCIsIDBdIDogW1widGFnX29wZW5cIiwgMV07XG4gICAgICAgIHJldHVybiB7IHR5cGUsIG5lc3RpbmcsIG1ldGE6IHsgdGFnLCBhdHRyaWJ1dGVzIH0gfTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGY0ID0gZnVuY3Rpb24odGFnKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidGFnX2Nsb3NlXCIsIG5lc3Rpbmc6IC0xLCBtZXRhOiB7IHRhZyB9IH07XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmNSA9IGZ1bmN0aW9uKGhlYWQsIHRhaWwpIHtcbiAgICAgICAgcmV0dXJuICFoZWFkID8gW10gOiBbaGVhZCwgLi4udGFpbF07XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmNiA9IGZ1bmN0aW9uKGl0ZW0yKSB7XG4gICAgICAgIHJldHVybiBpdGVtMjtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGY3ID0gZnVuY3Rpb24oaWRzKSB7XG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmOCA9IGZ1bmN0aW9uKGNsYXNzZXMpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmOSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjEwID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImNsYXNzXCIsIG5hbWUsIHZhbHVlOiB0cnVlIH07XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMTEgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImF0dHJpYnV0ZVwiLCBuYW1lOiBcImlkXCIsIHZhbHVlIH07XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMTIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImF0dHJpYnV0ZVwiLCBuYW1lLCB2YWx1ZSB9O1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjEzID0gZnVuY3Rpb24obmFtZSwgaGVhZCwgdGFpbCkge1xuICAgICAgICByZXR1cm4gaGVhZCA/IFtoZWFkLCAuLi50YWlsXSA6IFtdO1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjE0ID0gZnVuY3Rpb24obmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIGxldCBwYXJhbWV0ZXJzID0ge307XG4gICAgICAgIGZvciAobGV0IFtpbmRleCwgeyBuYW1lOiBuYW1lMiwgdmFsdWUgfV0gb2YgcGFyYW1zLmVudHJpZXMoKSlcbiAgICAgICAgICBwYXJhbWV0ZXJzW25hbWUyIHx8IGluZGV4XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uMyhuYW1lLCBwYXJhbWV0ZXJzKTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGYxNSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMTYgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBuYW1lLCB2YWx1ZSB9O1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjE3ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjE4ID0gZnVuY3Rpb24ocHJlZml4LCBoZWFkLCB0YWlsKSB7XG4gICAgICAgIGlmIChwcmVmaXggPT09IFwiQFwiKVxuICAgICAgICAgIHJldHVybiBbaGVhZCwgLi4udGFpbF07XG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFibGUyKFtoZWFkLCAuLi50YWlsXSk7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMTkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMjAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMjEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjIyID0gZnVuY3Rpb24oaGVhZCwgdGFpbCkge1xuICAgICAgICByZXR1cm4gW2hlYWQsIC4uLnRhaWxdO1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjIzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IFtdO1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjI0ID0gZnVuY3Rpb24oaGVhZCwgdGFpbCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihoZWFkLCAuLi50YWlsKTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGYyNSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSB8fCB7fTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGYyNiA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtleSA9PT0gXCIkJG1kdHlwZVwiID8ge30gOiB7IFtrZXldOiB2YWx1ZSB9O1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjI3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRleHQyKCkpO1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjI4ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmpvaW4oXCJcIik7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMjkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuXCI7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMzAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxyXCI7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMzEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiXHRcIjtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGYzMiA9IGZ1bmN0aW9uKHNlcXVlbmNlKSB7XG4gICAgICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGN1cnJQb3MgPSAwO1xuICAgICAgdmFyIHBlZyRzYXZlZFBvcyA9IDA7XG4gICAgICB2YXIgcGVnJHBvc0RldGFpbHNDYWNoZSA9IFt7IGxpbmU6IDEsIGNvbHVtbjogMSB9XTtcbiAgICAgIHZhciBwZWckZXhwZWN0ZWQgPSBbXTtcbiAgICAgIHZhciBwZWckc2lsZW50RmFpbHMgPSAwO1xuICAgICAgdmFyIHBlZyRyZXN1bHQ7XG4gICAgICBpZiAoXCJzdGFydFJ1bGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcImAgKyBvcHRpb25zLnN0YXJ0UnVsZSArICdcIi4nKTtcbiAgICAgICAgfVxuICAgICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckc3RhcnRSdWxlRnVuY3Rpb25zW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHRleHQyKCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gcGVnJHNhdmVkUG9zO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBbcGVnJHNhdmVkUG9zLCBwZWckY3VyclBvc107XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbiwgbG9jYXRpb24yKSB7XG4gICAgICAgIGxvY2F0aW9uMiA9IGxvY2F0aW9uMiAhPT0gdm9pZCAwID8gbG9jYXRpb24yIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgICAgICAgdGhyb3cgcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKFtwZWckb3RoZXJFeHBlY3RhdGlvbihkZXNjcmlwdGlvbildLCBpbnB1dC5zdWJzdHJpbmcocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyksIGxvY2F0aW9uMik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlcnJvcjIobWVzc2FnZSwgbG9jYXRpb24yKSB7XG4gICAgICAgIGxvY2F0aW9uMiA9IGxvY2F0aW9uMiAhPT0gdm9pZCAwID8gbG9jYXRpb24yIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgICAgICAgdGhyb3cgcGVnJGJ1aWxkU2ltcGxlRXJyb3IobWVzc2FnZSwgbG9jYXRpb24yKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24odGV4dDMsIGlnbm9yZUNhc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsaXRlcmFsXCIsIHRleHQ6IHRleHQzLCBpZ25vcmVDYXNlIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckY2xhc3NFeHBlY3RhdGlvbihwYXJ0cywgaW52ZXJ0ZWQsIGlnbm9yZUNhc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImNsYXNzXCIsXG4gICAgICAgICAgcGFydHMsXG4gICAgICAgICAgaW52ZXJ0ZWQsXG4gICAgICAgICAgaWdub3JlQ2FzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJGFueUV4cGVjdGF0aW9uKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImFueVwiIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckZW5kRXhwZWN0YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZW5kXCIgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRvdGhlckV4cGVjdGF0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb24gfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHtcbiAgICAgICAgdmFyIGRldGFpbHMgPSBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc107XG4gICAgICAgIHZhciBwO1xuICAgICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAgPSBwb3MgLSAxO1xuICAgICAgICAgIHdoaWxlICghcGVnJHBvc0RldGFpbHNDYWNoZVtwXSkge1xuICAgICAgICAgICAgcC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwXTtcbiAgICAgICAgICBkZXRhaWxzID0ge1xuICAgICAgICAgICAgbGluZTogZGV0YWlscy5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBkZXRhaWxzLmNvbHVtblxuICAgICAgICAgIH07XG4gICAgICAgICAgd2hpbGUgKHAgPCBwb3MpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHApID09PSAxMCkge1xuICAgICAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHArKztcbiAgICAgICAgICB9XG4gICAgICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdID0gZGV0YWlscztcbiAgICAgICAgICByZXR1cm4gZGV0YWlscztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHBlZyRWQUxJREZJTEVOQU1FID0gdHlwZW9mIG9wdGlvbnMuZmlsZW5hbWUgPT09IFwic3RyaW5nXCIgJiYgb3B0aW9ucy5maWxlbmFtZS5sZW5ndGggPiAwO1xuICAgICAgZnVuY3Rpb24gcGVnJGNvbXB1dGVMb2NhdGlvbihzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgICAgIHZhciBsb2MgPSB7fTtcbiAgICAgICAgaWYgKHBlZyRWQUxJREZJTEVOQU1FKVxuICAgICAgICAgIGxvYy5maWxlbmFtZSA9IG9wdGlvbnMuZmlsZW5hbWU7XG4gICAgICAgIHZhciBzdGFydFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoc3RhcnRQb3MpO1xuICAgICAgICBsb2Muc3RhcnQgPSB7XG4gICAgICAgICAgb2Zmc2V0OiBzdGFydFBvcyxcbiAgICAgICAgICBsaW5lOiBzdGFydFBvc0RldGFpbHMubGluZSxcbiAgICAgICAgICBjb2x1bW46IHN0YXJ0UG9zRGV0YWlscy5jb2x1bW5cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVuZFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoZW5kUG9zKTtcbiAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICBvZmZzZXQ6IGVuZFBvcyxcbiAgICAgICAgICBsaW5lOiBlbmRQb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBlbmRQb3NEZXRhaWxzLmNvbHVtblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbG9jO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJGJlZ2luKCkge1xuICAgICAgICBwZWckZXhwZWN0ZWQucHVzaCh7IHBvczogcGVnJGN1cnJQb3MsIHZhcmlhbnRzOiBbXSB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRleHBlY3QoZXhwZWN0ZWQyKSB7XG4gICAgICAgIHZhciB0b3AgPSBwZWckZXhwZWN0ZWRbcGVnJGV4cGVjdGVkLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAocGVnJGN1cnJQb3MgPCB0b3AucG9zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZWckY3VyclBvcyA+IHRvcC5wb3MpIHtcbiAgICAgICAgICB0b3AucG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgdG9wLnZhcmlhbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdG9wLnZhcmlhbnRzLnB1c2goZXhwZWN0ZWQyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRlbmQoaW52ZXJ0KSB7XG4gICAgICAgIHZhciBleHBlY3RlZDIgPSBwZWckZXhwZWN0ZWQucG9wKCk7XG4gICAgICAgIHZhciB0b3AgPSBwZWckZXhwZWN0ZWRbcGVnJGV4cGVjdGVkLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgdmFyaWFudHMgPSBleHBlY3RlZDIudmFyaWFudHM7XG4gICAgICAgIGlmICh0b3AucG9zICE9PSBleHBlY3RlZDIucG9zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICB2YXJpYW50cyA9IHZhcmlhbnRzLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS50eXBlID09PSBcIm5vdFwiID8gZS5leHBlY3RlZCA6IHsgdHlwZTogXCJub3RcIiwgZXhwZWN0ZWQ6IGUgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0b3AudmFyaWFudHMsIHZhcmlhbnRzKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRidWlsZFNpbXBsZUVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uMikge1xuICAgICAgICByZXR1cm4gbmV3IHBlZyRTeW50YXhFcnJvcihtZXNzYWdlLCBudWxsLCBudWxsLCBsb2NhdGlvbjIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKGV4cGVjdGVkMiwgZm91bmQsIGxvY2F0aW9uMikge1xuICAgICAgICByZXR1cm4gbmV3IHBlZyRTeW50YXhFcnJvcihwZWckU3ludGF4RXJyb3IuYnVpbGRNZXNzYWdlKGV4cGVjdGVkMiwgZm91bmQsIGxvY2F0aW9uMiksIGV4cGVjdGVkMiwgZm91bmQsIGxvY2F0aW9uMik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckYnVpbGRFcnJvcigpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkMiA9IHBlZyRleHBlY3RlZFswXTtcbiAgICAgICAgdmFyIGZhaWxQb3MgPSBleHBlY3RlZDIucG9zO1xuICAgICAgICByZXR1cm4gcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKGV4cGVjdGVkMi52YXJpYW50cywgZmFpbFBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChmYWlsUG9zKSA6IG51bGwsIGZhaWxQb3MgPCBpbnB1dC5sZW5ndGggPyBwZWckY29tcHV0ZUxvY2F0aW9uKGZhaWxQb3MsIGZhaWxQb3MgKyAxKSA6IHBlZyRjb21wdXRlTG9jYXRpb24oZmFpbFBvcywgZmFpbFBvcykpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVG9wKCkge1xuICAgICAgICB2YXIgczA7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBzMCA9IHBlZyRwYXJzZVRvcExldmVsVmFsdWUoKTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckcGFyc2VBbm5vdGF0aW9uKCk7XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRwYXJzZVRhZ09wZW4oKTtcbiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZVRhZ0Nsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVRvcExldmVsVmFsdWUoKSB7XG4gICAgICAgIHZhciBzMCwgczE7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IHBlZyRwYXJzZVZhcmlhYmxlKCk7XG4gICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxID0gcGVnJHBhcnNlRnVuY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRmMChzMSk7XG4gICAgICAgIH1cbiAgICAgICAgczAgPSBzMTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlQW5ub3RhdGlvbigpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VUYWdBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gW107XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRmMShzMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVGFnT3BlbigpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2O1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VUYWdOYW1lKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gW107XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlVmFsdWUoKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgaWYgKHM1ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM1ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckZjIoczEsIHM0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlVGFnQXR0cmlidXRlcygpO1xuICAgICAgICAgIGlmIChzNCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzNSA9IFtdO1xuICAgICAgICAgIHM2ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIHdoaWxlIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUucHVzaChzNik7XG4gICAgICAgICAgICBzNiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMCk7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nykge1xuICAgICAgICAgICAgczYgPSBwZWckYzA7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczYgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRmMyhzMSwgczMsIHM0LCBzNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVGFnQ2xvc2UoKSB7XG4gICAgICAgIHZhciBzMCwgczEsIHMyO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMCk7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDcpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMDtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZVRhZ05hbWUoKTtcbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckZjQoczIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VUYWdOYW1lKCkge1xuICAgICAgICB2YXIgczA7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUxKTtcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgIHMwID0gcGVnJHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVGFnQXR0cmlidXRlcygpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VUYWdBdHRyaWJ1dGVzSXRlbSgpO1xuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IFtdO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlVGFnQXR0cmlidXRlc1RhaWwoKTtcbiAgICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgICAgczMgPSBwZWckcGFyc2VUYWdBdHRyaWJ1dGVzVGFpbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRmNShzMSwgczIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVRhZ0F0dHJpYnV0ZXNUYWlsKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMjtcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gW107XG4gICAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZVRhZ0F0dHJpYnV0ZXNJdGVtKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGY2KHMyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVGFnQXR0cmlidXRlc0l0ZW0oKSB7XG4gICAgICAgIHZhciBzMCwgczE7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IHBlZyRwYXJzZVRhZ1Nob3J0Y3V0SWQoKTtcbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckZjcoczEpO1xuICAgICAgICB9XG4gICAgICAgIHMwID0gczE7XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VUYWdTaG9ydGN1dENsYXNzKCk7XG4gICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGY4KHMxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICBzMSA9IHBlZyRwYXJzZVRhZ0F0dHJpYnV0ZSgpO1xuICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRmOShzMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VUYWdTaG9ydGN1dENsYXNzKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMjtcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTIpO1xuICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nikge1xuICAgICAgICAgIHMxID0gcGVnJGMxO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRmMTAoczIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVGFnU2hvcnRjdXRJZCgpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczI7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUzKTtcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzUpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMjtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckZjExKHMyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVRhZ0F0dHJpYnV0ZSgpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTQpO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjEpIHtcbiAgICAgICAgICAgIHMyID0gcGVnJGMzO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckZjEyKHMxLCBzMyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZUZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3O1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTUpO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDApIHtcbiAgICAgICAgICAgIHMyID0gcGVnJGM0O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzID0gW107XG4gICAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzNCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2VGdW5jdGlvblBhcmFtZXRlcigpO1xuICAgICAgICAgICAgaWYgKHM1ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM1ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHM2ID0gW107XG4gICAgICAgICAgICBzNyA9IHBlZyRwYXJzZUZ1bmN0aW9uUGFyYW1ldGVyVGFpbCgpO1xuICAgICAgICAgICAgd2hpbGUgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM2LnB1c2goczcpO1xuICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZUZ1bmN0aW9uUGFyYW1ldGVyVGFpbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczQ7XG4gICAgICAgICAgICBzNCA9IHBlZyRmMTMoczEsIHM1LCBzNik7XG4gICAgICAgICAgICBydWxlJGV4cGVjdHMocGVnJGU2KTtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckYzU7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGYxNChzMSwgczQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VGdW5jdGlvblBhcmFtZXRlcigpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckY3VyclBvcztcbiAgICAgICAgczIgPSBwZWckcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTQpO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjEpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJGMzO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMxO1xuICAgICAgICAgICAgczEgPSBwZWckZjE1KHMyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHMyID0gcGVnJHBhcnNlVmFsdWUoKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckZjE2KHMxLCBzMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlRnVuY3Rpb25QYXJhbWV0ZXJUYWlsKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBbXTtcbiAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTcpO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgczIgPSBwZWckYzY7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBbXTtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICB3aGlsZSAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlRnVuY3Rpb25QYXJhbWV0ZXIoKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckZjE3KHM0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVHJhaWxpbmdDb21tYSgpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczI7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IFtdO1xuICAgICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIH1cbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlNyk7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjNjtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMSA9IFtzMSwgczJdO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVZhcmlhYmxlKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlOCk7XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAocGVnJHIwLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMyA9IFtdO1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VWYXJpYWJsZVRhaWwoKTtcbiAgICAgICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgICAgICAgczQgPSBwZWckcGFyc2VWYXJpYWJsZVRhaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckZjE4KHMxLCBzMiwgczMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVmFyaWFibGVUYWlsKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ2KSB7XG4gICAgICAgICAgczEgPSBwZWckYzE7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGYxNShzMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgICAgICAgczEgPSBwZWckYzc7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIgPSBwZWckcGFyc2VWYWx1ZU51bWJlcigpO1xuICAgICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlVmFsdWVTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkzKSB7XG4gICAgICAgICAgICAgICAgczMgPSBwZWckYzg7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckZjE3KHMyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VWYWx1ZSgpIHtcbiAgICAgICAgdmFyIHMwO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckcGFyc2VWYWx1ZU51bGwoKTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckcGFyc2VWYWx1ZUJvb2xlYW4oKTtcbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlVmFsdWVTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZVZhbHVlTnVtYmVyKCk7XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlVmFsdWVBcnJheSgpO1xuICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckcGFyc2VWYWx1ZUhhc2goKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZUZ1bmN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlVmFyaWFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VWYWx1ZU51bGwoKSB7XG4gICAgICAgIHZhciBzMCwgczE7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGU5KTtcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDQpID09PSBwZWckYzkpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjOTtcbiAgICAgICAgICBwZWckY3VyclBvcyArPSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRmMTkoKTtcbiAgICAgICAgfVxuICAgICAgICBzMCA9IHMxO1xuICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVmFsdWVCb29sZWFuKCkge1xuICAgICAgICB2YXIgczAsIHMxO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMTApO1xuICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjMTApIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMTA7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckZjIwKCk7XG4gICAgICAgIH1cbiAgICAgICAgczAgPSBzMTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGMxMSkge1xuICAgICAgICAgICAgczEgPSBwZWckYzExO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckZjIxKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH1cbiAgICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVZhbHVlQXJyYXkoKSB7XG4gICAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNjtcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTExKTtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgICAgIHMxID0gcGVnJGM3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gW107XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlVmFsdWUoKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgICBzNiA9IHBlZyRwYXJzZVZhbHVlQXJyYXlUYWlsKCk7XG4gICAgICAgICAgICB3aGlsZSAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczUucHVzaChzNik7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlVmFsdWVBcnJheVRhaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlVHJhaWxpbmdDb21tYSgpO1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRmMjIoczQsIHM1KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHM0ID0gW107XG4gICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUxMik7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mykge1xuICAgICAgICAgICAgczUgPSBwZWckYzg7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRmMjMoczMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VWYWx1ZUFycmF5VGFpbCgpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNDtcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gW107XG4gICAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgfVxuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGU3KTtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgIHMyID0gcGVnJGM2O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gW107XG4gICAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZVZhbHVlKCk7XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGYxNyhzNCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVZhbHVlSGFzaCgpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2O1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMTMpO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyMykge1xuICAgICAgICAgIHMxID0gcGVnJGMxMjtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IFtdO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZVZhbHVlSGFzaEl0ZW0oKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgICBzNiA9IHBlZyRwYXJzZVZhbHVlSGFzaFRhaWwoKTtcbiAgICAgICAgICAgIHdoaWxlIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNS5wdXNoKHM2KTtcbiAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VWYWx1ZUhhc2hUYWlsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzNiA9IHBlZyRwYXJzZVRyYWlsaW5nQ29tbWEoKTtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckZjI0KHM0LCBzNSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMyA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQucHVzaChzNSk7XG4gICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMTQpO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTI1KSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRjMTM7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRmMjUoczMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VWYWx1ZUhhc2hUYWlsKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBbXTtcbiAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTcpO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgczIgPSBwZWckYzY7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBbXTtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICB3aGlsZSAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlVmFsdWVIYXNoSXRlbSgpO1xuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRmNihzNCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVZhbHVlSGFzaEl0ZW0oKSB7XG4gICAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IHBlZyRwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VWYWx1ZVN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTE1KTtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRjMTQ7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMgPSBbXTtcbiAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckZjI2KHMxLCBzNCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVZhbHVlTnVtYmVyKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczY7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUxNik7XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ1KSB7XG4gICAgICAgICAgczEgPSBwZWckYzE1O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzMiA9IFtdO1xuICAgICAgICBpZiAocGVnJHIxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICAgIGlmIChwZWckcjEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJGMxO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgICBpZiAocGVnJHIxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgICAgczYgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM1LnB1c2goczYpO1xuICAgICAgICAgICAgICAgIGlmIChwZWckcjEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICAgICAgczYgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0ID0gW3M0LCBzNV07XG4gICAgICAgICAgICAgIHMzID0gczQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMyA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRmMjcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVmFsdWVTdHJpbmcoKSB7XG4gICAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTE3KTtcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMTY7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBbXTtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZVZhbHVlU3RyaW5nQ2hhcnMoKTtcbiAgICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgICAgczMgPSBwZWckcGFyc2VWYWx1ZVN0cmluZ0NoYXJzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJGMxNjtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGYyOChzMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VWYWx1ZVN0cmluZ0NoYXJzKCkge1xuICAgICAgICB2YXIgczA7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocGVnJHIyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckcGFyc2VWYWx1ZVN0cmluZ0VzY2FwZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VWYWx1ZVN0cmluZ0VzY2FwZXMoKSB7XG4gICAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTIpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMTc7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNCkge1xuICAgICAgICAgICAgczIgPSBwZWckYzE2O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTIpIHtcbiAgICAgICAgICAgICAgczIgPSBwZWckYzE3O1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMyID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTEwKSB7XG4gICAgICAgICAgICAgICAgczMgPSBwZWckYzE4O1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMyO1xuICAgICAgICAgICAgICAgIHMzID0gcGVnJGYyOSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHMyID0gczM7XG4gICAgICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMyID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMTQpIHtcbiAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGMxOTtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMjtcbiAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGYzMCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzMiA9IHMzO1xuICAgICAgICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTE2KSB7XG4gICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGMyMDtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMjtcbiAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckZjMxKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzMiA9IHMzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckZjMyKHMyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczI7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUxOCk7XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IFtdO1xuICAgICAgICBpZiAocGVnJHIzLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgICAgIGlmIChwZWckcjMudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IGlucHV0LnN1YnN0cmluZyhzMCwgcGVnJGN1cnJQb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH1cbiAgICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZV8oKSB7XG4gICAgICAgIHZhciBzMDtcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTE5KTtcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgIGlmIChwZWckcjQudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBWYXJpYWJsZTogVmFyaWFibGUyLCBGdW5jdGlvbjogRnVuY3Rpb24zIH0gPSBvcHRpb25zO1xuICAgICAgcGVnJGJlZ2luKCk7XG4gICAgICBwZWckcmVzdWx0ID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uKCk7XG4gICAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwZWckcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICBwZWckZXhwZWN0KHBlZyRlbmRFeHBlY3RhdGlvbigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBwZWckYnVpbGRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgIFN5bnRheEVycm9yOiBwZWckU3ludGF4RXJyb3IsXG4gICAgICBwYXJzZTogcGVnJHBhcnNlXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvbWFwcy9lbnRpdGllcy5qc29uXG52YXIgcmVxdWlyZV9lbnRpdGllcyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvbWFwcy9lbnRpdGllcy5qc29uXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7IEFhY3V0ZTogXCJcXHhDMVwiLCBhYWN1dGU6IFwiXFx4RTFcIiwgQWJyZXZlOiBcIlxcdTAxMDJcIiwgYWJyZXZlOiBcIlxcdTAxMDNcIiwgYWM6IFwiXFx1MjIzRVwiLCBhY2Q6IFwiXFx1MjIzRlwiLCBhY0U6IFwiXFx1MjIzRVxcdTAzMzNcIiwgQWNpcmM6IFwiXFx4QzJcIiwgYWNpcmM6IFwiXFx4RTJcIiwgYWN1dGU6IFwiXFx4QjRcIiwgQWN5OiBcIlxcdTA0MTBcIiwgYWN5OiBcIlxcdTA0MzBcIiwgQUVsaWc6IFwiXFx4QzZcIiwgYWVsaWc6IFwiXFx4RTZcIiwgYWY6IFwiXFx1MjA2MVwiLCBBZnI6IFwiXFx1ezFENTA0fVwiLCBhZnI6IFwiXFx1ezFENTFFfVwiLCBBZ3JhdmU6IFwiXFx4QzBcIiwgYWdyYXZlOiBcIlxceEUwXCIsIGFsZWZzeW06IFwiXFx1MjEzNVwiLCBhbGVwaDogXCJcXHUyMTM1XCIsIEFscGhhOiBcIlxcdTAzOTFcIiwgYWxwaGE6IFwiXFx1MDNCMVwiLCBBbWFjcjogXCJcXHUwMTAwXCIsIGFtYWNyOiBcIlxcdTAxMDFcIiwgYW1hbGc6IFwiXFx1MkEzRlwiLCBhbXA6IFwiJlwiLCBBTVA6IFwiJlwiLCBhbmRhbmQ6IFwiXFx1MkE1NVwiLCBBbmQ6IFwiXFx1MkE1M1wiLCBhbmQ6IFwiXFx1MjIyN1wiLCBhbmRkOiBcIlxcdTJBNUNcIiwgYW5kc2xvcGU6IFwiXFx1MkE1OFwiLCBhbmR2OiBcIlxcdTJBNUFcIiwgYW5nOiBcIlxcdTIyMjBcIiwgYW5nZTogXCJcXHUyOUE0XCIsIGFuZ2xlOiBcIlxcdTIyMjBcIiwgYW5nbXNkYWE6IFwiXFx1MjlBOFwiLCBhbmdtc2RhYjogXCJcXHUyOUE5XCIsIGFuZ21zZGFjOiBcIlxcdTI5QUFcIiwgYW5nbXNkYWQ6IFwiXFx1MjlBQlwiLCBhbmdtc2RhZTogXCJcXHUyOUFDXCIsIGFuZ21zZGFmOiBcIlxcdTI5QURcIiwgYW5nbXNkYWc6IFwiXFx1MjlBRVwiLCBhbmdtc2RhaDogXCJcXHUyOUFGXCIsIGFuZ21zZDogXCJcXHUyMjIxXCIsIGFuZ3J0OiBcIlxcdTIyMUZcIiwgYW5ncnR2YjogXCJcXHUyMkJFXCIsIGFuZ3J0dmJkOiBcIlxcdTI5OURcIiwgYW5nc3BoOiBcIlxcdTIyMjJcIiwgYW5nc3Q6IFwiXFx4QzVcIiwgYW5nemFycjogXCJcXHUyMzdDXCIsIEFvZ29uOiBcIlxcdTAxMDRcIiwgYW9nb246IFwiXFx1MDEwNVwiLCBBb3BmOiBcIlxcdXsxRDUzOH1cIiwgYW9wZjogXCJcXHV7MUQ1NTJ9XCIsIGFwYWNpcjogXCJcXHUyQTZGXCIsIGFwOiBcIlxcdTIyNDhcIiwgYXBFOiBcIlxcdTJBNzBcIiwgYXBlOiBcIlxcdTIyNEFcIiwgYXBpZDogXCJcXHUyMjRCXCIsIGFwb3M6IFwiJ1wiLCBBcHBseUZ1bmN0aW9uOiBcIlxcdTIwNjFcIiwgYXBwcm94OiBcIlxcdTIyNDhcIiwgYXBwcm94ZXE6IFwiXFx1MjI0QVwiLCBBcmluZzogXCJcXHhDNVwiLCBhcmluZzogXCJcXHhFNVwiLCBBc2NyOiBcIlxcdXsxRDQ5Q31cIiwgYXNjcjogXCJcXHV7MUQ0QjZ9XCIsIEFzc2lnbjogXCJcXHUyMjU0XCIsIGFzdDogXCIqXCIsIGFzeW1wOiBcIlxcdTIyNDhcIiwgYXN5bXBlcTogXCJcXHUyMjREXCIsIEF0aWxkZTogXCJcXHhDM1wiLCBhdGlsZGU6IFwiXFx4RTNcIiwgQXVtbDogXCJcXHhDNFwiLCBhdW1sOiBcIlxceEU0XCIsIGF3Y29uaW50OiBcIlxcdTIyMzNcIiwgYXdpbnQ6IFwiXFx1MkExMVwiLCBiYWNrY29uZzogXCJcXHUyMjRDXCIsIGJhY2tlcHNpbG9uOiBcIlxcdTAzRjZcIiwgYmFja3ByaW1lOiBcIlxcdTIwMzVcIiwgYmFja3NpbTogXCJcXHUyMjNEXCIsIGJhY2tzaW1lcTogXCJcXHUyMkNEXCIsIEJhY2tzbGFzaDogXCJcXHUyMjE2XCIsIEJhcnY6IFwiXFx1MkFFN1wiLCBiYXJ2ZWU6IFwiXFx1MjJCRFwiLCBiYXJ3ZWQ6IFwiXFx1MjMwNVwiLCBCYXJ3ZWQ6IFwiXFx1MjMwNlwiLCBiYXJ3ZWRnZTogXCJcXHUyMzA1XCIsIGJicms6IFwiXFx1MjNCNVwiLCBiYnJrdGJyazogXCJcXHUyM0I2XCIsIGJjb25nOiBcIlxcdTIyNENcIiwgQmN5OiBcIlxcdTA0MTFcIiwgYmN5OiBcIlxcdTA0MzFcIiwgYmRxdW86IFwiXFx1MjAxRVwiLCBiZWNhdXM6IFwiXFx1MjIzNVwiLCBiZWNhdXNlOiBcIlxcdTIyMzVcIiwgQmVjYXVzZTogXCJcXHUyMjM1XCIsIGJlbXB0eXY6IFwiXFx1MjlCMFwiLCBiZXBzaTogXCJcXHUwM0Y2XCIsIGJlcm5vdTogXCJcXHUyMTJDXCIsIEJlcm5vdWxsaXM6IFwiXFx1MjEyQ1wiLCBCZXRhOiBcIlxcdTAzOTJcIiwgYmV0YTogXCJcXHUwM0IyXCIsIGJldGg6IFwiXFx1MjEzNlwiLCBiZXR3ZWVuOiBcIlxcdTIyNkNcIiwgQmZyOiBcIlxcdXsxRDUwNX1cIiwgYmZyOiBcIlxcdXsxRDUxRn1cIiwgYmlnY2FwOiBcIlxcdTIyQzJcIiwgYmlnY2lyYzogXCJcXHUyNUVGXCIsIGJpZ2N1cDogXCJcXHUyMkMzXCIsIGJpZ29kb3Q6IFwiXFx1MkEwMFwiLCBiaWdvcGx1czogXCJcXHUyQTAxXCIsIGJpZ290aW1lczogXCJcXHUyQTAyXCIsIGJpZ3NxY3VwOiBcIlxcdTJBMDZcIiwgYmlnc3RhcjogXCJcXHUyNjA1XCIsIGJpZ3RyaWFuZ2xlZG93bjogXCJcXHUyNUJEXCIsIGJpZ3RyaWFuZ2xldXA6IFwiXFx1MjVCM1wiLCBiaWd1cGx1czogXCJcXHUyQTA0XCIsIGJpZ3ZlZTogXCJcXHUyMkMxXCIsIGJpZ3dlZGdlOiBcIlxcdTIyQzBcIiwgYmthcm93OiBcIlxcdTI5MERcIiwgYmxhY2tsb3plbmdlOiBcIlxcdTI5RUJcIiwgYmxhY2tzcXVhcmU6IFwiXFx1MjVBQVwiLCBibGFja3RyaWFuZ2xlOiBcIlxcdTI1QjRcIiwgYmxhY2t0cmlhbmdsZWRvd246IFwiXFx1MjVCRVwiLCBibGFja3RyaWFuZ2xlbGVmdDogXCJcXHUyNUMyXCIsIGJsYWNrdHJpYW5nbGVyaWdodDogXCJcXHUyNUI4XCIsIGJsYW5rOiBcIlxcdTI0MjNcIiwgYmxrMTI6IFwiXFx1MjU5MlwiLCBibGsxNDogXCJcXHUyNTkxXCIsIGJsazM0OiBcIlxcdTI1OTNcIiwgYmxvY2s6IFwiXFx1MjU4OFwiLCBibmU6IFwiPVxcdTIwRTVcIiwgYm5lcXVpdjogXCJcXHUyMjYxXFx1MjBFNVwiLCBiTm90OiBcIlxcdTJBRURcIiwgYm5vdDogXCJcXHUyMzEwXCIsIEJvcGY6IFwiXFx1ezFENTM5fVwiLCBib3BmOiBcIlxcdXsxRDU1M31cIiwgYm90OiBcIlxcdTIyQTVcIiwgYm90dG9tOiBcIlxcdTIyQTVcIiwgYm93dGllOiBcIlxcdTIyQzhcIiwgYm94Ym94OiBcIlxcdTI5QzlcIiwgYm94ZGw6IFwiXFx1MjUxMFwiLCBib3hkTDogXCJcXHUyNTU1XCIsIGJveERsOiBcIlxcdTI1NTZcIiwgYm94REw6IFwiXFx1MjU1N1wiLCBib3hkcjogXCJcXHUyNTBDXCIsIGJveGRSOiBcIlxcdTI1NTJcIiwgYm94RHI6IFwiXFx1MjU1M1wiLCBib3hEUjogXCJcXHUyNTU0XCIsIGJveGg6IFwiXFx1MjUwMFwiLCBib3hIOiBcIlxcdTI1NTBcIiwgYm94aGQ6IFwiXFx1MjUyQ1wiLCBib3hIZDogXCJcXHUyNTY0XCIsIGJveGhEOiBcIlxcdTI1NjVcIiwgYm94SEQ6IFwiXFx1MjU2NlwiLCBib3hodTogXCJcXHUyNTM0XCIsIGJveEh1OiBcIlxcdTI1NjdcIiwgYm94aFU6IFwiXFx1MjU2OFwiLCBib3hIVTogXCJcXHUyNTY5XCIsIGJveG1pbnVzOiBcIlxcdTIyOUZcIiwgYm94cGx1czogXCJcXHUyMjlFXCIsIGJveHRpbWVzOiBcIlxcdTIyQTBcIiwgYm94dWw6IFwiXFx1MjUxOFwiLCBib3h1TDogXCJcXHUyNTVCXCIsIGJveFVsOiBcIlxcdTI1NUNcIiwgYm94VUw6IFwiXFx1MjU1RFwiLCBib3h1cjogXCJcXHUyNTE0XCIsIGJveHVSOiBcIlxcdTI1NThcIiwgYm94VXI6IFwiXFx1MjU1OVwiLCBib3hVUjogXCJcXHUyNTVBXCIsIGJveHY6IFwiXFx1MjUwMlwiLCBib3hWOiBcIlxcdTI1NTFcIiwgYm94dmg6IFwiXFx1MjUzQ1wiLCBib3h2SDogXCJcXHUyNTZBXCIsIGJveFZoOiBcIlxcdTI1NkJcIiwgYm94Vkg6IFwiXFx1MjU2Q1wiLCBib3h2bDogXCJcXHUyNTI0XCIsIGJveHZMOiBcIlxcdTI1NjFcIiwgYm94Vmw6IFwiXFx1MjU2MlwiLCBib3hWTDogXCJcXHUyNTYzXCIsIGJveHZyOiBcIlxcdTI1MUNcIiwgYm94dlI6IFwiXFx1MjU1RVwiLCBib3hWcjogXCJcXHUyNTVGXCIsIGJveFZSOiBcIlxcdTI1NjBcIiwgYnByaW1lOiBcIlxcdTIwMzVcIiwgYnJldmU6IFwiXFx1MDJEOFwiLCBCcmV2ZTogXCJcXHUwMkQ4XCIsIGJydmJhcjogXCJcXHhBNlwiLCBic2NyOiBcIlxcdXsxRDRCN31cIiwgQnNjcjogXCJcXHUyMTJDXCIsIGJzZW1pOiBcIlxcdTIwNEZcIiwgYnNpbTogXCJcXHUyMjNEXCIsIGJzaW1lOiBcIlxcdTIyQ0RcIiwgYnNvbGI6IFwiXFx1MjlDNVwiLCBic29sOiBcIlxcXFxcIiwgYnNvbGhzdWI6IFwiXFx1MjdDOFwiLCBidWxsOiBcIlxcdTIwMjJcIiwgYnVsbGV0OiBcIlxcdTIwMjJcIiwgYnVtcDogXCJcXHUyMjRFXCIsIGJ1bXBFOiBcIlxcdTJBQUVcIiwgYnVtcGU6IFwiXFx1MjI0RlwiLCBCdW1wZXE6IFwiXFx1MjI0RVwiLCBidW1wZXE6IFwiXFx1MjI0RlwiLCBDYWN1dGU6IFwiXFx1MDEwNlwiLCBjYWN1dGU6IFwiXFx1MDEwN1wiLCBjYXBhbmQ6IFwiXFx1MkE0NFwiLCBjYXBicmN1cDogXCJcXHUyQTQ5XCIsIGNhcGNhcDogXCJcXHUyQTRCXCIsIGNhcDogXCJcXHUyMjI5XCIsIENhcDogXCJcXHUyMkQyXCIsIGNhcGN1cDogXCJcXHUyQTQ3XCIsIGNhcGRvdDogXCJcXHUyQTQwXCIsIENhcGl0YWxEaWZmZXJlbnRpYWxEOiBcIlxcdTIxNDVcIiwgY2FwczogXCJcXHUyMjI5XFx1RkUwMFwiLCBjYXJldDogXCJcXHUyMDQxXCIsIGNhcm9uOiBcIlxcdTAyQzdcIiwgQ2F5bGV5czogXCJcXHUyMTJEXCIsIGNjYXBzOiBcIlxcdTJBNERcIiwgQ2Nhcm9uOiBcIlxcdTAxMENcIiwgY2Nhcm9uOiBcIlxcdTAxMERcIiwgQ2NlZGlsOiBcIlxceEM3XCIsIGNjZWRpbDogXCJcXHhFN1wiLCBDY2lyYzogXCJcXHUwMTA4XCIsIGNjaXJjOiBcIlxcdTAxMDlcIiwgQ2NvbmludDogXCJcXHUyMjMwXCIsIGNjdXBzOiBcIlxcdTJBNENcIiwgY2N1cHNzbTogXCJcXHUyQTUwXCIsIENkb3Q6IFwiXFx1MDEwQVwiLCBjZG90OiBcIlxcdTAxMEJcIiwgY2VkaWw6IFwiXFx4QjhcIiwgQ2VkaWxsYTogXCJcXHhCOFwiLCBjZW1wdHl2OiBcIlxcdTI5QjJcIiwgY2VudDogXCJcXHhBMlwiLCBjZW50ZXJkb3Q6IFwiXFx4QjdcIiwgQ2VudGVyRG90OiBcIlxceEI3XCIsIGNmcjogXCJcXHV7MUQ1MjB9XCIsIENmcjogXCJcXHUyMTJEXCIsIENIY3k6IFwiXFx1MDQyN1wiLCBjaGN5OiBcIlxcdTA0NDdcIiwgY2hlY2s6IFwiXFx1MjcxM1wiLCBjaGVja21hcms6IFwiXFx1MjcxM1wiLCBDaGk6IFwiXFx1MDNBN1wiLCBjaGk6IFwiXFx1MDNDN1wiLCBjaXJjOiBcIlxcdTAyQzZcIiwgY2lyY2VxOiBcIlxcdTIyNTdcIiwgY2lyY2xlYXJyb3dsZWZ0OiBcIlxcdTIxQkFcIiwgY2lyY2xlYXJyb3dyaWdodDogXCJcXHUyMUJCXCIsIGNpcmNsZWRhc3Q6IFwiXFx1MjI5QlwiLCBjaXJjbGVkY2lyYzogXCJcXHUyMjlBXCIsIGNpcmNsZWRkYXNoOiBcIlxcdTIyOURcIiwgQ2lyY2xlRG90OiBcIlxcdTIyOTlcIiwgY2lyY2xlZFI6IFwiXFx4QUVcIiwgY2lyY2xlZFM6IFwiXFx1MjRDOFwiLCBDaXJjbGVNaW51czogXCJcXHUyMjk2XCIsIENpcmNsZVBsdXM6IFwiXFx1MjI5NVwiLCBDaXJjbGVUaW1lczogXCJcXHUyMjk3XCIsIGNpcjogXCJcXHUyNUNCXCIsIGNpckU6IFwiXFx1MjlDM1wiLCBjaXJlOiBcIlxcdTIyNTdcIiwgY2lyZm5pbnQ6IFwiXFx1MkExMFwiLCBjaXJtaWQ6IFwiXFx1MkFFRlwiLCBjaXJzY2lyOiBcIlxcdTI5QzJcIiwgQ2xvY2t3aXNlQ29udG91ckludGVncmFsOiBcIlxcdTIyMzJcIiwgQ2xvc2VDdXJseURvdWJsZVF1b3RlOiBcIlxcdTIwMURcIiwgQ2xvc2VDdXJseVF1b3RlOiBcIlxcdTIwMTlcIiwgY2x1YnM6IFwiXFx1MjY2M1wiLCBjbHVic3VpdDogXCJcXHUyNjYzXCIsIGNvbG9uOiBcIjpcIiwgQ29sb246IFwiXFx1MjIzN1wiLCBDb2xvbmU6IFwiXFx1MkE3NFwiLCBjb2xvbmU6IFwiXFx1MjI1NFwiLCBjb2xvbmVxOiBcIlxcdTIyNTRcIiwgY29tbWE6IFwiLFwiLCBjb21tYXQ6IFwiQFwiLCBjb21wOiBcIlxcdTIyMDFcIiwgY29tcGZuOiBcIlxcdTIyMThcIiwgY29tcGxlbWVudDogXCJcXHUyMjAxXCIsIGNvbXBsZXhlczogXCJcXHUyMTAyXCIsIGNvbmc6IFwiXFx1MjI0NVwiLCBjb25nZG90OiBcIlxcdTJBNkRcIiwgQ29uZ3J1ZW50OiBcIlxcdTIyNjFcIiwgY29uaW50OiBcIlxcdTIyMkVcIiwgQ29uaW50OiBcIlxcdTIyMkZcIiwgQ29udG91ckludGVncmFsOiBcIlxcdTIyMkVcIiwgY29wZjogXCJcXHV7MUQ1NTR9XCIsIENvcGY6IFwiXFx1MjEwMlwiLCBjb3Byb2Q6IFwiXFx1MjIxMFwiLCBDb3Byb2R1Y3Q6IFwiXFx1MjIxMFwiLCBjb3B5OiBcIlxceEE5XCIsIENPUFk6IFwiXFx4QTlcIiwgY29weXNyOiBcIlxcdTIxMTdcIiwgQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDogXCJcXHUyMjMzXCIsIGNyYXJyOiBcIlxcdTIxQjVcIiwgY3Jvc3M6IFwiXFx1MjcxN1wiLCBDcm9zczogXCJcXHUyQTJGXCIsIENzY3I6IFwiXFx1ezFENDlFfVwiLCBjc2NyOiBcIlxcdXsxRDRCOH1cIiwgY3N1YjogXCJcXHUyQUNGXCIsIGNzdWJlOiBcIlxcdTJBRDFcIiwgY3N1cDogXCJcXHUyQUQwXCIsIGNzdXBlOiBcIlxcdTJBRDJcIiwgY3Rkb3Q6IFwiXFx1MjJFRlwiLCBjdWRhcnJsOiBcIlxcdTI5MzhcIiwgY3VkYXJycjogXCJcXHUyOTM1XCIsIGN1ZXByOiBcIlxcdTIyREVcIiwgY3Vlc2M6IFwiXFx1MjJERlwiLCBjdWxhcnI6IFwiXFx1MjFCNlwiLCBjdWxhcnJwOiBcIlxcdTI5M0RcIiwgY3VwYnJjYXA6IFwiXFx1MkE0OFwiLCBjdXBjYXA6IFwiXFx1MkE0NlwiLCBDdXBDYXA6IFwiXFx1MjI0RFwiLCBjdXA6IFwiXFx1MjIyQVwiLCBDdXA6IFwiXFx1MjJEM1wiLCBjdXBjdXA6IFwiXFx1MkE0QVwiLCBjdXBkb3Q6IFwiXFx1MjI4RFwiLCBjdXBvcjogXCJcXHUyQTQ1XCIsIGN1cHM6IFwiXFx1MjIyQVxcdUZFMDBcIiwgY3VyYXJyOiBcIlxcdTIxQjdcIiwgY3VyYXJybTogXCJcXHUyOTNDXCIsIGN1cmx5ZXFwcmVjOiBcIlxcdTIyREVcIiwgY3VybHllcXN1Y2M6IFwiXFx1MjJERlwiLCBjdXJseXZlZTogXCJcXHUyMkNFXCIsIGN1cmx5d2VkZ2U6IFwiXFx1MjJDRlwiLCBjdXJyZW46IFwiXFx4QTRcIiwgY3VydmVhcnJvd2xlZnQ6IFwiXFx1MjFCNlwiLCBjdXJ2ZWFycm93cmlnaHQ6IFwiXFx1MjFCN1wiLCBjdXZlZTogXCJcXHUyMkNFXCIsIGN1d2VkOiBcIlxcdTIyQ0ZcIiwgY3djb25pbnQ6IFwiXFx1MjIzMlwiLCBjd2ludDogXCJcXHUyMjMxXCIsIGN5bGN0eTogXCJcXHUyMzJEXCIsIGRhZ2dlcjogXCJcXHUyMDIwXCIsIERhZ2dlcjogXCJcXHUyMDIxXCIsIGRhbGV0aDogXCJcXHUyMTM4XCIsIGRhcnI6IFwiXFx1MjE5M1wiLCBEYXJyOiBcIlxcdTIxQTFcIiwgZEFycjogXCJcXHUyMUQzXCIsIGRhc2g6IFwiXFx1MjAxMFwiLCBEYXNodjogXCJcXHUyQUU0XCIsIGRhc2h2OiBcIlxcdTIyQTNcIiwgZGJrYXJvdzogXCJcXHUyOTBGXCIsIGRibGFjOiBcIlxcdTAyRERcIiwgRGNhcm9uOiBcIlxcdTAxMEVcIiwgZGNhcm9uOiBcIlxcdTAxMEZcIiwgRGN5OiBcIlxcdTA0MTRcIiwgZGN5OiBcIlxcdTA0MzRcIiwgZGRhZ2dlcjogXCJcXHUyMDIxXCIsIGRkYXJyOiBcIlxcdTIxQ0FcIiwgREQ6IFwiXFx1MjE0NVwiLCBkZDogXCJcXHUyMTQ2XCIsIEREb3RyYWhkOiBcIlxcdTI5MTFcIiwgZGRvdHNlcTogXCJcXHUyQTc3XCIsIGRlZzogXCJcXHhCMFwiLCBEZWw6IFwiXFx1MjIwN1wiLCBEZWx0YTogXCJcXHUwMzk0XCIsIGRlbHRhOiBcIlxcdTAzQjRcIiwgZGVtcHR5djogXCJcXHUyOUIxXCIsIGRmaXNodDogXCJcXHUyOTdGXCIsIERmcjogXCJcXHV7MUQ1MDd9XCIsIGRmcjogXCJcXHV7MUQ1MjF9XCIsIGRIYXI6IFwiXFx1Mjk2NVwiLCBkaGFybDogXCJcXHUyMUMzXCIsIGRoYXJyOiBcIlxcdTIxQzJcIiwgRGlhY3JpdGljYWxBY3V0ZTogXCJcXHhCNFwiLCBEaWFjcml0aWNhbERvdDogXCJcXHUwMkQ5XCIsIERpYWNyaXRpY2FsRG91YmxlQWN1dGU6IFwiXFx1MDJERFwiLCBEaWFjcml0aWNhbEdyYXZlOiBcImBcIiwgRGlhY3JpdGljYWxUaWxkZTogXCJcXHUwMkRDXCIsIGRpYW06IFwiXFx1MjJDNFwiLCBkaWFtb25kOiBcIlxcdTIyQzRcIiwgRGlhbW9uZDogXCJcXHUyMkM0XCIsIGRpYW1vbmRzdWl0OiBcIlxcdTI2NjZcIiwgZGlhbXM6IFwiXFx1MjY2NlwiLCBkaWU6IFwiXFx4QThcIiwgRGlmZmVyZW50aWFsRDogXCJcXHUyMTQ2XCIsIGRpZ2FtbWE6IFwiXFx1MDNERFwiLCBkaXNpbjogXCJcXHUyMkYyXCIsIGRpdjogXCJcXHhGN1wiLCBkaXZpZGU6IFwiXFx4RjdcIiwgZGl2aWRlb250aW1lczogXCJcXHUyMkM3XCIsIGRpdm9ueDogXCJcXHUyMkM3XCIsIERKY3k6IFwiXFx1MDQwMlwiLCBkamN5OiBcIlxcdTA0NTJcIiwgZGxjb3JuOiBcIlxcdTIzMUVcIiwgZGxjcm9wOiBcIlxcdTIzMERcIiwgZG9sbGFyOiBcIiRcIiwgRG9wZjogXCJcXHV7MUQ1M0J9XCIsIGRvcGY6IFwiXFx1ezFENTU1fVwiLCBEb3Q6IFwiXFx4QThcIiwgZG90OiBcIlxcdTAyRDlcIiwgRG90RG90OiBcIlxcdTIwRENcIiwgZG90ZXE6IFwiXFx1MjI1MFwiLCBkb3RlcWRvdDogXCJcXHUyMjUxXCIsIERvdEVxdWFsOiBcIlxcdTIyNTBcIiwgZG90bWludXM6IFwiXFx1MjIzOFwiLCBkb3RwbHVzOiBcIlxcdTIyMTRcIiwgZG90c3F1YXJlOiBcIlxcdTIyQTFcIiwgZG91YmxlYmFyd2VkZ2U6IFwiXFx1MjMwNlwiLCBEb3VibGVDb250b3VySW50ZWdyYWw6IFwiXFx1MjIyRlwiLCBEb3VibGVEb3Q6IFwiXFx4QThcIiwgRG91YmxlRG93bkFycm93OiBcIlxcdTIxRDNcIiwgRG91YmxlTGVmdEFycm93OiBcIlxcdTIxRDBcIiwgRG91YmxlTGVmdFJpZ2h0QXJyb3c6IFwiXFx1MjFENFwiLCBEb3VibGVMZWZ0VGVlOiBcIlxcdTJBRTRcIiwgRG91YmxlTG9uZ0xlZnRBcnJvdzogXCJcXHUyN0Y4XCIsIERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdzogXCJcXHUyN0ZBXCIsIERvdWJsZUxvbmdSaWdodEFycm93OiBcIlxcdTI3RjlcIiwgRG91YmxlUmlnaHRBcnJvdzogXCJcXHUyMUQyXCIsIERvdWJsZVJpZ2h0VGVlOiBcIlxcdTIyQThcIiwgRG91YmxlVXBBcnJvdzogXCJcXHUyMUQxXCIsIERvdWJsZVVwRG93bkFycm93OiBcIlxcdTIxRDVcIiwgRG91YmxlVmVydGljYWxCYXI6IFwiXFx1MjIyNVwiLCBEb3duQXJyb3dCYXI6IFwiXFx1MjkxM1wiLCBkb3duYXJyb3c6IFwiXFx1MjE5M1wiLCBEb3duQXJyb3c6IFwiXFx1MjE5M1wiLCBEb3duYXJyb3c6IFwiXFx1MjFEM1wiLCBEb3duQXJyb3dVcEFycm93OiBcIlxcdTIxRjVcIiwgRG93bkJyZXZlOiBcIlxcdTAzMTFcIiwgZG93bmRvd25hcnJvd3M6IFwiXFx1MjFDQVwiLCBkb3duaGFycG9vbmxlZnQ6IFwiXFx1MjFDM1wiLCBkb3duaGFycG9vbnJpZ2h0OiBcIlxcdTIxQzJcIiwgRG93bkxlZnRSaWdodFZlY3RvcjogXCJcXHUyOTUwXCIsIERvd25MZWZ0VGVlVmVjdG9yOiBcIlxcdTI5NUVcIiwgRG93bkxlZnRWZWN0b3JCYXI6IFwiXFx1Mjk1NlwiLCBEb3duTGVmdFZlY3RvcjogXCJcXHUyMUJEXCIsIERvd25SaWdodFRlZVZlY3RvcjogXCJcXHUyOTVGXCIsIERvd25SaWdodFZlY3RvckJhcjogXCJcXHUyOTU3XCIsIERvd25SaWdodFZlY3RvcjogXCJcXHUyMUMxXCIsIERvd25UZWVBcnJvdzogXCJcXHUyMUE3XCIsIERvd25UZWU6IFwiXFx1MjJBNFwiLCBkcmJrYXJvdzogXCJcXHUyOTEwXCIsIGRyY29ybjogXCJcXHUyMzFGXCIsIGRyY3JvcDogXCJcXHUyMzBDXCIsIERzY3I6IFwiXFx1ezFENDlGfVwiLCBkc2NyOiBcIlxcdXsxRDRCOX1cIiwgRFNjeTogXCJcXHUwNDA1XCIsIGRzY3k6IFwiXFx1MDQ1NVwiLCBkc29sOiBcIlxcdTI5RjZcIiwgRHN0cm9rOiBcIlxcdTAxMTBcIiwgZHN0cm9rOiBcIlxcdTAxMTFcIiwgZHRkb3Q6IFwiXFx1MjJGMVwiLCBkdHJpOiBcIlxcdTI1QkZcIiwgZHRyaWY6IFwiXFx1MjVCRVwiLCBkdWFycjogXCJcXHUyMUY1XCIsIGR1aGFyOiBcIlxcdTI5NkZcIiwgZHdhbmdsZTogXCJcXHUyOUE2XCIsIERaY3k6IFwiXFx1MDQwRlwiLCBkemN5OiBcIlxcdTA0NUZcIiwgZHppZ3JhcnI6IFwiXFx1MjdGRlwiLCBFYWN1dGU6IFwiXFx4QzlcIiwgZWFjdXRlOiBcIlxceEU5XCIsIGVhc3RlcjogXCJcXHUyQTZFXCIsIEVjYXJvbjogXCJcXHUwMTFBXCIsIGVjYXJvbjogXCJcXHUwMTFCXCIsIEVjaXJjOiBcIlxceENBXCIsIGVjaXJjOiBcIlxceEVBXCIsIGVjaXI6IFwiXFx1MjI1NlwiLCBlY29sb246IFwiXFx1MjI1NVwiLCBFY3k6IFwiXFx1MDQyRFwiLCBlY3k6IFwiXFx1MDQ0RFwiLCBlRERvdDogXCJcXHUyQTc3XCIsIEVkb3Q6IFwiXFx1MDExNlwiLCBlZG90OiBcIlxcdTAxMTdcIiwgZURvdDogXCJcXHUyMjUxXCIsIGVlOiBcIlxcdTIxNDdcIiwgZWZEb3Q6IFwiXFx1MjI1MlwiLCBFZnI6IFwiXFx1ezFENTA4fVwiLCBlZnI6IFwiXFx1ezFENTIyfVwiLCBlZzogXCJcXHUyQTlBXCIsIEVncmF2ZTogXCJcXHhDOFwiLCBlZ3JhdmU6IFwiXFx4RThcIiwgZWdzOiBcIlxcdTJBOTZcIiwgZWdzZG90OiBcIlxcdTJBOThcIiwgZWw6IFwiXFx1MkE5OVwiLCBFbGVtZW50OiBcIlxcdTIyMDhcIiwgZWxpbnRlcnM6IFwiXFx1MjNFN1wiLCBlbGw6IFwiXFx1MjExM1wiLCBlbHM6IFwiXFx1MkE5NVwiLCBlbHNkb3Q6IFwiXFx1MkE5N1wiLCBFbWFjcjogXCJcXHUwMTEyXCIsIGVtYWNyOiBcIlxcdTAxMTNcIiwgZW1wdHk6IFwiXFx1MjIwNVwiLCBlbXB0eXNldDogXCJcXHUyMjA1XCIsIEVtcHR5U21hbGxTcXVhcmU6IFwiXFx1MjVGQlwiLCBlbXB0eXY6IFwiXFx1MjIwNVwiLCBFbXB0eVZlcnlTbWFsbFNxdWFyZTogXCJcXHUyNUFCXCIsIGVtc3AxMzogXCJcXHUyMDA0XCIsIGVtc3AxNDogXCJcXHUyMDA1XCIsIGVtc3A6IFwiXFx1MjAwM1wiLCBFTkc6IFwiXFx1MDE0QVwiLCBlbmc6IFwiXFx1MDE0QlwiLCBlbnNwOiBcIlxcdTIwMDJcIiwgRW9nb246IFwiXFx1MDExOFwiLCBlb2dvbjogXCJcXHUwMTE5XCIsIEVvcGY6IFwiXFx1ezFENTNDfVwiLCBlb3BmOiBcIlxcdXsxRDU1Nn1cIiwgZXBhcjogXCJcXHUyMkQ1XCIsIGVwYXJzbDogXCJcXHUyOUUzXCIsIGVwbHVzOiBcIlxcdTJBNzFcIiwgZXBzaTogXCJcXHUwM0I1XCIsIEVwc2lsb246IFwiXFx1MDM5NVwiLCBlcHNpbG9uOiBcIlxcdTAzQjVcIiwgZXBzaXY6IFwiXFx1MDNGNVwiLCBlcWNpcmM6IFwiXFx1MjI1NlwiLCBlcWNvbG9uOiBcIlxcdTIyNTVcIiwgZXFzaW06IFwiXFx1MjI0MlwiLCBlcXNsYW50Z3RyOiBcIlxcdTJBOTZcIiwgZXFzbGFudGxlc3M6IFwiXFx1MkE5NVwiLCBFcXVhbDogXCJcXHUyQTc1XCIsIGVxdWFsczogXCI9XCIsIEVxdWFsVGlsZGU6IFwiXFx1MjI0MlwiLCBlcXVlc3Q6IFwiXFx1MjI1RlwiLCBFcXVpbGlicml1bTogXCJcXHUyMUNDXCIsIGVxdWl2OiBcIlxcdTIyNjFcIiwgZXF1aXZERDogXCJcXHUyQTc4XCIsIGVxdnBhcnNsOiBcIlxcdTI5RTVcIiwgZXJhcnI6IFwiXFx1Mjk3MVwiLCBlckRvdDogXCJcXHUyMjUzXCIsIGVzY3I6IFwiXFx1MjEyRlwiLCBFc2NyOiBcIlxcdTIxMzBcIiwgZXNkb3Q6IFwiXFx1MjI1MFwiLCBFc2ltOiBcIlxcdTJBNzNcIiwgZXNpbTogXCJcXHUyMjQyXCIsIEV0YTogXCJcXHUwMzk3XCIsIGV0YTogXCJcXHUwM0I3XCIsIEVUSDogXCJcXHhEMFwiLCBldGg6IFwiXFx4RjBcIiwgRXVtbDogXCJcXHhDQlwiLCBldW1sOiBcIlxceEVCXCIsIGV1cm86IFwiXFx1MjBBQ1wiLCBleGNsOiBcIiFcIiwgZXhpc3Q6IFwiXFx1MjIwM1wiLCBFeGlzdHM6IFwiXFx1MjIwM1wiLCBleHBlY3RhdGlvbjogXCJcXHUyMTMwXCIsIGV4cG9uZW50aWFsZTogXCJcXHUyMTQ3XCIsIEV4cG9uZW50aWFsRTogXCJcXHUyMTQ3XCIsIGZhbGxpbmdkb3RzZXE6IFwiXFx1MjI1MlwiLCBGY3k6IFwiXFx1MDQyNFwiLCBmY3k6IFwiXFx1MDQ0NFwiLCBmZW1hbGU6IFwiXFx1MjY0MFwiLCBmZmlsaWc6IFwiXFx1RkIwM1wiLCBmZmxpZzogXCJcXHVGQjAwXCIsIGZmbGxpZzogXCJcXHVGQjA0XCIsIEZmcjogXCJcXHV7MUQ1MDl9XCIsIGZmcjogXCJcXHV7MUQ1MjN9XCIsIGZpbGlnOiBcIlxcdUZCMDFcIiwgRmlsbGVkU21hbGxTcXVhcmU6IFwiXFx1MjVGQ1wiLCBGaWxsZWRWZXJ5U21hbGxTcXVhcmU6IFwiXFx1MjVBQVwiLCBmamxpZzogXCJmalwiLCBmbGF0OiBcIlxcdTI2NkRcIiwgZmxsaWc6IFwiXFx1RkIwMlwiLCBmbHRuczogXCJcXHUyNUIxXCIsIGZub2Y6IFwiXFx1MDE5MlwiLCBGb3BmOiBcIlxcdXsxRDUzRH1cIiwgZm9wZjogXCJcXHV7MUQ1NTd9XCIsIGZvcmFsbDogXCJcXHUyMjAwXCIsIEZvckFsbDogXCJcXHUyMjAwXCIsIGZvcms6IFwiXFx1MjJENFwiLCBmb3JrdjogXCJcXHUyQUQ5XCIsIEZvdXJpZXJ0cmY6IFwiXFx1MjEzMVwiLCBmcGFydGludDogXCJcXHUyQTBEXCIsIGZyYWMxMjogXCJcXHhCRFwiLCBmcmFjMTM6IFwiXFx1MjE1M1wiLCBmcmFjMTQ6IFwiXFx4QkNcIiwgZnJhYzE1OiBcIlxcdTIxNTVcIiwgZnJhYzE2OiBcIlxcdTIxNTlcIiwgZnJhYzE4OiBcIlxcdTIxNUJcIiwgZnJhYzIzOiBcIlxcdTIxNTRcIiwgZnJhYzI1OiBcIlxcdTIxNTZcIiwgZnJhYzM0OiBcIlxceEJFXCIsIGZyYWMzNTogXCJcXHUyMTU3XCIsIGZyYWMzODogXCJcXHUyMTVDXCIsIGZyYWM0NTogXCJcXHUyMTU4XCIsIGZyYWM1NjogXCJcXHUyMTVBXCIsIGZyYWM1ODogXCJcXHUyMTVEXCIsIGZyYWM3ODogXCJcXHUyMTVFXCIsIGZyYXNsOiBcIlxcdTIwNDRcIiwgZnJvd246IFwiXFx1MjMyMlwiLCBmc2NyOiBcIlxcdXsxRDRCQn1cIiwgRnNjcjogXCJcXHUyMTMxXCIsIGdhY3V0ZTogXCJcXHUwMUY1XCIsIEdhbW1hOiBcIlxcdTAzOTNcIiwgZ2FtbWE6IFwiXFx1MDNCM1wiLCBHYW1tYWQ6IFwiXFx1MDNEQ1wiLCBnYW1tYWQ6IFwiXFx1MDNERFwiLCBnYXA6IFwiXFx1MkE4NlwiLCBHYnJldmU6IFwiXFx1MDExRVwiLCBnYnJldmU6IFwiXFx1MDExRlwiLCBHY2VkaWw6IFwiXFx1MDEyMlwiLCBHY2lyYzogXCJcXHUwMTFDXCIsIGdjaXJjOiBcIlxcdTAxMURcIiwgR2N5OiBcIlxcdTA0MTNcIiwgZ2N5OiBcIlxcdTA0MzNcIiwgR2RvdDogXCJcXHUwMTIwXCIsIGdkb3Q6IFwiXFx1MDEyMVwiLCBnZTogXCJcXHUyMjY1XCIsIGdFOiBcIlxcdTIyNjdcIiwgZ0VsOiBcIlxcdTJBOENcIiwgZ2VsOiBcIlxcdTIyREJcIiwgZ2VxOiBcIlxcdTIyNjVcIiwgZ2VxcTogXCJcXHUyMjY3XCIsIGdlcXNsYW50OiBcIlxcdTJBN0VcIiwgZ2VzY2M6IFwiXFx1MkFBOVwiLCBnZXM6IFwiXFx1MkE3RVwiLCBnZXNkb3Q6IFwiXFx1MkE4MFwiLCBnZXNkb3RvOiBcIlxcdTJBODJcIiwgZ2VzZG90b2w6IFwiXFx1MkE4NFwiLCBnZXNsOiBcIlxcdTIyREJcXHVGRTAwXCIsIGdlc2xlczogXCJcXHUyQTk0XCIsIEdmcjogXCJcXHV7MUQ1MEF9XCIsIGdmcjogXCJcXHV7MUQ1MjR9XCIsIGdnOiBcIlxcdTIyNkJcIiwgR2c6IFwiXFx1MjJEOVwiLCBnZ2c6IFwiXFx1MjJEOVwiLCBnaW1lbDogXCJcXHUyMTM3XCIsIEdKY3k6IFwiXFx1MDQwM1wiLCBnamN5OiBcIlxcdTA0NTNcIiwgZ2xhOiBcIlxcdTJBQTVcIiwgZ2w6IFwiXFx1MjI3N1wiLCBnbEU6IFwiXFx1MkE5MlwiLCBnbGo6IFwiXFx1MkFBNFwiLCBnbmFwOiBcIlxcdTJBOEFcIiwgZ25hcHByb3g6IFwiXFx1MkE4QVwiLCBnbmU6IFwiXFx1MkE4OFwiLCBnbkU6IFwiXFx1MjI2OVwiLCBnbmVxOiBcIlxcdTJBODhcIiwgZ25lcXE6IFwiXFx1MjI2OVwiLCBnbnNpbTogXCJcXHUyMkU3XCIsIEdvcGY6IFwiXFx1ezFENTNFfVwiLCBnb3BmOiBcIlxcdXsxRDU1OH1cIiwgZ3JhdmU6IFwiYFwiLCBHcmVhdGVyRXF1YWw6IFwiXFx1MjI2NVwiLCBHcmVhdGVyRXF1YWxMZXNzOiBcIlxcdTIyREJcIiwgR3JlYXRlckZ1bGxFcXVhbDogXCJcXHUyMjY3XCIsIEdyZWF0ZXJHcmVhdGVyOiBcIlxcdTJBQTJcIiwgR3JlYXRlckxlc3M6IFwiXFx1MjI3N1wiLCBHcmVhdGVyU2xhbnRFcXVhbDogXCJcXHUyQTdFXCIsIEdyZWF0ZXJUaWxkZTogXCJcXHUyMjczXCIsIEdzY3I6IFwiXFx1ezFENEEyfVwiLCBnc2NyOiBcIlxcdTIxMEFcIiwgZ3NpbTogXCJcXHUyMjczXCIsIGdzaW1lOiBcIlxcdTJBOEVcIiwgZ3NpbWw6IFwiXFx1MkE5MFwiLCBndGNjOiBcIlxcdTJBQTdcIiwgZ3RjaXI6IFwiXFx1MkE3QVwiLCBndDogXCI+XCIsIEdUOiBcIj5cIiwgR3Q6IFwiXFx1MjI2QlwiLCBndGRvdDogXCJcXHUyMkQ3XCIsIGd0bFBhcjogXCJcXHUyOTk1XCIsIGd0cXVlc3Q6IFwiXFx1MkE3Q1wiLCBndHJhcHByb3g6IFwiXFx1MkE4NlwiLCBndHJhcnI6IFwiXFx1Mjk3OFwiLCBndHJkb3Q6IFwiXFx1MjJEN1wiLCBndHJlcWxlc3M6IFwiXFx1MjJEQlwiLCBndHJlcXFsZXNzOiBcIlxcdTJBOENcIiwgZ3RybGVzczogXCJcXHUyMjc3XCIsIGd0cnNpbTogXCJcXHUyMjczXCIsIGd2ZXJ0bmVxcTogXCJcXHUyMjY5XFx1RkUwMFwiLCBndm5FOiBcIlxcdTIyNjlcXHVGRTAwXCIsIEhhY2VrOiBcIlxcdTAyQzdcIiwgaGFpcnNwOiBcIlxcdTIwMEFcIiwgaGFsZjogXCJcXHhCRFwiLCBoYW1pbHQ6IFwiXFx1MjEwQlwiLCBIQVJEY3k6IFwiXFx1MDQyQVwiLCBoYXJkY3k6IFwiXFx1MDQ0QVwiLCBoYXJyY2lyOiBcIlxcdTI5NDhcIiwgaGFycjogXCJcXHUyMTk0XCIsIGhBcnI6IFwiXFx1MjFENFwiLCBoYXJydzogXCJcXHUyMUFEXCIsIEhhdDogXCJeXCIsIGhiYXI6IFwiXFx1MjEwRlwiLCBIY2lyYzogXCJcXHUwMTI0XCIsIGhjaXJjOiBcIlxcdTAxMjVcIiwgaGVhcnRzOiBcIlxcdTI2NjVcIiwgaGVhcnRzdWl0OiBcIlxcdTI2NjVcIiwgaGVsbGlwOiBcIlxcdTIwMjZcIiwgaGVyY29uOiBcIlxcdTIyQjlcIiwgaGZyOiBcIlxcdXsxRDUyNX1cIiwgSGZyOiBcIlxcdTIxMENcIiwgSGlsYmVydFNwYWNlOiBcIlxcdTIxMEJcIiwgaGtzZWFyb3c6IFwiXFx1MjkyNVwiLCBoa3N3YXJvdzogXCJcXHUyOTI2XCIsIGhvYXJyOiBcIlxcdTIxRkZcIiwgaG9tdGh0OiBcIlxcdTIyM0JcIiwgaG9va2xlZnRhcnJvdzogXCJcXHUyMUE5XCIsIGhvb2tyaWdodGFycm93OiBcIlxcdTIxQUFcIiwgaG9wZjogXCJcXHV7MUQ1NTl9XCIsIEhvcGY6IFwiXFx1MjEwRFwiLCBob3JiYXI6IFwiXFx1MjAxNVwiLCBIb3Jpem9udGFsTGluZTogXCJcXHUyNTAwXCIsIGhzY3I6IFwiXFx1ezFENEJEfVwiLCBIc2NyOiBcIlxcdTIxMEJcIiwgaHNsYXNoOiBcIlxcdTIxMEZcIiwgSHN0cm9rOiBcIlxcdTAxMjZcIiwgaHN0cm9rOiBcIlxcdTAxMjdcIiwgSHVtcERvd25IdW1wOiBcIlxcdTIyNEVcIiwgSHVtcEVxdWFsOiBcIlxcdTIyNEZcIiwgaHlidWxsOiBcIlxcdTIwNDNcIiwgaHlwaGVuOiBcIlxcdTIwMTBcIiwgSWFjdXRlOiBcIlxceENEXCIsIGlhY3V0ZTogXCJcXHhFRFwiLCBpYzogXCJcXHUyMDYzXCIsIEljaXJjOiBcIlxceENFXCIsIGljaXJjOiBcIlxceEVFXCIsIEljeTogXCJcXHUwNDE4XCIsIGljeTogXCJcXHUwNDM4XCIsIElkb3Q6IFwiXFx1MDEzMFwiLCBJRWN5OiBcIlxcdTA0MTVcIiwgaWVjeTogXCJcXHUwNDM1XCIsIGlleGNsOiBcIlxceEExXCIsIGlmZjogXCJcXHUyMUQ0XCIsIGlmcjogXCJcXHV7MUQ1MjZ9XCIsIElmcjogXCJcXHUyMTExXCIsIElncmF2ZTogXCJcXHhDQ1wiLCBpZ3JhdmU6IFwiXFx4RUNcIiwgaWk6IFwiXFx1MjE0OFwiLCBpaWlpbnQ6IFwiXFx1MkEwQ1wiLCBpaWludDogXCJcXHUyMjJEXCIsIGlpbmZpbjogXCJcXHUyOURDXCIsIGlpb3RhOiBcIlxcdTIxMjlcIiwgSUpsaWc6IFwiXFx1MDEzMlwiLCBpamxpZzogXCJcXHUwMTMzXCIsIEltYWNyOiBcIlxcdTAxMkFcIiwgaW1hY3I6IFwiXFx1MDEyQlwiLCBpbWFnZTogXCJcXHUyMTExXCIsIEltYWdpbmFyeUk6IFwiXFx1MjE0OFwiLCBpbWFnbGluZTogXCJcXHUyMTEwXCIsIGltYWdwYXJ0OiBcIlxcdTIxMTFcIiwgaW1hdGg6IFwiXFx1MDEzMVwiLCBJbTogXCJcXHUyMTExXCIsIGltb2Y6IFwiXFx1MjJCN1wiLCBpbXBlZDogXCJcXHUwMUI1XCIsIEltcGxpZXM6IFwiXFx1MjFEMlwiLCBpbmNhcmU6IFwiXFx1MjEwNVwiLCBpbjogXCJcXHUyMjA4XCIsIGluZmluOiBcIlxcdTIyMUVcIiwgaW5maW50aWU6IFwiXFx1MjlERFwiLCBpbm9kb3Q6IFwiXFx1MDEzMVwiLCBpbnRjYWw6IFwiXFx1MjJCQVwiLCBpbnQ6IFwiXFx1MjIyQlwiLCBJbnQ6IFwiXFx1MjIyQ1wiLCBpbnRlZ2VyczogXCJcXHUyMTI0XCIsIEludGVncmFsOiBcIlxcdTIyMkJcIiwgaW50ZXJjYWw6IFwiXFx1MjJCQVwiLCBJbnRlcnNlY3Rpb246IFwiXFx1MjJDMlwiLCBpbnRsYXJoazogXCJcXHUyQTE3XCIsIGludHByb2Q6IFwiXFx1MkEzQ1wiLCBJbnZpc2libGVDb21tYTogXCJcXHUyMDYzXCIsIEludmlzaWJsZVRpbWVzOiBcIlxcdTIwNjJcIiwgSU9jeTogXCJcXHUwNDAxXCIsIGlvY3k6IFwiXFx1MDQ1MVwiLCBJb2dvbjogXCJcXHUwMTJFXCIsIGlvZ29uOiBcIlxcdTAxMkZcIiwgSW9wZjogXCJcXHV7MUQ1NDB9XCIsIGlvcGY6IFwiXFx1ezFENTVBfVwiLCBJb3RhOiBcIlxcdTAzOTlcIiwgaW90YTogXCJcXHUwM0I5XCIsIGlwcm9kOiBcIlxcdTJBM0NcIiwgaXF1ZXN0OiBcIlxceEJGXCIsIGlzY3I6IFwiXFx1ezFENEJFfVwiLCBJc2NyOiBcIlxcdTIxMTBcIiwgaXNpbjogXCJcXHUyMjA4XCIsIGlzaW5kb3Q6IFwiXFx1MjJGNVwiLCBpc2luRTogXCJcXHUyMkY5XCIsIGlzaW5zOiBcIlxcdTIyRjRcIiwgaXNpbnN2OiBcIlxcdTIyRjNcIiwgaXNpbnY6IFwiXFx1MjIwOFwiLCBpdDogXCJcXHUyMDYyXCIsIEl0aWxkZTogXCJcXHUwMTI4XCIsIGl0aWxkZTogXCJcXHUwMTI5XCIsIEl1a2N5OiBcIlxcdTA0MDZcIiwgaXVrY3k6IFwiXFx1MDQ1NlwiLCBJdW1sOiBcIlxceENGXCIsIGl1bWw6IFwiXFx4RUZcIiwgSmNpcmM6IFwiXFx1MDEzNFwiLCBqY2lyYzogXCJcXHUwMTM1XCIsIEpjeTogXCJcXHUwNDE5XCIsIGpjeTogXCJcXHUwNDM5XCIsIEpmcjogXCJcXHV7MUQ1MER9XCIsIGpmcjogXCJcXHV7MUQ1Mjd9XCIsIGptYXRoOiBcIlxcdTAyMzdcIiwgSm9wZjogXCJcXHV7MUQ1NDF9XCIsIGpvcGY6IFwiXFx1ezFENTVCfVwiLCBKc2NyOiBcIlxcdXsxRDRBNX1cIiwganNjcjogXCJcXHV7MUQ0QkZ9XCIsIEpzZXJjeTogXCJcXHUwNDA4XCIsIGpzZXJjeTogXCJcXHUwNDU4XCIsIEp1a2N5OiBcIlxcdTA0MDRcIiwganVrY3k6IFwiXFx1MDQ1NFwiLCBLYXBwYTogXCJcXHUwMzlBXCIsIGthcHBhOiBcIlxcdTAzQkFcIiwga2FwcGF2OiBcIlxcdTAzRjBcIiwgS2NlZGlsOiBcIlxcdTAxMzZcIiwga2NlZGlsOiBcIlxcdTAxMzdcIiwgS2N5OiBcIlxcdTA0MUFcIiwga2N5OiBcIlxcdTA0M0FcIiwgS2ZyOiBcIlxcdXsxRDUwRX1cIiwga2ZyOiBcIlxcdXsxRDUyOH1cIiwga2dyZWVuOiBcIlxcdTAxMzhcIiwgS0hjeTogXCJcXHUwNDI1XCIsIGtoY3k6IFwiXFx1MDQ0NVwiLCBLSmN5OiBcIlxcdTA0MENcIiwga2pjeTogXCJcXHUwNDVDXCIsIEtvcGY6IFwiXFx1ezFENTQyfVwiLCBrb3BmOiBcIlxcdXsxRDU1Q31cIiwgS3NjcjogXCJcXHV7MUQ0QTZ9XCIsIGtzY3I6IFwiXFx1ezFENEMwfVwiLCBsQWFycjogXCJcXHUyMURBXCIsIExhY3V0ZTogXCJcXHUwMTM5XCIsIGxhY3V0ZTogXCJcXHUwMTNBXCIsIGxhZW1wdHl2OiBcIlxcdTI5QjRcIiwgbGFncmFuOiBcIlxcdTIxMTJcIiwgTGFtYmRhOiBcIlxcdTAzOUJcIiwgbGFtYmRhOiBcIlxcdTAzQkJcIiwgbGFuZzogXCJcXHUyN0U4XCIsIExhbmc6IFwiXFx1MjdFQVwiLCBsYW5nZDogXCJcXHUyOTkxXCIsIGxhbmdsZTogXCJcXHUyN0U4XCIsIGxhcDogXCJcXHUyQTg1XCIsIExhcGxhY2V0cmY6IFwiXFx1MjExMlwiLCBsYXF1bzogXCJcXHhBQlwiLCBsYXJyYjogXCJcXHUyMUU0XCIsIGxhcnJiZnM6IFwiXFx1MjkxRlwiLCBsYXJyOiBcIlxcdTIxOTBcIiwgTGFycjogXCJcXHUyMTlFXCIsIGxBcnI6IFwiXFx1MjFEMFwiLCBsYXJyZnM6IFwiXFx1MjkxRFwiLCBsYXJyaGs6IFwiXFx1MjFBOVwiLCBsYXJybHA6IFwiXFx1MjFBQlwiLCBsYXJycGw6IFwiXFx1MjkzOVwiLCBsYXJyc2ltOiBcIlxcdTI5NzNcIiwgbGFycnRsOiBcIlxcdTIxQTJcIiwgbGF0YWlsOiBcIlxcdTI5MTlcIiwgbEF0YWlsOiBcIlxcdTI5MUJcIiwgbGF0OiBcIlxcdTJBQUJcIiwgbGF0ZTogXCJcXHUyQUFEXCIsIGxhdGVzOiBcIlxcdTJBQURcXHVGRTAwXCIsIGxiYXJyOiBcIlxcdTI5MENcIiwgbEJhcnI6IFwiXFx1MjkwRVwiLCBsYmJyazogXCJcXHUyNzcyXCIsIGxicmFjZTogXCJ7XCIsIGxicmFjazogXCJbXCIsIGxicmtlOiBcIlxcdTI5OEJcIiwgbGJya3NsZDogXCJcXHUyOThGXCIsIGxicmtzbHU6IFwiXFx1Mjk4RFwiLCBMY2Fyb246IFwiXFx1MDEzRFwiLCBsY2Fyb246IFwiXFx1MDEzRVwiLCBMY2VkaWw6IFwiXFx1MDEzQlwiLCBsY2VkaWw6IFwiXFx1MDEzQ1wiLCBsY2VpbDogXCJcXHUyMzA4XCIsIGxjdWI6IFwie1wiLCBMY3k6IFwiXFx1MDQxQlwiLCBsY3k6IFwiXFx1MDQzQlwiLCBsZGNhOiBcIlxcdTI5MzZcIiwgbGRxdW86IFwiXFx1MjAxQ1wiLCBsZHF1b3I6IFwiXFx1MjAxRVwiLCBsZHJkaGFyOiBcIlxcdTI5NjdcIiwgbGRydXNoYXI6IFwiXFx1Mjk0QlwiLCBsZHNoOiBcIlxcdTIxQjJcIiwgbGU6IFwiXFx1MjI2NFwiLCBsRTogXCJcXHUyMjY2XCIsIExlZnRBbmdsZUJyYWNrZXQ6IFwiXFx1MjdFOFwiLCBMZWZ0QXJyb3dCYXI6IFwiXFx1MjFFNFwiLCBsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLCBMZWZ0QXJyb3c6IFwiXFx1MjE5MFwiLCBMZWZ0YXJyb3c6IFwiXFx1MjFEMFwiLCBMZWZ0QXJyb3dSaWdodEFycm93OiBcIlxcdTIxQzZcIiwgbGVmdGFycm93dGFpbDogXCJcXHUyMUEyXCIsIExlZnRDZWlsaW5nOiBcIlxcdTIzMDhcIiwgTGVmdERvdWJsZUJyYWNrZXQ6IFwiXFx1MjdFNlwiLCBMZWZ0RG93blRlZVZlY3RvcjogXCJcXHUyOTYxXCIsIExlZnREb3duVmVjdG9yQmFyOiBcIlxcdTI5NTlcIiwgTGVmdERvd25WZWN0b3I6IFwiXFx1MjFDM1wiLCBMZWZ0Rmxvb3I6IFwiXFx1MjMwQVwiLCBsZWZ0aGFycG9vbmRvd246IFwiXFx1MjFCRFwiLCBsZWZ0aGFycG9vbnVwOiBcIlxcdTIxQkNcIiwgbGVmdGxlZnRhcnJvd3M6IFwiXFx1MjFDN1wiLCBsZWZ0cmlnaHRhcnJvdzogXCJcXHUyMTk0XCIsIExlZnRSaWdodEFycm93OiBcIlxcdTIxOTRcIiwgTGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjFENFwiLCBsZWZ0cmlnaHRhcnJvd3M6IFwiXFx1MjFDNlwiLCBsZWZ0cmlnaHRoYXJwb29uczogXCJcXHUyMUNCXCIsIGxlZnRyaWdodHNxdWlnYXJyb3c6IFwiXFx1MjFBRFwiLCBMZWZ0UmlnaHRWZWN0b3I6IFwiXFx1Mjk0RVwiLCBMZWZ0VGVlQXJyb3c6IFwiXFx1MjFBNFwiLCBMZWZ0VGVlOiBcIlxcdTIyQTNcIiwgTGVmdFRlZVZlY3RvcjogXCJcXHUyOTVBXCIsIGxlZnR0aHJlZXRpbWVzOiBcIlxcdTIyQ0JcIiwgTGVmdFRyaWFuZ2xlQmFyOiBcIlxcdTI5Q0ZcIiwgTGVmdFRyaWFuZ2xlOiBcIlxcdTIyQjJcIiwgTGVmdFRyaWFuZ2xlRXF1YWw6IFwiXFx1MjJCNFwiLCBMZWZ0VXBEb3duVmVjdG9yOiBcIlxcdTI5NTFcIiwgTGVmdFVwVGVlVmVjdG9yOiBcIlxcdTI5NjBcIiwgTGVmdFVwVmVjdG9yQmFyOiBcIlxcdTI5NThcIiwgTGVmdFVwVmVjdG9yOiBcIlxcdTIxQkZcIiwgTGVmdFZlY3RvckJhcjogXCJcXHUyOTUyXCIsIExlZnRWZWN0b3I6IFwiXFx1MjFCQ1wiLCBsRWc6IFwiXFx1MkE4QlwiLCBsZWc6IFwiXFx1MjJEQVwiLCBsZXE6IFwiXFx1MjI2NFwiLCBsZXFxOiBcIlxcdTIyNjZcIiwgbGVxc2xhbnQ6IFwiXFx1MkE3RFwiLCBsZXNjYzogXCJcXHUyQUE4XCIsIGxlczogXCJcXHUyQTdEXCIsIGxlc2RvdDogXCJcXHUyQTdGXCIsIGxlc2RvdG86IFwiXFx1MkE4MVwiLCBsZXNkb3RvcjogXCJcXHUyQTgzXCIsIGxlc2c6IFwiXFx1MjJEQVxcdUZFMDBcIiwgbGVzZ2VzOiBcIlxcdTJBOTNcIiwgbGVzc2FwcHJveDogXCJcXHUyQTg1XCIsIGxlc3Nkb3Q6IFwiXFx1MjJENlwiLCBsZXNzZXFndHI6IFwiXFx1MjJEQVwiLCBsZXNzZXFxZ3RyOiBcIlxcdTJBOEJcIiwgTGVzc0VxdWFsR3JlYXRlcjogXCJcXHUyMkRBXCIsIExlc3NGdWxsRXF1YWw6IFwiXFx1MjI2NlwiLCBMZXNzR3JlYXRlcjogXCJcXHUyMjc2XCIsIGxlc3NndHI6IFwiXFx1MjI3NlwiLCBMZXNzTGVzczogXCJcXHUyQUExXCIsIGxlc3NzaW06IFwiXFx1MjI3MlwiLCBMZXNzU2xhbnRFcXVhbDogXCJcXHUyQTdEXCIsIExlc3NUaWxkZTogXCJcXHUyMjcyXCIsIGxmaXNodDogXCJcXHUyOTdDXCIsIGxmbG9vcjogXCJcXHUyMzBBXCIsIExmcjogXCJcXHV7MUQ1MEZ9XCIsIGxmcjogXCJcXHV7MUQ1Mjl9XCIsIGxnOiBcIlxcdTIyNzZcIiwgbGdFOiBcIlxcdTJBOTFcIiwgbEhhcjogXCJcXHUyOTYyXCIsIGxoYXJkOiBcIlxcdTIxQkRcIiwgbGhhcnU6IFwiXFx1MjFCQ1wiLCBsaGFydWw6IFwiXFx1Mjk2QVwiLCBsaGJsazogXCJcXHUyNTg0XCIsIExKY3k6IFwiXFx1MDQwOVwiLCBsamN5OiBcIlxcdTA0NTlcIiwgbGxhcnI6IFwiXFx1MjFDN1wiLCBsbDogXCJcXHUyMjZBXCIsIExsOiBcIlxcdTIyRDhcIiwgbGxjb3JuZXI6IFwiXFx1MjMxRVwiLCBMbGVmdGFycm93OiBcIlxcdTIxREFcIiwgbGxoYXJkOiBcIlxcdTI5NkJcIiwgbGx0cmk6IFwiXFx1MjVGQVwiLCBMbWlkb3Q6IFwiXFx1MDEzRlwiLCBsbWlkb3Q6IFwiXFx1MDE0MFwiLCBsbW91c3RhY2hlOiBcIlxcdTIzQjBcIiwgbG1vdXN0OiBcIlxcdTIzQjBcIiwgbG5hcDogXCJcXHUyQTg5XCIsIGxuYXBwcm94OiBcIlxcdTJBODlcIiwgbG5lOiBcIlxcdTJBODdcIiwgbG5FOiBcIlxcdTIyNjhcIiwgbG5lcTogXCJcXHUyQTg3XCIsIGxuZXFxOiBcIlxcdTIyNjhcIiwgbG5zaW06IFwiXFx1MjJFNlwiLCBsb2FuZzogXCJcXHUyN0VDXCIsIGxvYXJyOiBcIlxcdTIxRkRcIiwgbG9icms6IFwiXFx1MjdFNlwiLCBsb25nbGVmdGFycm93OiBcIlxcdTI3RjVcIiwgTG9uZ0xlZnRBcnJvdzogXCJcXHUyN0Y1XCIsIExvbmdsZWZ0YXJyb3c6IFwiXFx1MjdGOFwiLCBsb25nbGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjdGN1wiLCBMb25nTGVmdFJpZ2h0QXJyb3c6IFwiXFx1MjdGN1wiLCBMb25nbGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjdGQVwiLCBsb25nbWFwc3RvOiBcIlxcdTI3RkNcIiwgbG9uZ3JpZ2h0YXJyb3c6IFwiXFx1MjdGNlwiLCBMb25nUmlnaHRBcnJvdzogXCJcXHUyN0Y2XCIsIExvbmdyaWdodGFycm93OiBcIlxcdTI3RjlcIiwgbG9vcGFycm93bGVmdDogXCJcXHUyMUFCXCIsIGxvb3BhcnJvd3JpZ2h0OiBcIlxcdTIxQUNcIiwgbG9wYXI6IFwiXFx1Mjk4NVwiLCBMb3BmOiBcIlxcdXsxRDU0M31cIiwgbG9wZjogXCJcXHV7MUQ1NUR9XCIsIGxvcGx1czogXCJcXHUyQTJEXCIsIGxvdGltZXM6IFwiXFx1MkEzNFwiLCBsb3dhc3Q6IFwiXFx1MjIxN1wiLCBsb3diYXI6IFwiX1wiLCBMb3dlckxlZnRBcnJvdzogXCJcXHUyMTk5XCIsIExvd2VyUmlnaHRBcnJvdzogXCJcXHUyMTk4XCIsIGxvejogXCJcXHUyNUNBXCIsIGxvemVuZ2U6IFwiXFx1MjVDQVwiLCBsb3pmOiBcIlxcdTI5RUJcIiwgbHBhcjogXCIoXCIsIGxwYXJsdDogXCJcXHUyOTkzXCIsIGxyYXJyOiBcIlxcdTIxQzZcIiwgbHJjb3JuZXI6IFwiXFx1MjMxRlwiLCBscmhhcjogXCJcXHUyMUNCXCIsIGxyaGFyZDogXCJcXHUyOTZEXCIsIGxybTogXCJcXHUyMDBFXCIsIGxydHJpOiBcIlxcdTIyQkZcIiwgbHNhcXVvOiBcIlxcdTIwMzlcIiwgbHNjcjogXCJcXHV7MUQ0QzF9XCIsIExzY3I6IFwiXFx1MjExMlwiLCBsc2g6IFwiXFx1MjFCMFwiLCBMc2g6IFwiXFx1MjFCMFwiLCBsc2ltOiBcIlxcdTIyNzJcIiwgbHNpbWU6IFwiXFx1MkE4RFwiLCBsc2ltZzogXCJcXHUyQThGXCIsIGxzcWI6IFwiW1wiLCBsc3F1bzogXCJcXHUyMDE4XCIsIGxzcXVvcjogXCJcXHUyMDFBXCIsIExzdHJvazogXCJcXHUwMTQxXCIsIGxzdHJvazogXCJcXHUwMTQyXCIsIGx0Y2M6IFwiXFx1MkFBNlwiLCBsdGNpcjogXCJcXHUyQTc5XCIsIGx0OiBcIjxcIiwgTFQ6IFwiPFwiLCBMdDogXCJcXHUyMjZBXCIsIGx0ZG90OiBcIlxcdTIyRDZcIiwgbHRocmVlOiBcIlxcdTIyQ0JcIiwgbHRpbWVzOiBcIlxcdTIyQzlcIiwgbHRsYXJyOiBcIlxcdTI5NzZcIiwgbHRxdWVzdDogXCJcXHUyQTdCXCIsIGx0cmk6IFwiXFx1MjVDM1wiLCBsdHJpZTogXCJcXHUyMkI0XCIsIGx0cmlmOiBcIlxcdTI1QzJcIiwgbHRyUGFyOiBcIlxcdTI5OTZcIiwgbHVyZHNoYXI6IFwiXFx1Mjk0QVwiLCBsdXJ1aGFyOiBcIlxcdTI5NjZcIiwgbHZlcnRuZXFxOiBcIlxcdTIyNjhcXHVGRTAwXCIsIGx2bkU6IFwiXFx1MjI2OFxcdUZFMDBcIiwgbWFjcjogXCJcXHhBRlwiLCBtYWxlOiBcIlxcdTI2NDJcIiwgbWFsdDogXCJcXHUyNzIwXCIsIG1hbHRlc2U6IFwiXFx1MjcyMFwiLCBNYXA6IFwiXFx1MjkwNVwiLCBtYXA6IFwiXFx1MjFBNlwiLCBtYXBzdG86IFwiXFx1MjFBNlwiLCBtYXBzdG9kb3duOiBcIlxcdTIxQTdcIiwgbWFwc3RvbGVmdDogXCJcXHUyMUE0XCIsIG1hcHN0b3VwOiBcIlxcdTIxQTVcIiwgbWFya2VyOiBcIlxcdTI1QUVcIiwgbWNvbW1hOiBcIlxcdTJBMjlcIiwgTWN5OiBcIlxcdTA0MUNcIiwgbWN5OiBcIlxcdTA0M0NcIiwgbWRhc2g6IFwiXFx1MjAxNFwiLCBtRERvdDogXCJcXHUyMjNBXCIsIG1lYXN1cmVkYW5nbGU6IFwiXFx1MjIyMVwiLCBNZWRpdW1TcGFjZTogXCJcXHUyMDVGXCIsIE1lbGxpbnRyZjogXCJcXHUyMTMzXCIsIE1mcjogXCJcXHV7MUQ1MTB9XCIsIG1mcjogXCJcXHV7MUQ1MkF9XCIsIG1obzogXCJcXHUyMTI3XCIsIG1pY3JvOiBcIlxceEI1XCIsIG1pZGFzdDogXCIqXCIsIG1pZGNpcjogXCJcXHUyQUYwXCIsIG1pZDogXCJcXHUyMjIzXCIsIG1pZGRvdDogXCJcXHhCN1wiLCBtaW51c2I6IFwiXFx1MjI5RlwiLCBtaW51czogXCJcXHUyMjEyXCIsIG1pbnVzZDogXCJcXHUyMjM4XCIsIG1pbnVzZHU6IFwiXFx1MkEyQVwiLCBNaW51c1BsdXM6IFwiXFx1MjIxM1wiLCBtbGNwOiBcIlxcdTJBREJcIiwgbWxkcjogXCJcXHUyMDI2XCIsIG1ucGx1czogXCJcXHUyMjEzXCIsIG1vZGVsczogXCJcXHUyMkE3XCIsIE1vcGY6IFwiXFx1ezFENTQ0fVwiLCBtb3BmOiBcIlxcdXsxRDU1RX1cIiwgbXA6IFwiXFx1MjIxM1wiLCBtc2NyOiBcIlxcdXsxRDRDMn1cIiwgTXNjcjogXCJcXHUyMTMzXCIsIG1zdHBvczogXCJcXHUyMjNFXCIsIE11OiBcIlxcdTAzOUNcIiwgbXU6IFwiXFx1MDNCQ1wiLCBtdWx0aW1hcDogXCJcXHUyMkI4XCIsIG11bWFwOiBcIlxcdTIyQjhcIiwgbmFibGE6IFwiXFx1MjIwN1wiLCBOYWN1dGU6IFwiXFx1MDE0M1wiLCBuYWN1dGU6IFwiXFx1MDE0NFwiLCBuYW5nOiBcIlxcdTIyMjBcXHUyMEQyXCIsIG5hcDogXCJcXHUyMjQ5XCIsIG5hcEU6IFwiXFx1MkE3MFxcdTAzMzhcIiwgbmFwaWQ6IFwiXFx1MjI0QlxcdTAzMzhcIiwgbmFwb3M6IFwiXFx1MDE0OVwiLCBuYXBwcm94OiBcIlxcdTIyNDlcIiwgbmF0dXJhbDogXCJcXHUyNjZFXCIsIG5hdHVyYWxzOiBcIlxcdTIxMTVcIiwgbmF0dXI6IFwiXFx1MjY2RVwiLCBuYnNwOiBcIlxceEEwXCIsIG5idW1wOiBcIlxcdTIyNEVcXHUwMzM4XCIsIG5idW1wZTogXCJcXHUyMjRGXFx1MDMzOFwiLCBuY2FwOiBcIlxcdTJBNDNcIiwgTmNhcm9uOiBcIlxcdTAxNDdcIiwgbmNhcm9uOiBcIlxcdTAxNDhcIiwgTmNlZGlsOiBcIlxcdTAxNDVcIiwgbmNlZGlsOiBcIlxcdTAxNDZcIiwgbmNvbmc6IFwiXFx1MjI0N1wiLCBuY29uZ2RvdDogXCJcXHUyQTZEXFx1MDMzOFwiLCBuY3VwOiBcIlxcdTJBNDJcIiwgTmN5OiBcIlxcdTA0MURcIiwgbmN5OiBcIlxcdTA0M0RcIiwgbmRhc2g6IFwiXFx1MjAxM1wiLCBuZWFyaGs6IFwiXFx1MjkyNFwiLCBuZWFycjogXCJcXHUyMTk3XCIsIG5lQXJyOiBcIlxcdTIxRDdcIiwgbmVhcnJvdzogXCJcXHUyMTk3XCIsIG5lOiBcIlxcdTIyNjBcIiwgbmVkb3Q6IFwiXFx1MjI1MFxcdTAzMzhcIiwgTmVnYXRpdmVNZWRpdW1TcGFjZTogXCJcXHUyMDBCXCIsIE5lZ2F0aXZlVGhpY2tTcGFjZTogXCJcXHUyMDBCXCIsIE5lZ2F0aXZlVGhpblNwYWNlOiBcIlxcdTIwMEJcIiwgTmVnYXRpdmVWZXJ5VGhpblNwYWNlOiBcIlxcdTIwMEJcIiwgbmVxdWl2OiBcIlxcdTIyNjJcIiwgbmVzZWFyOiBcIlxcdTI5MjhcIiwgbmVzaW06IFwiXFx1MjI0MlxcdTAzMzhcIiwgTmVzdGVkR3JlYXRlckdyZWF0ZXI6IFwiXFx1MjI2QlwiLCBOZXN0ZWRMZXNzTGVzczogXCJcXHUyMjZBXCIsIE5ld0xpbmU6IFwiXFxuXCIsIG5leGlzdDogXCJcXHUyMjA0XCIsIG5leGlzdHM6IFwiXFx1MjIwNFwiLCBOZnI6IFwiXFx1ezFENTExfVwiLCBuZnI6IFwiXFx1ezFENTJCfVwiLCBuZ0U6IFwiXFx1MjI2N1xcdTAzMzhcIiwgbmdlOiBcIlxcdTIyNzFcIiwgbmdlcTogXCJcXHUyMjcxXCIsIG5nZXFxOiBcIlxcdTIyNjdcXHUwMzM4XCIsIG5nZXFzbGFudDogXCJcXHUyQTdFXFx1MDMzOFwiLCBuZ2VzOiBcIlxcdTJBN0VcXHUwMzM4XCIsIG5HZzogXCJcXHUyMkQ5XFx1MDMzOFwiLCBuZ3NpbTogXCJcXHUyMjc1XCIsIG5HdDogXCJcXHUyMjZCXFx1MjBEMlwiLCBuZ3Q6IFwiXFx1MjI2RlwiLCBuZ3RyOiBcIlxcdTIyNkZcIiwgbkd0djogXCJcXHUyMjZCXFx1MDMzOFwiLCBuaGFycjogXCJcXHUyMUFFXCIsIG5oQXJyOiBcIlxcdTIxQ0VcIiwgbmhwYXI6IFwiXFx1MkFGMlwiLCBuaTogXCJcXHUyMjBCXCIsIG5pczogXCJcXHUyMkZDXCIsIG5pc2Q6IFwiXFx1MjJGQVwiLCBuaXY6IFwiXFx1MjIwQlwiLCBOSmN5OiBcIlxcdTA0MEFcIiwgbmpjeTogXCJcXHUwNDVBXCIsIG5sYXJyOiBcIlxcdTIxOUFcIiwgbmxBcnI6IFwiXFx1MjFDRFwiLCBubGRyOiBcIlxcdTIwMjVcIiwgbmxFOiBcIlxcdTIyNjZcXHUwMzM4XCIsIG5sZTogXCJcXHUyMjcwXCIsIG5sZWZ0YXJyb3c6IFwiXFx1MjE5QVwiLCBuTGVmdGFycm93OiBcIlxcdTIxQ0RcIiwgbmxlZnRyaWdodGFycm93OiBcIlxcdTIxQUVcIiwgbkxlZnRyaWdodGFycm93OiBcIlxcdTIxQ0VcIiwgbmxlcTogXCJcXHUyMjcwXCIsIG5sZXFxOiBcIlxcdTIyNjZcXHUwMzM4XCIsIG5sZXFzbGFudDogXCJcXHUyQTdEXFx1MDMzOFwiLCBubGVzOiBcIlxcdTJBN0RcXHUwMzM4XCIsIG5sZXNzOiBcIlxcdTIyNkVcIiwgbkxsOiBcIlxcdTIyRDhcXHUwMzM4XCIsIG5sc2ltOiBcIlxcdTIyNzRcIiwgbkx0OiBcIlxcdTIyNkFcXHUyMEQyXCIsIG5sdDogXCJcXHUyMjZFXCIsIG5sdHJpOiBcIlxcdTIyRUFcIiwgbmx0cmllOiBcIlxcdTIyRUNcIiwgbkx0djogXCJcXHUyMjZBXFx1MDMzOFwiLCBubWlkOiBcIlxcdTIyMjRcIiwgTm9CcmVhazogXCJcXHUyMDYwXCIsIE5vbkJyZWFraW5nU3BhY2U6IFwiXFx4QTBcIiwgbm9wZjogXCJcXHV7MUQ1NUZ9XCIsIE5vcGY6IFwiXFx1MjExNVwiLCBOb3Q6IFwiXFx1MkFFQ1wiLCBub3Q6IFwiXFx4QUNcIiwgTm90Q29uZ3J1ZW50OiBcIlxcdTIyNjJcIiwgTm90Q3VwQ2FwOiBcIlxcdTIyNkRcIiwgTm90RG91YmxlVmVydGljYWxCYXI6IFwiXFx1MjIyNlwiLCBOb3RFbGVtZW50OiBcIlxcdTIyMDlcIiwgTm90RXF1YWw6IFwiXFx1MjI2MFwiLCBOb3RFcXVhbFRpbGRlOiBcIlxcdTIyNDJcXHUwMzM4XCIsIE5vdEV4aXN0czogXCJcXHUyMjA0XCIsIE5vdEdyZWF0ZXI6IFwiXFx1MjI2RlwiLCBOb3RHcmVhdGVyRXF1YWw6IFwiXFx1MjI3MVwiLCBOb3RHcmVhdGVyRnVsbEVxdWFsOiBcIlxcdTIyNjdcXHUwMzM4XCIsIE5vdEdyZWF0ZXJHcmVhdGVyOiBcIlxcdTIyNkJcXHUwMzM4XCIsIE5vdEdyZWF0ZXJMZXNzOiBcIlxcdTIyNzlcIiwgTm90R3JlYXRlclNsYW50RXF1YWw6IFwiXFx1MkE3RVxcdTAzMzhcIiwgTm90R3JlYXRlclRpbGRlOiBcIlxcdTIyNzVcIiwgTm90SHVtcERvd25IdW1wOiBcIlxcdTIyNEVcXHUwMzM4XCIsIE5vdEh1bXBFcXVhbDogXCJcXHUyMjRGXFx1MDMzOFwiLCBub3RpbjogXCJcXHUyMjA5XCIsIG5vdGluZG90OiBcIlxcdTIyRjVcXHUwMzM4XCIsIG5vdGluRTogXCJcXHUyMkY5XFx1MDMzOFwiLCBub3RpbnZhOiBcIlxcdTIyMDlcIiwgbm90aW52YjogXCJcXHUyMkY3XCIsIG5vdGludmM6IFwiXFx1MjJGNlwiLCBOb3RMZWZ0VHJpYW5nbGVCYXI6IFwiXFx1MjlDRlxcdTAzMzhcIiwgTm90TGVmdFRyaWFuZ2xlOiBcIlxcdTIyRUFcIiwgTm90TGVmdFRyaWFuZ2xlRXF1YWw6IFwiXFx1MjJFQ1wiLCBOb3RMZXNzOiBcIlxcdTIyNkVcIiwgTm90TGVzc0VxdWFsOiBcIlxcdTIyNzBcIiwgTm90TGVzc0dyZWF0ZXI6IFwiXFx1MjI3OFwiLCBOb3RMZXNzTGVzczogXCJcXHUyMjZBXFx1MDMzOFwiLCBOb3RMZXNzU2xhbnRFcXVhbDogXCJcXHUyQTdEXFx1MDMzOFwiLCBOb3RMZXNzVGlsZGU6IFwiXFx1MjI3NFwiLCBOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcjogXCJcXHUyQUEyXFx1MDMzOFwiLCBOb3ROZXN0ZWRMZXNzTGVzczogXCJcXHUyQUExXFx1MDMzOFwiLCBub3RuaTogXCJcXHUyMjBDXCIsIG5vdG5pdmE6IFwiXFx1MjIwQ1wiLCBub3RuaXZiOiBcIlxcdTIyRkVcIiwgbm90bml2YzogXCJcXHUyMkZEXCIsIE5vdFByZWNlZGVzOiBcIlxcdTIyODBcIiwgTm90UHJlY2VkZXNFcXVhbDogXCJcXHUyQUFGXFx1MDMzOFwiLCBOb3RQcmVjZWRlc1NsYW50RXF1YWw6IFwiXFx1MjJFMFwiLCBOb3RSZXZlcnNlRWxlbWVudDogXCJcXHUyMjBDXCIsIE5vdFJpZ2h0VHJpYW5nbGVCYXI6IFwiXFx1MjlEMFxcdTAzMzhcIiwgTm90UmlnaHRUcmlhbmdsZTogXCJcXHUyMkVCXCIsIE5vdFJpZ2h0VHJpYW5nbGVFcXVhbDogXCJcXHUyMkVEXCIsIE5vdFNxdWFyZVN1YnNldDogXCJcXHUyMjhGXFx1MDMzOFwiLCBOb3RTcXVhcmVTdWJzZXRFcXVhbDogXCJcXHUyMkUyXCIsIE5vdFNxdWFyZVN1cGVyc2V0OiBcIlxcdTIyOTBcXHUwMzM4XCIsIE5vdFNxdWFyZVN1cGVyc2V0RXF1YWw6IFwiXFx1MjJFM1wiLCBOb3RTdWJzZXQ6IFwiXFx1MjI4MlxcdTIwRDJcIiwgTm90U3Vic2V0RXF1YWw6IFwiXFx1MjI4OFwiLCBOb3RTdWNjZWVkczogXCJcXHUyMjgxXCIsIE5vdFN1Y2NlZWRzRXF1YWw6IFwiXFx1MkFCMFxcdTAzMzhcIiwgTm90U3VjY2VlZHNTbGFudEVxdWFsOiBcIlxcdTIyRTFcIiwgTm90U3VjY2VlZHNUaWxkZTogXCJcXHUyMjdGXFx1MDMzOFwiLCBOb3RTdXBlcnNldDogXCJcXHUyMjgzXFx1MjBEMlwiLCBOb3RTdXBlcnNldEVxdWFsOiBcIlxcdTIyODlcIiwgTm90VGlsZGU6IFwiXFx1MjI0MVwiLCBOb3RUaWxkZUVxdWFsOiBcIlxcdTIyNDRcIiwgTm90VGlsZGVGdWxsRXF1YWw6IFwiXFx1MjI0N1wiLCBOb3RUaWxkZVRpbGRlOiBcIlxcdTIyNDlcIiwgTm90VmVydGljYWxCYXI6IFwiXFx1MjIyNFwiLCBucGFyYWxsZWw6IFwiXFx1MjIyNlwiLCBucGFyOiBcIlxcdTIyMjZcIiwgbnBhcnNsOiBcIlxcdTJBRkRcXHUyMEU1XCIsIG5wYXJ0OiBcIlxcdTIyMDJcXHUwMzM4XCIsIG5wb2xpbnQ6IFwiXFx1MkExNFwiLCBucHI6IFwiXFx1MjI4MFwiLCBucHJjdWU6IFwiXFx1MjJFMFwiLCBucHJlYzogXCJcXHUyMjgwXCIsIG5wcmVjZXE6IFwiXFx1MkFBRlxcdTAzMzhcIiwgbnByZTogXCJcXHUyQUFGXFx1MDMzOFwiLCBucmFycmM6IFwiXFx1MjkzM1xcdTAzMzhcIiwgbnJhcnI6IFwiXFx1MjE5QlwiLCBuckFycjogXCJcXHUyMUNGXCIsIG5yYXJydzogXCJcXHUyMTlEXFx1MDMzOFwiLCBucmlnaHRhcnJvdzogXCJcXHUyMTlCXCIsIG5SaWdodGFycm93OiBcIlxcdTIxQ0ZcIiwgbnJ0cmk6IFwiXFx1MjJFQlwiLCBucnRyaWU6IFwiXFx1MjJFRFwiLCBuc2M6IFwiXFx1MjI4MVwiLCBuc2NjdWU6IFwiXFx1MjJFMVwiLCBuc2NlOiBcIlxcdTJBQjBcXHUwMzM4XCIsIE5zY3I6IFwiXFx1ezFENEE5fVwiLCBuc2NyOiBcIlxcdXsxRDRDM31cIiwgbnNob3J0bWlkOiBcIlxcdTIyMjRcIiwgbnNob3J0cGFyYWxsZWw6IFwiXFx1MjIyNlwiLCBuc2ltOiBcIlxcdTIyNDFcIiwgbnNpbWU6IFwiXFx1MjI0NFwiLCBuc2ltZXE6IFwiXFx1MjI0NFwiLCBuc21pZDogXCJcXHUyMjI0XCIsIG5zcGFyOiBcIlxcdTIyMjZcIiwgbnNxc3ViZTogXCJcXHUyMkUyXCIsIG5zcXN1cGU6IFwiXFx1MjJFM1wiLCBuc3ViOiBcIlxcdTIyODRcIiwgbnN1YkU6IFwiXFx1MkFDNVxcdTAzMzhcIiwgbnN1YmU6IFwiXFx1MjI4OFwiLCBuc3Vic2V0OiBcIlxcdTIyODJcXHUyMEQyXCIsIG5zdWJzZXRlcTogXCJcXHUyMjg4XCIsIG5zdWJzZXRlcXE6IFwiXFx1MkFDNVxcdTAzMzhcIiwgbnN1Y2M6IFwiXFx1MjI4MVwiLCBuc3VjY2VxOiBcIlxcdTJBQjBcXHUwMzM4XCIsIG5zdXA6IFwiXFx1MjI4NVwiLCBuc3VwRTogXCJcXHUyQUM2XFx1MDMzOFwiLCBuc3VwZTogXCJcXHUyMjg5XCIsIG5zdXBzZXQ6IFwiXFx1MjI4M1xcdTIwRDJcIiwgbnN1cHNldGVxOiBcIlxcdTIyODlcIiwgbnN1cHNldGVxcTogXCJcXHUyQUM2XFx1MDMzOFwiLCBudGdsOiBcIlxcdTIyNzlcIiwgTnRpbGRlOiBcIlxceEQxXCIsIG50aWxkZTogXCJcXHhGMVwiLCBudGxnOiBcIlxcdTIyNzhcIiwgbnRyaWFuZ2xlbGVmdDogXCJcXHUyMkVBXCIsIG50cmlhbmdsZWxlZnRlcTogXCJcXHUyMkVDXCIsIG50cmlhbmdsZXJpZ2h0OiBcIlxcdTIyRUJcIiwgbnRyaWFuZ2xlcmlnaHRlcTogXCJcXHUyMkVEXCIsIE51OiBcIlxcdTAzOURcIiwgbnU6IFwiXFx1MDNCRFwiLCBudW06IFwiI1wiLCBudW1lcm86IFwiXFx1MjExNlwiLCBudW1zcDogXCJcXHUyMDA3XCIsIG52YXA6IFwiXFx1MjI0RFxcdTIwRDJcIiwgbnZkYXNoOiBcIlxcdTIyQUNcIiwgbnZEYXNoOiBcIlxcdTIyQURcIiwgblZkYXNoOiBcIlxcdTIyQUVcIiwgblZEYXNoOiBcIlxcdTIyQUZcIiwgbnZnZTogXCJcXHUyMjY1XFx1MjBEMlwiLCBudmd0OiBcIj5cXHUyMEQyXCIsIG52SGFycjogXCJcXHUyOTA0XCIsIG52aW5maW46IFwiXFx1MjlERVwiLCBudmxBcnI6IFwiXFx1MjkwMlwiLCBudmxlOiBcIlxcdTIyNjRcXHUyMEQyXCIsIG52bHQ6IFwiPFxcdTIwRDJcIiwgbnZsdHJpZTogXCJcXHUyMkI0XFx1MjBEMlwiLCBudnJBcnI6IFwiXFx1MjkwM1wiLCBudnJ0cmllOiBcIlxcdTIyQjVcXHUyMEQyXCIsIG52c2ltOiBcIlxcdTIyM0NcXHUyMEQyXCIsIG53YXJoazogXCJcXHUyOTIzXCIsIG53YXJyOiBcIlxcdTIxOTZcIiwgbndBcnI6IFwiXFx1MjFENlwiLCBud2Fycm93OiBcIlxcdTIxOTZcIiwgbnduZWFyOiBcIlxcdTI5MjdcIiwgT2FjdXRlOiBcIlxceEQzXCIsIG9hY3V0ZTogXCJcXHhGM1wiLCBvYXN0OiBcIlxcdTIyOUJcIiwgT2NpcmM6IFwiXFx4RDRcIiwgb2NpcmM6IFwiXFx4RjRcIiwgb2NpcjogXCJcXHUyMjlBXCIsIE9jeTogXCJcXHUwNDFFXCIsIG9jeTogXCJcXHUwNDNFXCIsIG9kYXNoOiBcIlxcdTIyOURcIiwgT2RibGFjOiBcIlxcdTAxNTBcIiwgb2RibGFjOiBcIlxcdTAxNTFcIiwgb2RpdjogXCJcXHUyQTM4XCIsIG9kb3Q6IFwiXFx1MjI5OVwiLCBvZHNvbGQ6IFwiXFx1MjlCQ1wiLCBPRWxpZzogXCJcXHUwMTUyXCIsIG9lbGlnOiBcIlxcdTAxNTNcIiwgb2ZjaXI6IFwiXFx1MjlCRlwiLCBPZnI6IFwiXFx1ezFENTEyfVwiLCBvZnI6IFwiXFx1ezFENTJDfVwiLCBvZ29uOiBcIlxcdTAyREJcIiwgT2dyYXZlOiBcIlxceEQyXCIsIG9ncmF2ZTogXCJcXHhGMlwiLCBvZ3Q6IFwiXFx1MjlDMVwiLCBvaGJhcjogXCJcXHUyOUI1XCIsIG9obTogXCJcXHUwM0E5XCIsIG9pbnQ6IFwiXFx1MjIyRVwiLCBvbGFycjogXCJcXHUyMUJBXCIsIG9sY2lyOiBcIlxcdTI5QkVcIiwgb2xjcm9zczogXCJcXHUyOUJCXCIsIG9saW5lOiBcIlxcdTIwM0VcIiwgb2x0OiBcIlxcdTI5QzBcIiwgT21hY3I6IFwiXFx1MDE0Q1wiLCBvbWFjcjogXCJcXHUwMTREXCIsIE9tZWdhOiBcIlxcdTAzQTlcIiwgb21lZ2E6IFwiXFx1MDNDOVwiLCBPbWljcm9uOiBcIlxcdTAzOUZcIiwgb21pY3JvbjogXCJcXHUwM0JGXCIsIG9taWQ6IFwiXFx1MjlCNlwiLCBvbWludXM6IFwiXFx1MjI5NlwiLCBPb3BmOiBcIlxcdXsxRDU0Nn1cIiwgb29wZjogXCJcXHV7MUQ1NjB9XCIsIG9wYXI6IFwiXFx1MjlCN1wiLCBPcGVuQ3VybHlEb3VibGVRdW90ZTogXCJcXHUyMDFDXCIsIE9wZW5DdXJseVF1b3RlOiBcIlxcdTIwMThcIiwgb3BlcnA6IFwiXFx1MjlCOVwiLCBvcGx1czogXCJcXHUyMjk1XCIsIG9yYXJyOiBcIlxcdTIxQkJcIiwgT3I6IFwiXFx1MkE1NFwiLCBvcjogXCJcXHUyMjI4XCIsIG9yZDogXCJcXHUyQTVEXCIsIG9yZGVyOiBcIlxcdTIxMzRcIiwgb3JkZXJvZjogXCJcXHUyMTM0XCIsIG9yZGY6IFwiXFx4QUFcIiwgb3JkbTogXCJcXHhCQVwiLCBvcmlnb2Y6IFwiXFx1MjJCNlwiLCBvcm9yOiBcIlxcdTJBNTZcIiwgb3JzbG9wZTogXCJcXHUyQTU3XCIsIG9ydjogXCJcXHUyQTVCXCIsIG9TOiBcIlxcdTI0QzhcIiwgT3NjcjogXCJcXHV7MUQ0QUF9XCIsIG9zY3I6IFwiXFx1MjEzNFwiLCBPc2xhc2g6IFwiXFx4RDhcIiwgb3NsYXNoOiBcIlxceEY4XCIsIG9zb2w6IFwiXFx1MjI5OFwiLCBPdGlsZGU6IFwiXFx4RDVcIiwgb3RpbGRlOiBcIlxceEY1XCIsIG90aW1lc2FzOiBcIlxcdTJBMzZcIiwgT3RpbWVzOiBcIlxcdTJBMzdcIiwgb3RpbWVzOiBcIlxcdTIyOTdcIiwgT3VtbDogXCJcXHhENlwiLCBvdW1sOiBcIlxceEY2XCIsIG92YmFyOiBcIlxcdTIzM0RcIiwgT3ZlckJhcjogXCJcXHUyMDNFXCIsIE92ZXJCcmFjZTogXCJcXHUyM0RFXCIsIE92ZXJCcmFja2V0OiBcIlxcdTIzQjRcIiwgT3ZlclBhcmVudGhlc2lzOiBcIlxcdTIzRENcIiwgcGFyYTogXCJcXHhCNlwiLCBwYXJhbGxlbDogXCJcXHUyMjI1XCIsIHBhcjogXCJcXHUyMjI1XCIsIHBhcnNpbTogXCJcXHUyQUYzXCIsIHBhcnNsOiBcIlxcdTJBRkRcIiwgcGFydDogXCJcXHUyMjAyXCIsIFBhcnRpYWxEOiBcIlxcdTIyMDJcIiwgUGN5OiBcIlxcdTA0MUZcIiwgcGN5OiBcIlxcdTA0M0ZcIiwgcGVyY250OiBcIiVcIiwgcGVyaW9kOiBcIi5cIiwgcGVybWlsOiBcIlxcdTIwMzBcIiwgcGVycDogXCJcXHUyMkE1XCIsIHBlcnRlbms6IFwiXFx1MjAzMVwiLCBQZnI6IFwiXFx1ezFENTEzfVwiLCBwZnI6IFwiXFx1ezFENTJEfVwiLCBQaGk6IFwiXFx1MDNBNlwiLCBwaGk6IFwiXFx1MDNDNlwiLCBwaGl2OiBcIlxcdTAzRDVcIiwgcGhtbWF0OiBcIlxcdTIxMzNcIiwgcGhvbmU6IFwiXFx1MjYwRVwiLCBQaTogXCJcXHUwM0EwXCIsIHBpOiBcIlxcdTAzQzBcIiwgcGl0Y2hmb3JrOiBcIlxcdTIyRDRcIiwgcGl2OiBcIlxcdTAzRDZcIiwgcGxhbmNrOiBcIlxcdTIxMEZcIiwgcGxhbmNraDogXCJcXHUyMTBFXCIsIHBsYW5rdjogXCJcXHUyMTBGXCIsIHBsdXNhY2lyOiBcIlxcdTJBMjNcIiwgcGx1c2I6IFwiXFx1MjI5RVwiLCBwbHVzY2lyOiBcIlxcdTJBMjJcIiwgcGx1czogXCIrXCIsIHBsdXNkbzogXCJcXHUyMjE0XCIsIHBsdXNkdTogXCJcXHUyQTI1XCIsIHBsdXNlOiBcIlxcdTJBNzJcIiwgUGx1c01pbnVzOiBcIlxceEIxXCIsIHBsdXNtbjogXCJcXHhCMVwiLCBwbHVzc2ltOiBcIlxcdTJBMjZcIiwgcGx1c3R3bzogXCJcXHUyQTI3XCIsIHBtOiBcIlxceEIxXCIsIFBvaW5jYXJlcGxhbmU6IFwiXFx1MjEwQ1wiLCBwb2ludGludDogXCJcXHUyQTE1XCIsIHBvcGY6IFwiXFx1ezFENTYxfVwiLCBQb3BmOiBcIlxcdTIxMTlcIiwgcG91bmQ6IFwiXFx4QTNcIiwgcHJhcDogXCJcXHUyQUI3XCIsIFByOiBcIlxcdTJBQkJcIiwgcHI6IFwiXFx1MjI3QVwiLCBwcmN1ZTogXCJcXHUyMjdDXCIsIHByZWNhcHByb3g6IFwiXFx1MkFCN1wiLCBwcmVjOiBcIlxcdTIyN0FcIiwgcHJlY2N1cmx5ZXE6IFwiXFx1MjI3Q1wiLCBQcmVjZWRlczogXCJcXHUyMjdBXCIsIFByZWNlZGVzRXF1YWw6IFwiXFx1MkFBRlwiLCBQcmVjZWRlc1NsYW50RXF1YWw6IFwiXFx1MjI3Q1wiLCBQcmVjZWRlc1RpbGRlOiBcIlxcdTIyN0VcIiwgcHJlY2VxOiBcIlxcdTJBQUZcIiwgcHJlY25hcHByb3g6IFwiXFx1MkFCOVwiLCBwcmVjbmVxcTogXCJcXHUyQUI1XCIsIHByZWNuc2ltOiBcIlxcdTIyRThcIiwgcHJlOiBcIlxcdTJBQUZcIiwgcHJFOiBcIlxcdTJBQjNcIiwgcHJlY3NpbTogXCJcXHUyMjdFXCIsIHByaW1lOiBcIlxcdTIwMzJcIiwgUHJpbWU6IFwiXFx1MjAzM1wiLCBwcmltZXM6IFwiXFx1MjExOVwiLCBwcm5hcDogXCJcXHUyQUI5XCIsIHBybkU6IFwiXFx1MkFCNVwiLCBwcm5zaW06IFwiXFx1MjJFOFwiLCBwcm9kOiBcIlxcdTIyMEZcIiwgUHJvZHVjdDogXCJcXHUyMjBGXCIsIHByb2ZhbGFyOiBcIlxcdTIzMkVcIiwgcHJvZmxpbmU6IFwiXFx1MjMxMlwiLCBwcm9mc3VyZjogXCJcXHUyMzEzXCIsIHByb3A6IFwiXFx1MjIxRFwiLCBQcm9wb3J0aW9uYWw6IFwiXFx1MjIxRFwiLCBQcm9wb3J0aW9uOiBcIlxcdTIyMzdcIiwgcHJvcHRvOiBcIlxcdTIyMURcIiwgcHJzaW06IFwiXFx1MjI3RVwiLCBwcnVyZWw6IFwiXFx1MjJCMFwiLCBQc2NyOiBcIlxcdXsxRDRBQn1cIiwgcHNjcjogXCJcXHV7MUQ0QzV9XCIsIFBzaTogXCJcXHUwM0E4XCIsIHBzaTogXCJcXHUwM0M4XCIsIHB1bmNzcDogXCJcXHUyMDA4XCIsIFFmcjogXCJcXHV7MUQ1MTR9XCIsIHFmcjogXCJcXHV7MUQ1MkV9XCIsIHFpbnQ6IFwiXFx1MkEwQ1wiLCBxb3BmOiBcIlxcdXsxRDU2Mn1cIiwgUW9wZjogXCJcXHUyMTFBXCIsIHFwcmltZTogXCJcXHUyMDU3XCIsIFFzY3I6IFwiXFx1ezFENEFDfVwiLCBxc2NyOiBcIlxcdXsxRDRDNn1cIiwgcXVhdGVybmlvbnM6IFwiXFx1MjEwRFwiLCBxdWF0aW50OiBcIlxcdTJBMTZcIiwgcXVlc3Q6IFwiP1wiLCBxdWVzdGVxOiBcIlxcdTIyNUZcIiwgcXVvdDogJ1wiJywgUVVPVDogJ1wiJywgckFhcnI6IFwiXFx1MjFEQlwiLCByYWNlOiBcIlxcdTIyM0RcXHUwMzMxXCIsIFJhY3V0ZTogXCJcXHUwMTU0XCIsIHJhY3V0ZTogXCJcXHUwMTU1XCIsIHJhZGljOiBcIlxcdTIyMUFcIiwgcmFlbXB0eXY6IFwiXFx1MjlCM1wiLCByYW5nOiBcIlxcdTI3RTlcIiwgUmFuZzogXCJcXHUyN0VCXCIsIHJhbmdkOiBcIlxcdTI5OTJcIiwgcmFuZ2U6IFwiXFx1MjlBNVwiLCByYW5nbGU6IFwiXFx1MjdFOVwiLCByYXF1bzogXCJcXHhCQlwiLCByYXJyYXA6IFwiXFx1Mjk3NVwiLCByYXJyYjogXCJcXHUyMUU1XCIsIHJhcnJiZnM6IFwiXFx1MjkyMFwiLCByYXJyYzogXCJcXHUyOTMzXCIsIHJhcnI6IFwiXFx1MjE5MlwiLCBSYXJyOiBcIlxcdTIxQTBcIiwgckFycjogXCJcXHUyMUQyXCIsIHJhcnJmczogXCJcXHUyOTFFXCIsIHJhcnJoazogXCJcXHUyMUFBXCIsIHJhcnJscDogXCJcXHUyMUFDXCIsIHJhcnJwbDogXCJcXHUyOTQ1XCIsIHJhcnJzaW06IFwiXFx1Mjk3NFwiLCBSYXJydGw6IFwiXFx1MjkxNlwiLCByYXJydGw6IFwiXFx1MjFBM1wiLCByYXJydzogXCJcXHUyMTlEXCIsIHJhdGFpbDogXCJcXHUyOTFBXCIsIHJBdGFpbDogXCJcXHUyOTFDXCIsIHJhdGlvOiBcIlxcdTIyMzZcIiwgcmF0aW9uYWxzOiBcIlxcdTIxMUFcIiwgcmJhcnI6IFwiXFx1MjkwRFwiLCByQmFycjogXCJcXHUyOTBGXCIsIFJCYXJyOiBcIlxcdTI5MTBcIiwgcmJicms6IFwiXFx1Mjc3M1wiLCByYnJhY2U6IFwifVwiLCByYnJhY2s6IFwiXVwiLCByYnJrZTogXCJcXHUyOThDXCIsIHJicmtzbGQ6IFwiXFx1Mjk4RVwiLCByYnJrc2x1OiBcIlxcdTI5OTBcIiwgUmNhcm9uOiBcIlxcdTAxNThcIiwgcmNhcm9uOiBcIlxcdTAxNTlcIiwgUmNlZGlsOiBcIlxcdTAxNTZcIiwgcmNlZGlsOiBcIlxcdTAxNTdcIiwgcmNlaWw6IFwiXFx1MjMwOVwiLCByY3ViOiBcIn1cIiwgUmN5OiBcIlxcdTA0MjBcIiwgcmN5OiBcIlxcdTA0NDBcIiwgcmRjYTogXCJcXHUyOTM3XCIsIHJkbGRoYXI6IFwiXFx1Mjk2OVwiLCByZHF1bzogXCJcXHUyMDFEXCIsIHJkcXVvcjogXCJcXHUyMDFEXCIsIHJkc2g6IFwiXFx1MjFCM1wiLCByZWFsOiBcIlxcdTIxMUNcIiwgcmVhbGluZTogXCJcXHUyMTFCXCIsIHJlYWxwYXJ0OiBcIlxcdTIxMUNcIiwgcmVhbHM6IFwiXFx1MjExRFwiLCBSZTogXCJcXHUyMTFDXCIsIHJlY3Q6IFwiXFx1MjVBRFwiLCByZWc6IFwiXFx4QUVcIiwgUkVHOiBcIlxceEFFXCIsIFJldmVyc2VFbGVtZW50OiBcIlxcdTIyMEJcIiwgUmV2ZXJzZUVxdWlsaWJyaXVtOiBcIlxcdTIxQ0JcIiwgUmV2ZXJzZVVwRXF1aWxpYnJpdW06IFwiXFx1Mjk2RlwiLCByZmlzaHQ6IFwiXFx1Mjk3RFwiLCByZmxvb3I6IFwiXFx1MjMwQlwiLCByZnI6IFwiXFx1ezFENTJGfVwiLCBSZnI6IFwiXFx1MjExQ1wiLCBySGFyOiBcIlxcdTI5NjRcIiwgcmhhcmQ6IFwiXFx1MjFDMVwiLCByaGFydTogXCJcXHUyMUMwXCIsIHJoYXJ1bDogXCJcXHUyOTZDXCIsIFJobzogXCJcXHUwM0ExXCIsIHJobzogXCJcXHUwM0MxXCIsIHJob3Y6IFwiXFx1MDNGMVwiLCBSaWdodEFuZ2xlQnJhY2tldDogXCJcXHUyN0U5XCIsIFJpZ2h0QXJyb3dCYXI6IFwiXFx1MjFFNVwiLCByaWdodGFycm93OiBcIlxcdTIxOTJcIiwgUmlnaHRBcnJvdzogXCJcXHUyMTkyXCIsIFJpZ2h0YXJyb3c6IFwiXFx1MjFEMlwiLCBSaWdodEFycm93TGVmdEFycm93OiBcIlxcdTIxQzRcIiwgcmlnaHRhcnJvd3RhaWw6IFwiXFx1MjFBM1wiLCBSaWdodENlaWxpbmc6IFwiXFx1MjMwOVwiLCBSaWdodERvdWJsZUJyYWNrZXQ6IFwiXFx1MjdFN1wiLCBSaWdodERvd25UZWVWZWN0b3I6IFwiXFx1Mjk1RFwiLCBSaWdodERvd25WZWN0b3JCYXI6IFwiXFx1Mjk1NVwiLCBSaWdodERvd25WZWN0b3I6IFwiXFx1MjFDMlwiLCBSaWdodEZsb29yOiBcIlxcdTIzMEJcIiwgcmlnaHRoYXJwb29uZG93bjogXCJcXHUyMUMxXCIsIHJpZ2h0aGFycG9vbnVwOiBcIlxcdTIxQzBcIiwgcmlnaHRsZWZ0YXJyb3dzOiBcIlxcdTIxQzRcIiwgcmlnaHRsZWZ0aGFycG9vbnM6IFwiXFx1MjFDQ1wiLCByaWdodHJpZ2h0YXJyb3dzOiBcIlxcdTIxQzlcIiwgcmlnaHRzcXVpZ2Fycm93OiBcIlxcdTIxOURcIiwgUmlnaHRUZWVBcnJvdzogXCJcXHUyMUE2XCIsIFJpZ2h0VGVlOiBcIlxcdTIyQTJcIiwgUmlnaHRUZWVWZWN0b3I6IFwiXFx1Mjk1QlwiLCByaWdodHRocmVldGltZXM6IFwiXFx1MjJDQ1wiLCBSaWdodFRyaWFuZ2xlQmFyOiBcIlxcdTI5RDBcIiwgUmlnaHRUcmlhbmdsZTogXCJcXHUyMkIzXCIsIFJpZ2h0VHJpYW5nbGVFcXVhbDogXCJcXHUyMkI1XCIsIFJpZ2h0VXBEb3duVmVjdG9yOiBcIlxcdTI5NEZcIiwgUmlnaHRVcFRlZVZlY3RvcjogXCJcXHUyOTVDXCIsIFJpZ2h0VXBWZWN0b3JCYXI6IFwiXFx1Mjk1NFwiLCBSaWdodFVwVmVjdG9yOiBcIlxcdTIxQkVcIiwgUmlnaHRWZWN0b3JCYXI6IFwiXFx1Mjk1M1wiLCBSaWdodFZlY3RvcjogXCJcXHUyMUMwXCIsIHJpbmc6IFwiXFx1MDJEQVwiLCByaXNpbmdkb3RzZXE6IFwiXFx1MjI1M1wiLCBybGFycjogXCJcXHUyMUM0XCIsIHJsaGFyOiBcIlxcdTIxQ0NcIiwgcmxtOiBcIlxcdTIwMEZcIiwgcm1vdXN0YWNoZTogXCJcXHUyM0IxXCIsIHJtb3VzdDogXCJcXHUyM0IxXCIsIHJubWlkOiBcIlxcdTJBRUVcIiwgcm9hbmc6IFwiXFx1MjdFRFwiLCByb2FycjogXCJcXHUyMUZFXCIsIHJvYnJrOiBcIlxcdTI3RTdcIiwgcm9wYXI6IFwiXFx1Mjk4NlwiLCByb3BmOiBcIlxcdXsxRDU2M31cIiwgUm9wZjogXCJcXHUyMTFEXCIsIHJvcGx1czogXCJcXHUyQTJFXCIsIHJvdGltZXM6IFwiXFx1MkEzNVwiLCBSb3VuZEltcGxpZXM6IFwiXFx1Mjk3MFwiLCBycGFyOiBcIilcIiwgcnBhcmd0OiBcIlxcdTI5OTRcIiwgcnBwb2xpbnQ6IFwiXFx1MkExMlwiLCBycmFycjogXCJcXHUyMUM5XCIsIFJyaWdodGFycm93OiBcIlxcdTIxREJcIiwgcnNhcXVvOiBcIlxcdTIwM0FcIiwgcnNjcjogXCJcXHV7MUQ0Qzd9XCIsIFJzY3I6IFwiXFx1MjExQlwiLCByc2g6IFwiXFx1MjFCMVwiLCBSc2g6IFwiXFx1MjFCMVwiLCByc3FiOiBcIl1cIiwgcnNxdW86IFwiXFx1MjAxOVwiLCByc3F1b3I6IFwiXFx1MjAxOVwiLCBydGhyZWU6IFwiXFx1MjJDQ1wiLCBydGltZXM6IFwiXFx1MjJDQVwiLCBydHJpOiBcIlxcdTI1QjlcIiwgcnRyaWU6IFwiXFx1MjJCNVwiLCBydHJpZjogXCJcXHUyNUI4XCIsIHJ0cmlsdHJpOiBcIlxcdTI5Q0VcIiwgUnVsZURlbGF5ZWQ6IFwiXFx1MjlGNFwiLCBydWx1aGFyOiBcIlxcdTI5NjhcIiwgcng6IFwiXFx1MjExRVwiLCBTYWN1dGU6IFwiXFx1MDE1QVwiLCBzYWN1dGU6IFwiXFx1MDE1QlwiLCBzYnF1bzogXCJcXHUyMDFBXCIsIHNjYXA6IFwiXFx1MkFCOFwiLCBTY2Fyb246IFwiXFx1MDE2MFwiLCBzY2Fyb246IFwiXFx1MDE2MVwiLCBTYzogXCJcXHUyQUJDXCIsIHNjOiBcIlxcdTIyN0JcIiwgc2NjdWU6IFwiXFx1MjI3RFwiLCBzY2U6IFwiXFx1MkFCMFwiLCBzY0U6IFwiXFx1MkFCNFwiLCBTY2VkaWw6IFwiXFx1MDE1RVwiLCBzY2VkaWw6IFwiXFx1MDE1RlwiLCBTY2lyYzogXCJcXHUwMTVDXCIsIHNjaXJjOiBcIlxcdTAxNURcIiwgc2NuYXA6IFwiXFx1MkFCQVwiLCBzY25FOiBcIlxcdTJBQjZcIiwgc2Nuc2ltOiBcIlxcdTIyRTlcIiwgc2Nwb2xpbnQ6IFwiXFx1MkExM1wiLCBzY3NpbTogXCJcXHUyMjdGXCIsIFNjeTogXCJcXHUwNDIxXCIsIHNjeTogXCJcXHUwNDQxXCIsIHNkb3RiOiBcIlxcdTIyQTFcIiwgc2RvdDogXCJcXHUyMkM1XCIsIHNkb3RlOiBcIlxcdTJBNjZcIiwgc2VhcmhrOiBcIlxcdTI5MjVcIiwgc2VhcnI6IFwiXFx1MjE5OFwiLCBzZUFycjogXCJcXHUyMUQ4XCIsIHNlYXJyb3c6IFwiXFx1MjE5OFwiLCBzZWN0OiBcIlxceEE3XCIsIHNlbWk6IFwiO1wiLCBzZXN3YXI6IFwiXFx1MjkyOVwiLCBzZXRtaW51czogXCJcXHUyMjE2XCIsIHNldG1uOiBcIlxcdTIyMTZcIiwgc2V4dDogXCJcXHUyNzM2XCIsIFNmcjogXCJcXHV7MUQ1MTZ9XCIsIHNmcjogXCJcXHV7MUQ1MzB9XCIsIHNmcm93bjogXCJcXHUyMzIyXCIsIHNoYXJwOiBcIlxcdTI2NkZcIiwgU0hDSGN5OiBcIlxcdTA0MjlcIiwgc2hjaGN5OiBcIlxcdTA0NDlcIiwgU0hjeTogXCJcXHUwNDI4XCIsIHNoY3k6IFwiXFx1MDQ0OFwiLCBTaG9ydERvd25BcnJvdzogXCJcXHUyMTkzXCIsIFNob3J0TGVmdEFycm93OiBcIlxcdTIxOTBcIiwgc2hvcnRtaWQ6IFwiXFx1MjIyM1wiLCBzaG9ydHBhcmFsbGVsOiBcIlxcdTIyMjVcIiwgU2hvcnRSaWdodEFycm93OiBcIlxcdTIxOTJcIiwgU2hvcnRVcEFycm93OiBcIlxcdTIxOTFcIiwgc2h5OiBcIlxceEFEXCIsIFNpZ21hOiBcIlxcdTAzQTNcIiwgc2lnbWE6IFwiXFx1MDNDM1wiLCBzaWdtYWY6IFwiXFx1MDNDMlwiLCBzaWdtYXY6IFwiXFx1MDNDMlwiLCBzaW06IFwiXFx1MjIzQ1wiLCBzaW1kb3Q6IFwiXFx1MkE2QVwiLCBzaW1lOiBcIlxcdTIyNDNcIiwgc2ltZXE6IFwiXFx1MjI0M1wiLCBzaW1nOiBcIlxcdTJBOUVcIiwgc2ltZ0U6IFwiXFx1MkFBMFwiLCBzaW1sOiBcIlxcdTJBOURcIiwgc2ltbEU6IFwiXFx1MkE5RlwiLCBzaW1uZTogXCJcXHUyMjQ2XCIsIHNpbXBsdXM6IFwiXFx1MkEyNFwiLCBzaW1yYXJyOiBcIlxcdTI5NzJcIiwgc2xhcnI6IFwiXFx1MjE5MFwiLCBTbWFsbENpcmNsZTogXCJcXHUyMjE4XCIsIHNtYWxsc2V0bWludXM6IFwiXFx1MjIxNlwiLCBzbWFzaHA6IFwiXFx1MkEzM1wiLCBzbWVwYXJzbDogXCJcXHUyOUU0XCIsIHNtaWQ6IFwiXFx1MjIyM1wiLCBzbWlsZTogXCJcXHUyMzIzXCIsIHNtdDogXCJcXHUyQUFBXCIsIHNtdGU6IFwiXFx1MkFBQ1wiLCBzbXRlczogXCJcXHUyQUFDXFx1RkUwMFwiLCBTT0ZUY3k6IFwiXFx1MDQyQ1wiLCBzb2Z0Y3k6IFwiXFx1MDQ0Q1wiLCBzb2xiYXI6IFwiXFx1MjMzRlwiLCBzb2xiOiBcIlxcdTI5QzRcIiwgc29sOiBcIi9cIiwgU29wZjogXCJcXHV7MUQ1NEF9XCIsIHNvcGY6IFwiXFx1ezFENTY0fVwiLCBzcGFkZXM6IFwiXFx1MjY2MFwiLCBzcGFkZXN1aXQ6IFwiXFx1MjY2MFwiLCBzcGFyOiBcIlxcdTIyMjVcIiwgc3FjYXA6IFwiXFx1MjI5M1wiLCBzcWNhcHM6IFwiXFx1MjI5M1xcdUZFMDBcIiwgc3FjdXA6IFwiXFx1MjI5NFwiLCBzcWN1cHM6IFwiXFx1MjI5NFxcdUZFMDBcIiwgU3FydDogXCJcXHUyMjFBXCIsIHNxc3ViOiBcIlxcdTIyOEZcIiwgc3FzdWJlOiBcIlxcdTIyOTFcIiwgc3FzdWJzZXQ6IFwiXFx1MjI4RlwiLCBzcXN1YnNldGVxOiBcIlxcdTIyOTFcIiwgc3FzdXA6IFwiXFx1MjI5MFwiLCBzcXN1cGU6IFwiXFx1MjI5MlwiLCBzcXN1cHNldDogXCJcXHUyMjkwXCIsIHNxc3Vwc2V0ZXE6IFwiXFx1MjI5MlwiLCBzcXVhcmU6IFwiXFx1MjVBMVwiLCBTcXVhcmU6IFwiXFx1MjVBMVwiLCBTcXVhcmVJbnRlcnNlY3Rpb246IFwiXFx1MjI5M1wiLCBTcXVhcmVTdWJzZXQ6IFwiXFx1MjI4RlwiLCBTcXVhcmVTdWJzZXRFcXVhbDogXCJcXHUyMjkxXCIsIFNxdWFyZVN1cGVyc2V0OiBcIlxcdTIyOTBcIiwgU3F1YXJlU3VwZXJzZXRFcXVhbDogXCJcXHUyMjkyXCIsIFNxdWFyZVVuaW9uOiBcIlxcdTIyOTRcIiwgc3F1YXJmOiBcIlxcdTI1QUFcIiwgc3F1OiBcIlxcdTI1QTFcIiwgc3F1ZjogXCJcXHUyNUFBXCIsIHNyYXJyOiBcIlxcdTIxOTJcIiwgU3NjcjogXCJcXHV7MUQ0QUV9XCIsIHNzY3I6IFwiXFx1ezFENEM4fVwiLCBzc2V0bW46IFwiXFx1MjIxNlwiLCBzc21pbGU6IFwiXFx1MjMyM1wiLCBzc3RhcmY6IFwiXFx1MjJDNlwiLCBTdGFyOiBcIlxcdTIyQzZcIiwgc3RhcjogXCJcXHUyNjA2XCIsIHN0YXJmOiBcIlxcdTI2MDVcIiwgc3RyYWlnaHRlcHNpbG9uOiBcIlxcdTAzRjVcIiwgc3RyYWlnaHRwaGk6IFwiXFx1MDNENVwiLCBzdHJuczogXCJcXHhBRlwiLCBzdWI6IFwiXFx1MjI4MlwiLCBTdWI6IFwiXFx1MjJEMFwiLCBzdWJkb3Q6IFwiXFx1MkFCRFwiLCBzdWJFOiBcIlxcdTJBQzVcIiwgc3ViZTogXCJcXHUyMjg2XCIsIHN1YmVkb3Q6IFwiXFx1MkFDM1wiLCBzdWJtdWx0OiBcIlxcdTJBQzFcIiwgc3VibkU6IFwiXFx1MkFDQlwiLCBzdWJuZTogXCJcXHUyMjhBXCIsIHN1YnBsdXM6IFwiXFx1MkFCRlwiLCBzdWJyYXJyOiBcIlxcdTI5NzlcIiwgc3Vic2V0OiBcIlxcdTIyODJcIiwgU3Vic2V0OiBcIlxcdTIyRDBcIiwgc3Vic2V0ZXE6IFwiXFx1MjI4NlwiLCBzdWJzZXRlcXE6IFwiXFx1MkFDNVwiLCBTdWJzZXRFcXVhbDogXCJcXHUyMjg2XCIsIHN1YnNldG5lcTogXCJcXHUyMjhBXCIsIHN1YnNldG5lcXE6IFwiXFx1MkFDQlwiLCBzdWJzaW06IFwiXFx1MkFDN1wiLCBzdWJzdWI6IFwiXFx1MkFENVwiLCBzdWJzdXA6IFwiXFx1MkFEM1wiLCBzdWNjYXBwcm94OiBcIlxcdTJBQjhcIiwgc3VjYzogXCJcXHUyMjdCXCIsIHN1Y2NjdXJseWVxOiBcIlxcdTIyN0RcIiwgU3VjY2VlZHM6IFwiXFx1MjI3QlwiLCBTdWNjZWVkc0VxdWFsOiBcIlxcdTJBQjBcIiwgU3VjY2VlZHNTbGFudEVxdWFsOiBcIlxcdTIyN0RcIiwgU3VjY2VlZHNUaWxkZTogXCJcXHUyMjdGXCIsIHN1Y2NlcTogXCJcXHUyQUIwXCIsIHN1Y2NuYXBwcm94OiBcIlxcdTJBQkFcIiwgc3VjY25lcXE6IFwiXFx1MkFCNlwiLCBzdWNjbnNpbTogXCJcXHUyMkU5XCIsIHN1Y2NzaW06IFwiXFx1MjI3RlwiLCBTdWNoVGhhdDogXCJcXHUyMjBCXCIsIHN1bTogXCJcXHUyMjExXCIsIFN1bTogXCJcXHUyMjExXCIsIHN1bmc6IFwiXFx1MjY2QVwiLCBzdXAxOiBcIlxceEI5XCIsIHN1cDI6IFwiXFx4QjJcIiwgc3VwMzogXCJcXHhCM1wiLCBzdXA6IFwiXFx1MjI4M1wiLCBTdXA6IFwiXFx1MjJEMVwiLCBzdXBkb3Q6IFwiXFx1MkFCRVwiLCBzdXBkc3ViOiBcIlxcdTJBRDhcIiwgc3VwRTogXCJcXHUyQUM2XCIsIHN1cGU6IFwiXFx1MjI4N1wiLCBzdXBlZG90OiBcIlxcdTJBQzRcIiwgU3VwZXJzZXQ6IFwiXFx1MjI4M1wiLCBTdXBlcnNldEVxdWFsOiBcIlxcdTIyODdcIiwgc3VwaHNvbDogXCJcXHUyN0M5XCIsIHN1cGhzdWI6IFwiXFx1MkFEN1wiLCBzdXBsYXJyOiBcIlxcdTI5N0JcIiwgc3VwbXVsdDogXCJcXHUyQUMyXCIsIHN1cG5FOiBcIlxcdTJBQ0NcIiwgc3VwbmU6IFwiXFx1MjI4QlwiLCBzdXBwbHVzOiBcIlxcdTJBQzBcIiwgc3Vwc2V0OiBcIlxcdTIyODNcIiwgU3Vwc2V0OiBcIlxcdTIyRDFcIiwgc3Vwc2V0ZXE6IFwiXFx1MjI4N1wiLCBzdXBzZXRlcXE6IFwiXFx1MkFDNlwiLCBzdXBzZXRuZXE6IFwiXFx1MjI4QlwiLCBzdXBzZXRuZXFxOiBcIlxcdTJBQ0NcIiwgc3Vwc2ltOiBcIlxcdTJBQzhcIiwgc3Vwc3ViOiBcIlxcdTJBRDRcIiwgc3Vwc3VwOiBcIlxcdTJBRDZcIiwgc3dhcmhrOiBcIlxcdTI5MjZcIiwgc3dhcnI6IFwiXFx1MjE5OVwiLCBzd0FycjogXCJcXHUyMUQ5XCIsIHN3YXJyb3c6IFwiXFx1MjE5OVwiLCBzd253YXI6IFwiXFx1MjkyQVwiLCBzemxpZzogXCJcXHhERlwiLCBUYWI6IFwiXHRcIiwgdGFyZ2V0OiBcIlxcdTIzMTZcIiwgVGF1OiBcIlxcdTAzQTRcIiwgdGF1OiBcIlxcdTAzQzRcIiwgdGJyazogXCJcXHUyM0I0XCIsIFRjYXJvbjogXCJcXHUwMTY0XCIsIHRjYXJvbjogXCJcXHUwMTY1XCIsIFRjZWRpbDogXCJcXHUwMTYyXCIsIHRjZWRpbDogXCJcXHUwMTYzXCIsIFRjeTogXCJcXHUwNDIyXCIsIHRjeTogXCJcXHUwNDQyXCIsIHRkb3Q6IFwiXFx1MjBEQlwiLCB0ZWxyZWM6IFwiXFx1MjMxNVwiLCBUZnI6IFwiXFx1ezFENTE3fVwiLCB0ZnI6IFwiXFx1ezFENTMxfVwiLCB0aGVyZTQ6IFwiXFx1MjIzNFwiLCB0aGVyZWZvcmU6IFwiXFx1MjIzNFwiLCBUaGVyZWZvcmU6IFwiXFx1MjIzNFwiLCBUaGV0YTogXCJcXHUwMzk4XCIsIHRoZXRhOiBcIlxcdTAzQjhcIiwgdGhldGFzeW06IFwiXFx1MDNEMVwiLCB0aGV0YXY6IFwiXFx1MDNEMVwiLCB0aGlja2FwcHJveDogXCJcXHUyMjQ4XCIsIHRoaWNrc2ltOiBcIlxcdTIyM0NcIiwgVGhpY2tTcGFjZTogXCJcXHUyMDVGXFx1MjAwQVwiLCBUaGluU3BhY2U6IFwiXFx1MjAwOVwiLCB0aGluc3A6IFwiXFx1MjAwOVwiLCB0aGthcDogXCJcXHUyMjQ4XCIsIHRoa3NpbTogXCJcXHUyMjNDXCIsIFRIT1JOOiBcIlxceERFXCIsIHRob3JuOiBcIlxceEZFXCIsIHRpbGRlOiBcIlxcdTAyRENcIiwgVGlsZGU6IFwiXFx1MjIzQ1wiLCBUaWxkZUVxdWFsOiBcIlxcdTIyNDNcIiwgVGlsZGVGdWxsRXF1YWw6IFwiXFx1MjI0NVwiLCBUaWxkZVRpbGRlOiBcIlxcdTIyNDhcIiwgdGltZXNiYXI6IFwiXFx1MkEzMVwiLCB0aW1lc2I6IFwiXFx1MjJBMFwiLCB0aW1lczogXCJcXHhEN1wiLCB0aW1lc2Q6IFwiXFx1MkEzMFwiLCB0aW50OiBcIlxcdTIyMkRcIiwgdG9lYTogXCJcXHUyOTI4XCIsIHRvcGJvdDogXCJcXHUyMzM2XCIsIHRvcGNpcjogXCJcXHUyQUYxXCIsIHRvcDogXCJcXHUyMkE0XCIsIFRvcGY6IFwiXFx1ezFENTRCfVwiLCB0b3BmOiBcIlxcdXsxRDU2NX1cIiwgdG9wZm9yazogXCJcXHUyQURBXCIsIHRvc2E6IFwiXFx1MjkyOVwiLCB0cHJpbWU6IFwiXFx1MjAzNFwiLCB0cmFkZTogXCJcXHUyMTIyXCIsIFRSQURFOiBcIlxcdTIxMjJcIiwgdHJpYW5nbGU6IFwiXFx1MjVCNVwiLCB0cmlhbmdsZWRvd246IFwiXFx1MjVCRlwiLCB0cmlhbmdsZWxlZnQ6IFwiXFx1MjVDM1wiLCB0cmlhbmdsZWxlZnRlcTogXCJcXHUyMkI0XCIsIHRyaWFuZ2xlcTogXCJcXHUyMjVDXCIsIHRyaWFuZ2xlcmlnaHQ6IFwiXFx1MjVCOVwiLCB0cmlhbmdsZXJpZ2h0ZXE6IFwiXFx1MjJCNVwiLCB0cmlkb3Q6IFwiXFx1MjVFQ1wiLCB0cmllOiBcIlxcdTIyNUNcIiwgdHJpbWludXM6IFwiXFx1MkEzQVwiLCBUcmlwbGVEb3Q6IFwiXFx1MjBEQlwiLCB0cmlwbHVzOiBcIlxcdTJBMzlcIiwgdHJpc2I6IFwiXFx1MjlDRFwiLCB0cml0aW1lOiBcIlxcdTJBM0JcIiwgdHJwZXppdW06IFwiXFx1MjNFMlwiLCBUc2NyOiBcIlxcdXsxRDRBRn1cIiwgdHNjcjogXCJcXHV7MUQ0Qzl9XCIsIFRTY3k6IFwiXFx1MDQyNlwiLCB0c2N5OiBcIlxcdTA0NDZcIiwgVFNIY3k6IFwiXFx1MDQwQlwiLCB0c2hjeTogXCJcXHUwNDVCXCIsIFRzdHJvazogXCJcXHUwMTY2XCIsIHRzdHJvazogXCJcXHUwMTY3XCIsIHR3aXh0OiBcIlxcdTIyNkNcIiwgdHdvaGVhZGxlZnRhcnJvdzogXCJcXHUyMTlFXCIsIHR3b2hlYWRyaWdodGFycm93OiBcIlxcdTIxQTBcIiwgVWFjdXRlOiBcIlxceERBXCIsIHVhY3V0ZTogXCJcXHhGQVwiLCB1YXJyOiBcIlxcdTIxOTFcIiwgVWFycjogXCJcXHUyMTlGXCIsIHVBcnI6IFwiXFx1MjFEMVwiLCBVYXJyb2NpcjogXCJcXHUyOTQ5XCIsIFVicmN5OiBcIlxcdTA0MEVcIiwgdWJyY3k6IFwiXFx1MDQ1RVwiLCBVYnJldmU6IFwiXFx1MDE2Q1wiLCB1YnJldmU6IFwiXFx1MDE2RFwiLCBVY2lyYzogXCJcXHhEQlwiLCB1Y2lyYzogXCJcXHhGQlwiLCBVY3k6IFwiXFx1MDQyM1wiLCB1Y3k6IFwiXFx1MDQ0M1wiLCB1ZGFycjogXCJcXHUyMUM1XCIsIFVkYmxhYzogXCJcXHUwMTcwXCIsIHVkYmxhYzogXCJcXHUwMTcxXCIsIHVkaGFyOiBcIlxcdTI5NkVcIiwgdWZpc2h0OiBcIlxcdTI5N0VcIiwgVWZyOiBcIlxcdXsxRDUxOH1cIiwgdWZyOiBcIlxcdXsxRDUzMn1cIiwgVWdyYXZlOiBcIlxceEQ5XCIsIHVncmF2ZTogXCJcXHhGOVwiLCB1SGFyOiBcIlxcdTI5NjNcIiwgdWhhcmw6IFwiXFx1MjFCRlwiLCB1aGFycjogXCJcXHUyMUJFXCIsIHVoYmxrOiBcIlxcdTI1ODBcIiwgdWxjb3JuOiBcIlxcdTIzMUNcIiwgdWxjb3JuZXI6IFwiXFx1MjMxQ1wiLCB1bGNyb3A6IFwiXFx1MjMwRlwiLCB1bHRyaTogXCJcXHUyNUY4XCIsIFVtYWNyOiBcIlxcdTAxNkFcIiwgdW1hY3I6IFwiXFx1MDE2QlwiLCB1bWw6IFwiXFx4QThcIiwgVW5kZXJCYXI6IFwiX1wiLCBVbmRlckJyYWNlOiBcIlxcdTIzREZcIiwgVW5kZXJCcmFja2V0OiBcIlxcdTIzQjVcIiwgVW5kZXJQYXJlbnRoZXNpczogXCJcXHUyM0REXCIsIFVuaW9uOiBcIlxcdTIyQzNcIiwgVW5pb25QbHVzOiBcIlxcdTIyOEVcIiwgVW9nb246IFwiXFx1MDE3MlwiLCB1b2dvbjogXCJcXHUwMTczXCIsIFVvcGY6IFwiXFx1ezFENTRDfVwiLCB1b3BmOiBcIlxcdXsxRDU2Nn1cIiwgVXBBcnJvd0JhcjogXCJcXHUyOTEyXCIsIHVwYXJyb3c6IFwiXFx1MjE5MVwiLCBVcEFycm93OiBcIlxcdTIxOTFcIiwgVXBhcnJvdzogXCJcXHUyMUQxXCIsIFVwQXJyb3dEb3duQXJyb3c6IFwiXFx1MjFDNVwiLCB1cGRvd25hcnJvdzogXCJcXHUyMTk1XCIsIFVwRG93bkFycm93OiBcIlxcdTIxOTVcIiwgVXBkb3duYXJyb3c6IFwiXFx1MjFENVwiLCBVcEVxdWlsaWJyaXVtOiBcIlxcdTI5NkVcIiwgdXBoYXJwb29ubGVmdDogXCJcXHUyMUJGXCIsIHVwaGFycG9vbnJpZ2h0OiBcIlxcdTIxQkVcIiwgdXBsdXM6IFwiXFx1MjI4RVwiLCBVcHBlckxlZnRBcnJvdzogXCJcXHUyMTk2XCIsIFVwcGVyUmlnaHRBcnJvdzogXCJcXHUyMTk3XCIsIHVwc2k6IFwiXFx1MDNDNVwiLCBVcHNpOiBcIlxcdTAzRDJcIiwgdXBzaWg6IFwiXFx1MDNEMlwiLCBVcHNpbG9uOiBcIlxcdTAzQTVcIiwgdXBzaWxvbjogXCJcXHUwM0M1XCIsIFVwVGVlQXJyb3c6IFwiXFx1MjFBNVwiLCBVcFRlZTogXCJcXHUyMkE1XCIsIHVwdXBhcnJvd3M6IFwiXFx1MjFDOFwiLCB1cmNvcm46IFwiXFx1MjMxRFwiLCB1cmNvcm5lcjogXCJcXHUyMzFEXCIsIHVyY3JvcDogXCJcXHUyMzBFXCIsIFVyaW5nOiBcIlxcdTAxNkVcIiwgdXJpbmc6IFwiXFx1MDE2RlwiLCB1cnRyaTogXCJcXHUyNUY5XCIsIFVzY3I6IFwiXFx1ezFENEIwfVwiLCB1c2NyOiBcIlxcdXsxRDRDQX1cIiwgdXRkb3Q6IFwiXFx1MjJGMFwiLCBVdGlsZGU6IFwiXFx1MDE2OFwiLCB1dGlsZGU6IFwiXFx1MDE2OVwiLCB1dHJpOiBcIlxcdTI1QjVcIiwgdXRyaWY6IFwiXFx1MjVCNFwiLCB1dWFycjogXCJcXHUyMUM4XCIsIFV1bWw6IFwiXFx4RENcIiwgdXVtbDogXCJcXHhGQ1wiLCB1d2FuZ2xlOiBcIlxcdTI5QTdcIiwgdmFuZ3J0OiBcIlxcdTI5OUNcIiwgdmFyZXBzaWxvbjogXCJcXHUwM0Y1XCIsIHZhcmthcHBhOiBcIlxcdTAzRjBcIiwgdmFybm90aGluZzogXCJcXHUyMjA1XCIsIHZhcnBoaTogXCJcXHUwM0Q1XCIsIHZhcnBpOiBcIlxcdTAzRDZcIiwgdmFycHJvcHRvOiBcIlxcdTIyMURcIiwgdmFycjogXCJcXHUyMTk1XCIsIHZBcnI6IFwiXFx1MjFENVwiLCB2YXJyaG86IFwiXFx1MDNGMVwiLCB2YXJzaWdtYTogXCJcXHUwM0MyXCIsIHZhcnN1YnNldG5lcTogXCJcXHUyMjhBXFx1RkUwMFwiLCB2YXJzdWJzZXRuZXFxOiBcIlxcdTJBQ0JcXHVGRTAwXCIsIHZhcnN1cHNldG5lcTogXCJcXHUyMjhCXFx1RkUwMFwiLCB2YXJzdXBzZXRuZXFxOiBcIlxcdTJBQ0NcXHVGRTAwXCIsIHZhcnRoZXRhOiBcIlxcdTAzRDFcIiwgdmFydHJpYW5nbGVsZWZ0OiBcIlxcdTIyQjJcIiwgdmFydHJpYW5nbGVyaWdodDogXCJcXHUyMkIzXCIsIHZCYXI6IFwiXFx1MkFFOFwiLCBWYmFyOiBcIlxcdTJBRUJcIiwgdkJhcnY6IFwiXFx1MkFFOVwiLCBWY3k6IFwiXFx1MDQxMlwiLCB2Y3k6IFwiXFx1MDQzMlwiLCB2ZGFzaDogXCJcXHUyMkEyXCIsIHZEYXNoOiBcIlxcdTIyQThcIiwgVmRhc2g6IFwiXFx1MjJBOVwiLCBWRGFzaDogXCJcXHUyMkFCXCIsIFZkYXNobDogXCJcXHUyQUU2XCIsIHZlZWJhcjogXCJcXHUyMkJCXCIsIHZlZTogXCJcXHUyMjI4XCIsIFZlZTogXCJcXHUyMkMxXCIsIHZlZWVxOiBcIlxcdTIyNUFcIiwgdmVsbGlwOiBcIlxcdTIyRUVcIiwgdmVyYmFyOiBcInxcIiwgVmVyYmFyOiBcIlxcdTIwMTZcIiwgdmVydDogXCJ8XCIsIFZlcnQ6IFwiXFx1MjAxNlwiLCBWZXJ0aWNhbEJhcjogXCJcXHUyMjIzXCIsIFZlcnRpY2FsTGluZTogXCJ8XCIsIFZlcnRpY2FsU2VwYXJhdG9yOiBcIlxcdTI3NThcIiwgVmVydGljYWxUaWxkZTogXCJcXHUyMjQwXCIsIFZlcnlUaGluU3BhY2U6IFwiXFx1MjAwQVwiLCBWZnI6IFwiXFx1ezFENTE5fVwiLCB2ZnI6IFwiXFx1ezFENTMzfVwiLCB2bHRyaTogXCJcXHUyMkIyXCIsIHZuc3ViOiBcIlxcdTIyODJcXHUyMEQyXCIsIHZuc3VwOiBcIlxcdTIyODNcXHUyMEQyXCIsIFZvcGY6IFwiXFx1ezFENTREfVwiLCB2b3BmOiBcIlxcdXsxRDU2N31cIiwgdnByb3A6IFwiXFx1MjIxRFwiLCB2cnRyaTogXCJcXHUyMkIzXCIsIFZzY3I6IFwiXFx1ezFENEIxfVwiLCB2c2NyOiBcIlxcdXsxRDRDQn1cIiwgdnN1Ym5FOiBcIlxcdTJBQ0JcXHVGRTAwXCIsIHZzdWJuZTogXCJcXHUyMjhBXFx1RkUwMFwiLCB2c3VwbkU6IFwiXFx1MkFDQ1xcdUZFMDBcIiwgdnN1cG5lOiBcIlxcdTIyOEJcXHVGRTAwXCIsIFZ2ZGFzaDogXCJcXHUyMkFBXCIsIHZ6aWd6YWc6IFwiXFx1Mjk5QVwiLCBXY2lyYzogXCJcXHUwMTc0XCIsIHdjaXJjOiBcIlxcdTAxNzVcIiwgd2VkYmFyOiBcIlxcdTJBNUZcIiwgd2VkZ2U6IFwiXFx1MjIyN1wiLCBXZWRnZTogXCJcXHUyMkMwXCIsIHdlZGdlcTogXCJcXHUyMjU5XCIsIHdlaWVycDogXCJcXHUyMTE4XCIsIFdmcjogXCJcXHV7MUQ1MUF9XCIsIHdmcjogXCJcXHV7MUQ1MzR9XCIsIFdvcGY6IFwiXFx1ezFENTRFfVwiLCB3b3BmOiBcIlxcdXsxRDU2OH1cIiwgd3A6IFwiXFx1MjExOFwiLCB3cjogXCJcXHUyMjQwXCIsIHdyZWF0aDogXCJcXHUyMjQwXCIsIFdzY3I6IFwiXFx1ezFENEIyfVwiLCB3c2NyOiBcIlxcdXsxRDRDQ31cIiwgeGNhcDogXCJcXHUyMkMyXCIsIHhjaXJjOiBcIlxcdTI1RUZcIiwgeGN1cDogXCJcXHUyMkMzXCIsIHhkdHJpOiBcIlxcdTI1QkRcIiwgWGZyOiBcIlxcdXsxRDUxQn1cIiwgeGZyOiBcIlxcdXsxRDUzNX1cIiwgeGhhcnI6IFwiXFx1MjdGN1wiLCB4aEFycjogXCJcXHUyN0ZBXCIsIFhpOiBcIlxcdTAzOUVcIiwgeGk6IFwiXFx1MDNCRVwiLCB4bGFycjogXCJcXHUyN0Y1XCIsIHhsQXJyOiBcIlxcdTI3RjhcIiwgeG1hcDogXCJcXHUyN0ZDXCIsIHhuaXM6IFwiXFx1MjJGQlwiLCB4b2RvdDogXCJcXHUyQTAwXCIsIFhvcGY6IFwiXFx1ezFENTRGfVwiLCB4b3BmOiBcIlxcdXsxRDU2OX1cIiwgeG9wbHVzOiBcIlxcdTJBMDFcIiwgeG90aW1lOiBcIlxcdTJBMDJcIiwgeHJhcnI6IFwiXFx1MjdGNlwiLCB4ckFycjogXCJcXHUyN0Y5XCIsIFhzY3I6IFwiXFx1ezFENEIzfVwiLCB4c2NyOiBcIlxcdXsxRDRDRH1cIiwgeHNxY3VwOiBcIlxcdTJBMDZcIiwgeHVwbHVzOiBcIlxcdTJBMDRcIiwgeHV0cmk6IFwiXFx1MjVCM1wiLCB4dmVlOiBcIlxcdTIyQzFcIiwgeHdlZGdlOiBcIlxcdTIyQzBcIiwgWWFjdXRlOiBcIlxceEREXCIsIHlhY3V0ZTogXCJcXHhGRFwiLCBZQWN5OiBcIlxcdTA0MkZcIiwgeWFjeTogXCJcXHUwNDRGXCIsIFljaXJjOiBcIlxcdTAxNzZcIiwgeWNpcmM6IFwiXFx1MDE3N1wiLCBZY3k6IFwiXFx1MDQyQlwiLCB5Y3k6IFwiXFx1MDQ0QlwiLCB5ZW46IFwiXFx4QTVcIiwgWWZyOiBcIlxcdXsxRDUxQ31cIiwgeWZyOiBcIlxcdXsxRDUzNn1cIiwgWUljeTogXCJcXHUwNDA3XCIsIHlpY3k6IFwiXFx1MDQ1N1wiLCBZb3BmOiBcIlxcdXsxRDU1MH1cIiwgeW9wZjogXCJcXHV7MUQ1NkF9XCIsIFlzY3I6IFwiXFx1ezFENEI0fVwiLCB5c2NyOiBcIlxcdXsxRDRDRX1cIiwgWVVjeTogXCJcXHUwNDJFXCIsIHl1Y3k6IFwiXFx1MDQ0RVwiLCB5dW1sOiBcIlxceEZGXCIsIFl1bWw6IFwiXFx1MDE3OFwiLCBaYWN1dGU6IFwiXFx1MDE3OVwiLCB6YWN1dGU6IFwiXFx1MDE3QVwiLCBaY2Fyb246IFwiXFx1MDE3RFwiLCB6Y2Fyb246IFwiXFx1MDE3RVwiLCBaY3k6IFwiXFx1MDQxN1wiLCB6Y3k6IFwiXFx1MDQzN1wiLCBaZG90OiBcIlxcdTAxN0JcIiwgemRvdDogXCJcXHUwMTdDXCIsIHplZXRyZjogXCJcXHUyMTI4XCIsIFplcm9XaWR0aFNwYWNlOiBcIlxcdTIwMEJcIiwgWmV0YTogXCJcXHUwMzk2XCIsIHpldGE6IFwiXFx1MDNCNlwiLCB6ZnI6IFwiXFx1ezFENTM3fVwiLCBaZnI6IFwiXFx1MjEyOFwiLCBaSGN5OiBcIlxcdTA0MTZcIiwgemhjeTogXCJcXHUwNDM2XCIsIHppZ3JhcnI6IFwiXFx1MjFERFwiLCB6b3BmOiBcIlxcdXsxRDU2Qn1cIiwgWm9wZjogXCJcXHUyMTI0XCIsIFpzY3I6IFwiXFx1ezFENEI1fVwiLCB6c2NyOiBcIlxcdXsxRDRDRn1cIiwgendqOiBcIlxcdTIwMERcIiwgenduajogXCJcXHUyMDBDXCIgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzXG52YXIgcmVxdWlyZV9lbnRpdGllczIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9lbnRpdGllcy5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9lbnRpdGllcygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleC5qc1xudmFyIHJlcXVpcmVfcmVnZXggPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSAvWyEtIyUtXFwqLC1cXC86O1xcP0BcXFstXFxdX1xce1xcfVxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTA5RkRcXHUwQTc2XFx1MEFGMFxcdTBDODRcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNEVcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODAxXFx1REQ2RnxcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDNbXFx1REY1NS1cXHVERjU5XXxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzhcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDVbXFx1REM0Qi1cXHVEQzRGXFx1REM1QlxcdURDNURcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REU2MC1cXHVERTZDXFx1REYzQy1cXHVERjNFXXxcXHVEODA2W1xcdURDM0JcXHVERTNGLVxcdURFNDZcXHVERTlBLVxcdURFOUNcXHVERTlFLVxcdURFQTJdfFxcdUQ4MDdbXFx1REM0MS1cXHVEQzQ1XFx1REM3MFxcdURDNzFcXHVERUY3XFx1REVGOF18XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF18XFx1RDgxQltcXHVERTk3LVxcdURFOUFdfFxcdUQ4MkZcXHVEQzlGfFxcdUQ4MzZbXFx1REU4Ny1cXHVERThCXXxcXHVEODNBW1xcdURENUVcXHVERDVGXS87XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWR1cmwvZW5jb2RlLmpzXG52YXIgcmVxdWlyZV9lbmNvZGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWR1cmwvZW5jb2RlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGVuY29kZUNhY2hlID0ge307XG4gICAgZnVuY3Rpb24gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSkge1xuICAgICAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgIH1cbiAgICAgIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgICAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgIGlmICgvXlswLTlhLXpdJC9pLnRlc3QoY2gpKSB7XG4gICAgICAgICAgY2FjaGUucHVzaChjaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGUucHVzaChcIiVcIiArIChcIjBcIiArIGkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGUoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xuICAgICAgdmFyIGksIGwsIGNvZGUyLCBuZXh0Q29kZSwgY2FjaGUsIHJlc3VsdCA9IFwiXCI7XG4gICAgICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAga2VlcEVzY2FwZWQgPSBleGNsdWRlO1xuICAgICAgICBleGNsdWRlID0gZW5jb2RlLmRlZmF1bHRDaGFycztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Yga2VlcEVzY2FwZWQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAga2VlcEVzY2FwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY2FjaGUgPSBnZXRFbmNvZGVDYWNoZShleGNsdWRlKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvZGUyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChrZWVwRXNjYXBlZCAmJiBjb2RlMiA9PT0gMzcgJiYgaSArIDIgPCBsKSB7XG4gICAgICAgICAgaWYgKC9eWzAtOWEtZl17Mn0kL2kudGVzdChzdHJpbmcuc2xpY2UoaSArIDEsIGkgKyAzKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmcuc2xpY2UoaSwgaSArIDMpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlMiA8IDEyOCkge1xuICAgICAgICAgIHJlc3VsdCArPSBjYWNoZVtjb2RlMl07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUyID49IDU1Mjk2ICYmIGNvZGUyIDw9IDU3MzQzKSB7XG4gICAgICAgICAgaWYgKGNvZGUyID49IDU1Mjk2ICYmIGNvZGUyIDw9IDU2MzE5ICYmIGkgKyAxIDwgbCkge1xuICAgICAgICAgICAgbmV4dENvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAobmV4dENvZGUgPj0gNTYzMjAgJiYgbmV4dENvZGUgPD0gNTczNDMpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0gKyBzdHJpbmdbaSArIDFdKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ICs9IFwiJUVGJUJGJUJEXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZW5jb2RlLmRlZmF1bHRDaGFycyA9IFwiOy8/OkAmPSskLC1fLiF+KicoKSNcIjtcbiAgICBlbmNvZGUuY29tcG9uZW50Q2hhcnMgPSBcIi1fLiF+KicoKVwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZW5jb2RlO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21kdXJsL2RlY29kZS5qc1xudmFyIHJlcXVpcmVfZGVjb2RlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21kdXJsL2RlY29kZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBkZWNvZGVDYWNoZSA9IHt9O1xuICAgIGZ1bmN0aW9uIGdldERlY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgICAgIHZhciBpLCBjaCwgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXTtcbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9XG4gICAgICBjYWNoZSA9IGRlY29kZUNhY2hlW2V4Y2x1ZGVdID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICAgICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gZXhjbHVkZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBjYWNoZVtjaF0gPSBcIiVcIiArIChcIjBcIiArIGNoLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGV4Y2x1ZGUpIHtcbiAgICAgIHZhciBjYWNoZTtcbiAgICAgIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBleGNsdWRlID0gZGVjb2RlLmRlZmF1bHRDaGFycztcbiAgICAgIH1cbiAgICAgIGNhY2hlID0gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSk7XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyglW2EtZjAtOV17Mn0pKy9naSwgZnVuY3Rpb24oc2VxKSB7XG4gICAgICAgIHZhciBpLCBsLCBiMSwgYjIsIGIzLCBiNCwgY2hyLCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gc2VxLmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuICAgICAgICAgIGIxID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxLCBpICsgMyksIDE2KTtcbiAgICAgICAgICBpZiAoYjEgPCAxMjgpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjYWNoZVtiMV07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChiMSAmIDIyNCkgPT09IDE5MiAmJiBpICsgMyA8IGwpIHtcbiAgICAgICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcbiAgICAgICAgICAgIGlmICgoYjIgJiAxOTIpID09PSAxMjgpIHtcbiAgICAgICAgICAgICAgY2hyID0gYjEgPDwgNiAmIDE5ODQgfCBiMiAmIDYzO1xuICAgICAgICAgICAgICBpZiAoY2hyIDwgMTI4KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFx1RkZGRFxcdUZGRkRcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoYjEgJiAyNDApID09PSAyMjQgJiYgaSArIDYgPCBsKSB7XG4gICAgICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG4gICAgICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG4gICAgICAgICAgICBpZiAoKGIyICYgMTkyKSA9PT0gMTI4ICYmIChiMyAmIDE5MikgPT09IDEyOCkge1xuICAgICAgICAgICAgICBjaHIgPSBiMSA8PCAxMiAmIDYxNDQwIHwgYjIgPDwgNiAmIDQwMzIgfCBiMyAmIDYzO1xuICAgICAgICAgICAgICBpZiAoY2hyIDwgMjA0OCB8fCBjaHIgPj0gNTUyOTYgJiYgY2hyIDw9IDU3MzQzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFx1RkZGRFxcdUZGRkRcXHVGRkZEXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpICs9IDY7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGIxICYgMjQ4KSA9PT0gMjQwICYmIGkgKyA5IDwgbCkge1xuICAgICAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xuICAgICAgICAgICAgYjQgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEwLCBpICsgMTIpLCAxNik7XG4gICAgICAgICAgICBpZiAoKGIyICYgMTkyKSA9PT0gMTI4ICYmIChiMyAmIDE5MikgPT09IDEyOCAmJiAoYjQgJiAxOTIpID09PSAxMjgpIHtcbiAgICAgICAgICAgICAgY2hyID0gYjEgPDwgMTggJiAxODM1MDA4IHwgYjIgPDwgMTIgJiAyNTgwNDggfCBiMyA8PCA2ICYgNDAzMiB8IGI0ICYgNjM7XG4gICAgICAgICAgICAgIGlmIChjaHIgPCA2NTUzNiB8fCBjaHIgPiAxMTE0MTExKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFx1RkZGRFxcdUZGRkRcXHVGRkZEXFx1RkZGRFwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNociAtPSA2NTUzNjtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiArIChjaHIgPj4gMTApLCA1NjMyMCArIChjaHIgJiAxMDIzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaSArPSA5O1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ICs9IFwiXFx1RkZGRFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZGVjb2RlLmRlZmF1bHRDaGFycyA9IFwiOy8/OkAmPSskLCNcIjtcbiAgICBkZWNvZGUuY29tcG9uZW50Q2hhcnMgPSBcIlwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZGVjb2RlO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21kdXJsL2Zvcm1hdC5qc1xudmFyIHJlcXVpcmVfZm9ybWF0ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21kdXJsL2Zvcm1hdC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9ybWF0Mih1cmwpIHtcbiAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgcmVzdWx0ICs9IHVybC5wcm90b2NvbCB8fCBcIlwiO1xuICAgICAgcmVzdWx0ICs9IHVybC5zbGFzaGVzID8gXCIvL1wiIDogXCJcIjtcbiAgICAgIHJlc3VsdCArPSB1cmwuYXV0aCA/IHVybC5hdXRoICsgXCJAXCIgOiBcIlwiO1xuICAgICAgaWYgKHVybC5ob3N0bmFtZSAmJiB1cmwuaG9zdG5hbWUuaW5kZXhPZihcIjpcIikgIT09IC0xKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIltcIiArIHVybC5ob3N0bmFtZSArIFwiXVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IHVybC5ob3N0bmFtZSB8fCBcIlwiO1xuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IHVybC5wb3J0ID8gXCI6XCIgKyB1cmwucG9ydCA6IFwiXCI7XG4gICAgICByZXN1bHQgKz0gdXJsLnBhdGhuYW1lIHx8IFwiXCI7XG4gICAgICByZXN1bHQgKz0gdXJsLnNlYXJjaCB8fCBcIlwiO1xuICAgICAgcmVzdWx0ICs9IHVybC5oYXNoIHx8IFwiXCI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWR1cmwvcGFyc2UuanNcbnZhciByZXF1aXJlX3BhcnNlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21kdXJsL3BhcnNlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gVXJsKCkge1xuICAgICAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gICAgICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICAgICAgdGhpcy5hdXRoID0gbnVsbDtcbiAgICAgIHRoaXMucG9ydCA9IG51bGw7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHRoaXMuaGFzaCA9IG51bGw7XG4gICAgICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2k7XG4gICAgdmFyIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLztcbiAgICB2YXIgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvO1xuICAgIHZhciBkZWxpbXMgPSBbXCI8XCIsIFwiPlwiLCAnXCInLCBcImBcIiwgXCIgXCIsIFwiXFxyXCIsIFwiXFxuXCIsIFwiXHRcIl07XG4gICAgdmFyIHVud2lzZSA9IFtcIntcIiwgXCJ9XCIsIFwifFwiLCBcIlxcXFxcIiwgXCJeXCIsIFwiYFwiXS5jb25jYXQoZGVsaW1zKTtcbiAgICB2YXIgYXV0b0VzY2FwZSA9IFtcIidcIl0uY29uY2F0KHVud2lzZSk7XG4gICAgdmFyIG5vbkhvc3RDaGFycyA9IFtcIiVcIiwgXCIvXCIsIFwiP1wiLCBcIjtcIiwgXCIjXCJdLmNvbmNhdChhdXRvRXNjYXBlKTtcbiAgICB2YXIgaG9zdEVuZGluZ0NoYXJzID0gW1wiL1wiLCBcIj9cIiwgXCIjXCJdO1xuICAgIHZhciBob3N0bmFtZU1heExlbiA9IDI1NTtcbiAgICB2YXIgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLztcbiAgICB2YXIgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC87XG4gICAgdmFyIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICBcImphdmFzY3JpcHRcIjogdHJ1ZSxcbiAgICAgIFwiamF2YXNjcmlwdDpcIjogdHJ1ZVxuICAgIH07XG4gICAgdmFyIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgIFwiaHR0cFwiOiB0cnVlLFxuICAgICAgXCJodHRwc1wiOiB0cnVlLFxuICAgICAgXCJmdHBcIjogdHJ1ZSxcbiAgICAgIFwiZ29waGVyXCI6IHRydWUsXG4gICAgICBcImZpbGVcIjogdHJ1ZSxcbiAgICAgIFwiaHR0cDpcIjogdHJ1ZSxcbiAgICAgIFwiaHR0cHM6XCI6IHRydWUsXG4gICAgICBcImZ0cDpcIjogdHJ1ZSxcbiAgICAgIFwiZ29waGVyOlwiOiB0cnVlLFxuICAgICAgXCJmaWxlOlwiOiB0cnVlXG4gICAgfTtcbiAgICBmdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gICAgICBpZiAodXJsICYmIHVybCBpbnN0YW5jZW9mIFVybCkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgfVxuICAgICAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gICAgICB1LnBhcnNlKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICAgICAgcmV0dXJuIHU7XG4gICAgfVxuICAgIFVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gICAgICB2YXIgaSwgbCwgbG93ZXJQcm90bywgaGVjLCBzbGFzaGVzLCByZXN0ID0gdXJsO1xuICAgICAgcmVzdCA9IHJlc3QudHJpbSgpO1xuICAgICAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoXCIjXCIpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgICAgIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLnByb3RvY29sID0gcHJvdG87XG4gICAgICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgICAgIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gXCIvL1wiO1xuICAgICAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmIChzbGFzaGVzIHx8IHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKFwiQFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKFwiQFwiLCBob3N0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgfVxuICAgICAgICBob3N0RW5kID0gLTE7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdFtob3N0RW5kIC0gMV0gPT09IFwiOlwiKSB7XG4gICAgICAgICAgaG9zdEVuZC0tO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG4gICAgICAgIHRoaXMucGFyc2VIb3N0KGhvc3QpO1xuICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCBcIlwiO1xuICAgICAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gXCJbXCIgJiYgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSBcIl1cIjtcbiAgICAgICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgIHZhciBuZXdwYXJ0ID0gXCJcIjtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgICAgIG5ld3BhcnQgKz0gXCJ4XCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3QgPSBub3RIb3N0LmpvaW4oXCIuXCIpICsgcmVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbihcIi5cIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKFwiI1wiKTtcbiAgICAgIGlmIChoYXNoICE9PSAtMSkge1xuICAgICAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gICAgICB9XG4gICAgICB2YXIgcW0gPSByZXN0LmluZGV4T2YoXCI/XCIpO1xuICAgICAgaWYgKHFtICE9PSAtMSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gICAgICB9XG4gICAgICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICAgICAgdGhpcy5wYXRobmFtZSA9IFwiXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oaG9zdCkge1xuICAgICAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgcG9ydCA9IHBvcnRbMF07XG4gICAgICAgIGlmIChwb3J0ICE9PSBcIjpcIikge1xuICAgICAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmIChob3N0KSB7XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xuICAgICAgfVxuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1cmxQYXJzZTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tZHVybC9pbmRleC5qc1xudmFyIHJlcXVpcmVfbWR1cmwgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWR1cmwvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSByZXF1aXJlX2VuY29kZSgpO1xuICAgIG1vZHVsZS5leHBvcnRzLmRlY29kZSA9IHJlcXVpcmVfZGVjb2RlKCk7XG4gICAgbW9kdWxlLmV4cG9ydHMuZm9ybWF0ID0gcmVxdWlyZV9mb3JtYXQoKTtcbiAgICBtb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmVfcGFyc2UoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5qc1xudmFyIHJlcXVpcmVfcmVnZXgyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSAvW1xcMC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdLztcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4LmpzXG52YXIgcmVxdWlyZV9yZWdleDMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gL1tcXDAtXFx4MUZcXHg3Ri1cXHg5Rl0vO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXguanNcbnZhciByZXF1aXJlX3JlZ2V4NCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL0NmL3JlZ2V4LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSAvW1xceEFEXFx1MDYwMC1cXHUwNjA1XFx1MDYxQ1xcdTA2RERcXHUwNzBGXFx1MDhFMlxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNjRcXHUyMDY2LVxcdTIwNkZcXHVGRUZGXFx1RkZGOS1cXHVGRkZCXXxcXHVEODA0W1xcdURDQkRcXHVEQ0NEXXxcXHVEODJGW1xcdURDQTAtXFx1RENBM118XFx1RDgzNFtcXHVERDczLVxcdUREN0FdfFxcdURCNDBbXFx1REMwMVxcdURDMjAtXFx1REM3Rl0vO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qc1xudmFyIHJlcXVpcmVfcmVnZXg1ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gL1sgXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDBdLztcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy91Yy5taWNyby9pbmRleC5qc1xudmFyIHJlcXVpcmVfdWMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvdWMubWljcm8vaW5kZXguanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZXhwb3J0cy5BbnkgPSByZXF1aXJlX3JlZ2V4MigpO1xuICAgIGV4cG9ydHMuQ2MgPSByZXF1aXJlX3JlZ2V4MygpO1xuICAgIGV4cG9ydHMuQ2YgPSByZXF1aXJlX3JlZ2V4NCgpO1xuICAgIGV4cG9ydHMuUCA9IHJlcXVpcmVfcmVnZXgoKTtcbiAgICBleHBvcnRzLlogPSByZXF1aXJlX3JlZ2V4NSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vdXRpbHMuanNcbnZhciByZXF1aXJlX3V0aWxzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vdXRpbHMuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gX2NsYXNzKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICAgIHJldHVybiBfY2xhc3Mob2JqKSA9PT0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbiAgICB9XG4gICAgdmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NpZ24ob2JqKSB7XG4gICAgICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyBcIm11c3QgYmUgb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJyYXlSZXBsYWNlQXQoc3JjLCBwb3MsIG5ld0VsZW1lbnRzKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KHNyYy5zbGljZSgwLCBwb3MpLCBuZXdFbGVtZW50cywgc3JjLnNsaWNlKHBvcyArIDEpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVudGl0eUNvZGUoYykge1xuICAgICAgaWYgKGMgPj0gNTUyOTYgJiYgYyA8PSA1NzM0Mykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoYyA+PSA2NDk3NiAmJiBjIDw9IDY1MDA3KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICgoYyAmIDY1NTM1KSA9PT0gNjU1MzUgfHwgKGMgJiA2NTUzNSkgPT09IDY1NTM0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID49IDAgJiYgYyA8PSA4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAxMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoYyA+PSAxNCAmJiBjIDw9IDMxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID49IDEyNyAmJiBjIDw9IDE1OSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoYyA+IDExMTQxMTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoYykge1xuICAgICAgaWYgKGMgPiA2NTUzNSkge1xuICAgICAgICBjIC09IDY1NTM2O1xuICAgICAgICB2YXIgc3Vycm9nYXRlMSA9IDU1Mjk2ICsgKGMgPj4gMTApLCBzdXJyb2dhdGUyID0gNTYzMjAgKyAoYyAmIDEwMjMpO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzdXJyb2dhdGUxLCBzdXJyb2dhdGUyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgIH1cbiAgICB2YXIgVU5FU0NBUEVfTURfUkUgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS5cXC86Ozw9Pj9AW1xcXFxcXF1eX2B7fH1+XSkvZztcbiAgICB2YXIgRU5USVRZX1JFID0gLyYoW2EteiNdW2EtejAtOV17MSwzMX0pOy9naTtcbiAgICB2YXIgVU5FU0NBUEVfQUxMX1JFID0gbmV3IFJlZ0V4cChVTkVTQ0FQRV9NRF9SRS5zb3VyY2UgKyBcInxcIiArIEVOVElUWV9SRS5zb3VyY2UsIFwiZ2lcIik7XG4gICAgdmFyIERJR0lUQUxfRU5USVRZX1RFU1RfUkUgPSAvXiMoKD86eFthLWYwLTldezEsOH18WzAtOV17MSw4fSkpL2k7XG4gICAgdmFyIGVudGl0aWVzID0gcmVxdWlyZV9lbnRpdGllczIoKTtcbiAgICBmdW5jdGlvbiByZXBsYWNlRW50aXR5UGF0dGVybihtYXRjaCwgbmFtZSkge1xuICAgICAgdmFyIGNvZGUyID0gMDtcbiAgICAgIGlmIChoYXMoZW50aXRpZXMsIG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBlbnRpdGllc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDM1ICYmIERJR0lUQUxfRU5USVRZX1RFU1RfUkUudGVzdChuYW1lKSkge1xuICAgICAgICBjb2RlMiA9IG5hbWVbMV0udG9Mb3dlckNhc2UoKSA9PT0gXCJ4XCIgPyBwYXJzZUludChuYW1lLnNsaWNlKDIpLCAxNikgOiBwYXJzZUludChuYW1lLnNsaWNlKDEpLCAxMCk7XG4gICAgICAgIGlmIChpc1ZhbGlkRW50aXR5Q29kZShjb2RlMikpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjb2RlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVNZChzdHIpIHtcbiAgICAgIGlmIChzdHIuaW5kZXhPZihcIlxcXFxcIikgPCAwKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfTURfUkUsIFwiJDFcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlQWxsKHN0cikge1xuICAgICAgaWYgKHN0ci5pbmRleE9mKFwiXFxcXFwiKSA8IDAgJiYgc3RyLmluZGV4T2YoXCImXCIpIDwgMCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKFVORVNDQVBFX0FMTF9SRSwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZWQsIGVudGl0eSkge1xuICAgICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAgIHJldHVybiBlc2NhcGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBsYWNlRW50aXR5UGF0dGVybihtYXRjaCwgZW50aXR5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgSFRNTF9FU0NBUEVfVEVTVF9SRSA9IC9bJjw+XCJdLztcbiAgICB2YXIgSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSA9IC9bJjw+XCJdL2c7XG4gICAgdmFyIEhUTUxfUkVQTEFDRU1FTlRTID0ge1xuICAgICAgXCImXCI6IFwiJmFtcDtcIixcbiAgICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICAgICdcIic6IFwiJnF1b3Q7XCJcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VVbnNhZmVDaGFyKGNoKSB7XG4gICAgICByZXR1cm4gSFRNTF9SRVBMQUNFTUVOVFNbY2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVIdG1sMihzdHIpIHtcbiAgICAgIGlmIChIVE1MX0VTQ0FQRV9URVNUX1JFLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSwgcmVwbGFjZVVuc2FmZUNoYXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgdmFyIFJFR0VYUF9FU0NBUEVfUkUgPSAvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nO1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJFKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR0VYUF9FU0NBUEVfUkUsIFwiXFxcXCQmXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1NwYWNlKGNvZGUyKSB7XG4gICAgICBzd2l0Y2ggKGNvZGUyKSB7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNvZGUyKSB7XG4gICAgICBpZiAoY29kZTIgPj0gODE5MiAmJiBjb2RlMiA8PSA4MjAyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjb2RlMikge1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgIGNhc2UgMTYwOlxuICAgICAgICBjYXNlIDU3NjA6XG4gICAgICAgIGNhc2UgODIzOTpcbiAgICAgICAgY2FzZSA4Mjg3OlxuICAgICAgICBjYXNlIDEyMjg4OlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgVU5JQ09ERV9QVU5DVF9SRSA9IHJlcXVpcmVfcmVnZXgoKTtcbiAgICBmdW5jdGlvbiBpc1B1bmN0Q2hhcihjaCkge1xuICAgICAgcmV0dXJuIFVOSUNPREVfUFVOQ1RfUkUudGVzdChjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTWRBc2NpaVB1bmN0KGNoKSB7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgMzM6XG4gICAgICAgIGNhc2UgMzQ6XG4gICAgICAgIGNhc2UgMzU6XG4gICAgICAgIGNhc2UgMzY6XG4gICAgICAgIGNhc2UgMzc6XG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgIGNhc2UgNDA6XG4gICAgICAgIGNhc2UgNDE6XG4gICAgICAgIGNhc2UgNDI6XG4gICAgICAgIGNhc2UgNDM6XG4gICAgICAgIGNhc2UgNDQ6XG4gICAgICAgIGNhc2UgNDU6XG4gICAgICAgIGNhc2UgNDY6XG4gICAgICAgIGNhc2UgNDc6XG4gICAgICAgIGNhc2UgNTg6XG4gICAgICAgIGNhc2UgNTk6XG4gICAgICAgIGNhc2UgNjA6XG4gICAgICAgIGNhc2UgNjE6XG4gICAgICAgIGNhc2UgNjI6XG4gICAgICAgIGNhc2UgNjM6XG4gICAgICAgIGNhc2UgNjQ6XG4gICAgICAgIGNhc2UgOTE6XG4gICAgICAgIGNhc2UgOTI6XG4gICAgICAgIGNhc2UgOTM6XG4gICAgICAgIGNhc2UgOTQ6XG4gICAgICAgIGNhc2UgOTU6XG4gICAgICAgIGNhc2UgOTY6XG4gICAgICAgIGNhc2UgMTIzOlxuICAgICAgICBjYXNlIDEyNDpcbiAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgIGNhc2UgMTI2OlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUmVmZXJlbmNlKHN0cikge1xuICAgICAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbiAgICAgIGlmIChcIlxcdTFFOUVcIi50b0xvd2VyQ2FzZSgpID09PSBcIlxcdTFFN0VcIikge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgv4bqeL2csIFwiXFx4REZcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgZXhwb3J0cy5saWIgPSB7fTtcbiAgICBleHBvcnRzLmxpYi5tZHVybCA9IHJlcXVpcmVfbWR1cmwoKTtcbiAgICBleHBvcnRzLmxpYi51Y21pY3JvID0gcmVxdWlyZV91YygpO1xuICAgIGV4cG9ydHMuYXNzaWduID0gYXNzaWduO1xuICAgIGV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBleHBvcnRzLmhhcyA9IGhhcztcbiAgICBleHBvcnRzLnVuZXNjYXBlTWQgPSB1bmVzY2FwZU1kO1xuICAgIGV4cG9ydHMudW5lc2NhcGVBbGwgPSB1bmVzY2FwZUFsbDtcbiAgICBleHBvcnRzLmlzVmFsaWRFbnRpdHlDb2RlID0gaXNWYWxpZEVudGl0eUNvZGU7XG4gICAgZXhwb3J0cy5mcm9tQ29kZVBvaW50ID0gZnJvbUNvZGVQb2ludDtcbiAgICBleHBvcnRzLmVzY2FwZUh0bWwgPSBlc2NhcGVIdG1sMjtcbiAgICBleHBvcnRzLmFycmF5UmVwbGFjZUF0ID0gYXJyYXlSZXBsYWNlQXQ7XG4gICAgZXhwb3J0cy5pc1NwYWNlID0gaXNTcGFjZTtcbiAgICBleHBvcnRzLmlzV2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZTtcbiAgICBleHBvcnRzLmlzTWRBc2NpaVB1bmN0ID0gaXNNZEFzY2lpUHVuY3Q7XG4gICAgZXhwb3J0cy5pc1B1bmN0Q2hhciA9IGlzUHVuY3RDaGFyO1xuICAgIGV4cG9ydHMuZXNjYXBlUkUgPSBlc2NhcGVSRTtcbiAgICBleHBvcnRzLm5vcm1hbGl6ZVJlZmVyZW5jZSA9IG5vcm1hbGl6ZVJlZmVyZW5jZTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2xhYmVsLmpzXG52YXIgcmVxdWlyZV9wYXJzZV9saW5rX2xhYmVsID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGFydCwgZGlzYWJsZU5lc3RlZCkge1xuICAgICAgdmFyIGxldmVsLCBmb3VuZCwgbWFya2VyLCBwcmV2UG9zLCBsYWJlbEVuZCA9IC0xLCBtYXgyID0gc3RhdGUucG9zTWF4LCBvbGRQb3MgPSBzdGF0ZS5wb3M7XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydCArIDE7XG4gICAgICBsZXZlbCA9IDE7XG4gICAgICB3aGlsZSAoc3RhdGUucG9zIDwgbWF4Mikge1xuICAgICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpO1xuICAgICAgICBpZiAobWFya2VyID09PSA5Mykge1xuICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldlBvcyA9IHN0YXRlLnBvcztcbiAgICAgICAgc3RhdGUubWQuaW5saW5lLnNraXBUb2tlbihzdGF0ZSk7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IDkxKSB7XG4gICAgICAgICAgaWYgKHByZXZQb3MgPT09IHN0YXRlLnBvcyAtIDEpIHtcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXNhYmxlTmVzdGVkKSB7XG4gICAgICAgICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgbGFiZWxFbmQgPSBzdGF0ZS5wb3M7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gbGFiZWxFbmQ7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uLmpzXG52YXIgcmVxdWlyZV9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24uanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlX3V0aWxzKCkudW5lc2NhcGVBbGw7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4Mikge1xuICAgICAgdmFyIGNvZGUyLCBsZXZlbCwgbGluZXMgPSAwLCBzdGFydCA9IHBvcywgcmVzdWx0ID0ge1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgbGluZXM6IDAsXG4gICAgICAgIHN0cjogXCJcIlxuICAgICAgfTtcbiAgICAgIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSA2MCkge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgd2hpbGUgKHBvcyA8IG1heDIpIHtcbiAgICAgICAgICBjb2RlMiA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgaWYgKGNvZGUyID09PSAxMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGUyID09PSA2MCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGUyID09PSA2Mikge1xuICAgICAgICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICAgICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XG4gICAgICAgICAgICByZXN1bHQub2sgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGUyID09PSA5MiAmJiBwb3MgKyAxIDwgbWF4Mikge1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxldmVsID0gMDtcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgyKSB7XG4gICAgICAgIGNvZGUyID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGNvZGUyID09PSAzMikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlMiA8IDMyIHx8IGNvZGUyID09PSAxMjcpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZTIgPT09IDkyICYmIHBvcyArIDEgPCBtYXgyKSB7XG4gICAgICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KHBvcyArIDEpID09PSAzMikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlMiA9PT0gNDApIHtcbiAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICAgIGlmIChsZXZlbCA+IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZTIgPT09IDQxKSB7XG4gICAgICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA9PT0gcG9zKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQsIHBvcykpO1xuICAgICAgcmVzdWx0LmxpbmVzID0gbGluZXM7XG4gICAgICByZXN1bHQucG9zID0gcG9zO1xuICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX3RpdGxlLmpzXG52YXIgcmVxdWlyZV9wYXJzZV9saW5rX3RpdGxlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlX3V0aWxzKCkudW5lc2NhcGVBbGw7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4Mikge1xuICAgICAgdmFyIGNvZGUyLCBtYXJrZXIsIGxpbmVzID0gMCwgc3RhcnQgPSBwb3MsIHJlc3VsdCA9IHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBwb3M6IDAsXG4gICAgICAgIGxpbmVzOiAwLFxuICAgICAgICBzdHI6IFwiXCJcbiAgICAgIH07XG4gICAgICBpZiAocG9zID49IG1heDIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIG1hcmtlciA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAobWFya2VyICE9PSAzNCAmJiBtYXJrZXIgIT09IDM5ICYmIG1hcmtlciAhPT0gNDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHBvcysrO1xuICAgICAgaWYgKG1hcmtlciA9PT0gNDApIHtcbiAgICAgICAgbWFya2VyID0gNDE7XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zIDwgbWF4Mikge1xuICAgICAgICBjb2RlMiA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChjb2RlMiA9PT0gbWFya2VyKSB7XG4gICAgICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICAgICAgcmVzdWx0LmxpbmVzID0gbGluZXM7XG4gICAgICAgICAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCArIDEsIHBvcykpO1xuICAgICAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlMiA9PT0gNDAgJiYgbWFya2VyID09PSA0MSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZTIgPT09IDEwKSB7XG4gICAgICAgICAgbGluZXMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlMiA9PT0gOTIgJiYgcG9zICsgMSA8IG1heDIpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMTApIHtcbiAgICAgICAgICAgIGxpbmVzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL2luZGV4LmpzXG52YXIgcmVxdWlyZV9oZWxwZXJzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL2luZGV4LmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGV4cG9ydHMucGFyc2VMaW5rTGFiZWwgPSByZXF1aXJlX3BhcnNlX2xpbmtfbGFiZWwoKTtcbiAgICBleHBvcnRzLnBhcnNlTGlua0Rlc3RpbmF0aW9uID0gcmVxdWlyZV9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uKCk7XG4gICAgZXhwb3J0cy5wYXJzZUxpbmtUaXRsZSA9IHJlcXVpcmVfcGFyc2VfbGlua190aXRsZSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9yZW5kZXJlci5qc1xudmFyIHJlcXVpcmVfcmVuZGVyZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3JlbmRlcmVyLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGFzc2lnbiA9IHJlcXVpcmVfdXRpbHMoKS5hc3NpZ247XG4gICAgdmFyIHVuZXNjYXBlQWxsID0gcmVxdWlyZV91dGlscygpLnVuZXNjYXBlQWxsO1xuICAgIHZhciBlc2NhcGVIdG1sMiA9IHJlcXVpcmVfdXRpbHMoKS5lc2NhcGVIdG1sO1xuICAgIHZhciBkZWZhdWx0X3J1bGVzID0ge307XG4gICAgZGVmYXVsdF9ydWxlcy5jb2RlX2lubGluZSA9IGZ1bmN0aW9uKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG4gICAgICByZXR1cm4gXCI8Y29kZVwiICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArIFwiPlwiICsgZXNjYXBlSHRtbDIodG9rZW5zW2lkeF0uY29udGVudCkgKyBcIjwvY29kZT5cIjtcbiAgICB9O1xuICAgIGRlZmF1bHRfcnVsZXMuY29kZV9ibG9jayA9IGZ1bmN0aW9uKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG4gICAgICByZXR1cm4gXCI8cHJlXCIgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgXCI+PGNvZGU+XCIgKyBlc2NhcGVIdG1sMih0b2tlbnNbaWR4XS5jb250ZW50KSArIFwiPC9jb2RlPjwvcHJlPlxcblwiO1xuICAgIH07XG4gICAgZGVmYXVsdF9ydWxlcy5mZW5jZSA9IGZ1bmN0aW9uKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF0sIGluZm8gPSB0b2tlbi5pbmZvID8gdW5lc2NhcGVBbGwodG9rZW4uaW5mbykudHJpbSgpIDogXCJcIiwgbGFuZ05hbWUgPSBcIlwiLCBsYW5nQXR0cnMgPSBcIlwiLCBoaWdobGlnaHRlZCwgaSwgYXJyLCB0bXBBdHRycywgdG1wVG9rZW47XG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBhcnIgPSBpbmZvLnNwbGl0KC8oXFxzKykvZyk7XG4gICAgICAgIGxhbmdOYW1lID0gYXJyWzBdO1xuICAgICAgICBsYW5nQXR0cnMgPSBhcnIuc2xpY2UoMikuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmhpZ2hsaWdodCkge1xuICAgICAgICBoaWdobGlnaHRlZCA9IG9wdGlvbnMuaGlnaGxpZ2h0KHRva2VuLmNvbnRlbnQsIGxhbmdOYW1lLCBsYW5nQXR0cnMpIHx8IGVzY2FwZUh0bWwyKHRva2VuLmNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGlnaGxpZ2h0ZWQgPSBlc2NhcGVIdG1sMih0b2tlbi5jb250ZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChoaWdobGlnaHRlZC5pbmRleE9mKFwiPHByZVwiKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0ZWQgKyBcIlxcblwiO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgaSA9IHRva2VuLmF0dHJJbmRleChcImNsYXNzXCIpO1xuICAgICAgICB0bXBBdHRycyA9IHRva2VuLmF0dHJzID8gdG9rZW4uYXR0cnMuc2xpY2UoKSA6IFtdO1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICB0bXBBdHRycy5wdXNoKFtcImNsYXNzXCIsIG9wdGlvbnMubGFuZ1ByZWZpeCArIGxhbmdOYW1lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG1wQXR0cnNbaV0gPSB0bXBBdHRyc1tpXS5zbGljZSgpO1xuICAgICAgICAgIHRtcEF0dHJzW2ldWzFdICs9IFwiIFwiICsgb3B0aW9ucy5sYW5nUHJlZml4ICsgbGFuZ05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdG1wVG9rZW4gPSB7XG4gICAgICAgICAgYXR0cnM6IHRtcEF0dHJzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBcIjxwcmU+PGNvZGVcIiArIHNsZi5yZW5kZXJBdHRycyh0bXBUb2tlbikgKyBcIj5cIiArIGhpZ2hsaWdodGVkICsgXCI8L2NvZGU+PC9wcmU+XFxuXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCI8cHJlPjxjb2RlXCIgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgXCI+XCIgKyBoaWdobGlnaHRlZCArIFwiPC9jb2RlPjwvcHJlPlxcblwiO1xuICAgIH07XG4gICAgZGVmYXVsdF9ydWxlcy5pbWFnZSA9IGZ1bmN0aW9uKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG4gICAgICB0b2tlbi5hdHRyc1t0b2tlbi5hdHRySW5kZXgoXCJhbHRcIildWzFdID0gc2xmLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbi5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICAgIHJldHVybiBzbGYucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgZGVmYXVsdF9ydWxlcy5oYXJkYnJlYWsgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMueGh0bWxPdXQgPyBcIjxiciAvPlxcblwiIDogXCI8YnI+XFxuXCI7XG4gICAgfTtcbiAgICBkZWZhdWx0X3J1bGVzLnNvZnRicmVhayA9IGZ1bmN0aW9uKHRva2VucywgaWR4LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5icmVha3MgPyBvcHRpb25zLnhodG1sT3V0ID8gXCI8YnIgLz5cXG5cIiA6IFwiPGJyPlxcblwiIDogXCJcXG5cIjtcbiAgICB9O1xuICAgIGRlZmF1bHRfcnVsZXMudGV4dCA9IGZ1bmN0aW9uKHRva2VucywgaWR4KSB7XG4gICAgICByZXR1cm4gZXNjYXBlSHRtbDIodG9rZW5zW2lkeF0uY29udGVudCk7XG4gICAgfTtcbiAgICBkZWZhdWx0X3J1bGVzLmh0bWxfYmxvY2sgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCkge1xuICAgICAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG4gICAgfTtcbiAgICBkZWZhdWx0X3J1bGVzLmh0bWxfaW5saW5lID0gZnVuY3Rpb24odG9rZW5zLCBpZHgpIHtcbiAgICAgIHJldHVybiB0b2tlbnNbaWR4XS5jb250ZW50O1xuICAgIH07XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYXNzaWduKHt9LCBkZWZhdWx0X3J1bGVzKTtcbiAgICB9XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckF0dHJzID0gZnVuY3Rpb24gcmVuZGVyQXR0cnModG9rZW4pIHtcbiAgICAgIHZhciBpLCBsLCByZXN1bHQ7XG4gICAgICBpZiAoIXRva2VuLmF0dHJzKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gXCJcIjtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0b2tlbi5hdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgZXNjYXBlSHRtbDIodG9rZW4uYXR0cnNbaV1bMF0pICsgJz1cIicgKyBlc2NhcGVIdG1sMih0b2tlbi5hdHRyc1tpXVsxXSkgKyAnXCInO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbiA9IGZ1bmN0aW9uIHJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbmV4dFRva2VuLCByZXN1bHQgPSBcIlwiLCBuZWVkTGYgPSBmYWxzZSwgdG9rZW4gPSB0b2tlbnNbaWR4XTtcbiAgICAgIGlmICh0b2tlbi5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4uYmxvY2sgJiYgdG9rZW4ubmVzdGluZyAhPT0gLTEgJiYgaWR4ICYmIHRva2Vuc1tpZHggLSAxXS5oaWRkZW4pIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gKHRva2VuLm5lc3RpbmcgPT09IC0xID8gXCI8L1wiIDogXCI8XCIpICsgdG9rZW4udGFnO1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVyQXR0cnModG9rZW4pO1xuICAgICAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDAgJiYgb3B0aW9ucy54aHRtbE91dCkge1xuICAgICAgICByZXN1bHQgKz0gXCIgL1wiO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuLmJsb2NrKSB7XG4gICAgICAgIG5lZWRMZiA9IHRydWU7XG4gICAgICAgIGlmICh0b2tlbi5uZXN0aW5nID09PSAxKSB7XG4gICAgICAgICAgaWYgKGlkeCArIDEgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXh0VG9rZW4gPSB0b2tlbnNbaWR4ICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dFRva2VuLnR5cGUgPT09IFwiaW5saW5lXCIgfHwgbmV4dFRva2VuLmhpZGRlbikge1xuICAgICAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dFRva2VuLm5lc3RpbmcgPT09IC0xICYmIG5leHRUb2tlbi50YWcgPT09IHRva2VuLnRhZykge1xuICAgICAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSBuZWVkTGYgPyBcIj5cXG5cIiA6IFwiPlwiO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbih0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICAgICAgdmFyIHR5cGUsIHJlc3VsdCA9IFwiXCIsIHJ1bGVzID0gdGhpcy5ydWxlcztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGVzW3R5cGVdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHJ1bGVzW3R5cGVdKHRva2VucywgaSwgb3B0aW9ucywgZW52LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZUFzVGV4dCA9IGZ1bmN0aW9uKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRva2Vuc1tpXS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgIHJlc3VsdCArPSB0b2tlbnNbaV0uY29udGVudDtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lQXNUZXh0KHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gXCJzb2Z0YnJlYWtcIikge1xuICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gICAgICB2YXIgaSwgbGVuLCB0eXBlLCByZXN1bHQgPSBcIlwiLCBydWxlcyA9IHRoaXMucnVsZXM7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJpbmxpbmVcIikge1xuICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlcklubGluZSh0b2tlbnNbaV0uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJ1bGVzW3R5cGVdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHJ1bGVzW3Rva2Vuc1tpXS50eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVyVG9rZW4odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXIuanNcbnZhciByZXF1aXJlX3J1bGVyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlci5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGZ1bmN0aW9uIFJ1bGVyKCkge1xuICAgICAgdGhpcy5fX3J1bGVzX18gPSBbXTtcbiAgICAgIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgICB9XG4gICAgUnVsZXIucHJvdG90eXBlLl9fZmluZF9fID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9fcnVsZXNfXy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5fX3J1bGVzX19baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBSdWxlci5wcm90b3R5cGUuX19jb21waWxlX18gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjaGFpbnMgPSBbXCJcIl07XG4gICAgICBzZWxmLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgaWYgKCFydWxlLmVuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcnVsZS5hbHQuZm9yRWFjaChmdW5jdGlvbihhbHROYW1lKSB7XG4gICAgICAgICAgaWYgKGNoYWlucy5pbmRleE9mKGFsdE5hbWUpIDwgMCkge1xuICAgICAgICAgICAgY2hhaW5zLnB1c2goYWx0TmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5fX2NhY2hlX18gPSB7fTtcbiAgICAgIGNoYWlucy5mb3JFYWNoKGZ1bmN0aW9uKGNoYWluKSB7XG4gICAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXSA9IFtdO1xuICAgICAgICBzZWxmLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICBpZiAoIXJ1bGUuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhaW4gJiYgcnVsZS5hbHQuaW5kZXhPZihjaGFpbikgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXS5wdXNoKHJ1bGUuZm4pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgUnVsZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24obmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gICAgICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiBcIiArIG5hbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3J1bGVzX19baW5kZXhdLmZuID0gZm47XG4gICAgICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uYWx0ID0gb3B0LmFsdCB8fCBbXTtcbiAgICAgIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgICB9O1xuICAgIFJ1bGVyLnByb3RvdHlwZS5iZWZvcmUgPSBmdW5jdGlvbihiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18oYmVmb3JlTmFtZSk7XG4gICAgICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiBcIiArIGJlZm9yZU5hbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3J1bGVzX18uc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgICAgIG5hbWU6IHJ1bGVOYW1lLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBmbixcbiAgICAgICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgICB9O1xuICAgIFJ1bGVyLnByb3RvdHlwZS5hZnRlciA9IGZ1bmN0aW9uKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGFmdGVyTmFtZSk7XG4gICAgICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiBcIiArIGFmdGVyTmFtZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXggKyAxLCAwLCB7XG4gICAgICAgIG5hbWU6IHJ1bGVOYW1lLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBmbixcbiAgICAgICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgICB9O1xuICAgIFJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24ocnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XG4gICAgICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMuX19ydWxlc19fLnB1c2goe1xuICAgICAgICBuYW1lOiBydWxlTmFtZSxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgZm4sXG4gICAgICAgIGFsdDogb3B0LmFsdCB8fCBbXVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG4gICAgfTtcbiAgICBSdWxlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24obGlzdDIsIGlnbm9yZUludmFsaWQpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0MikpIHtcbiAgICAgICAgbGlzdDIgPSBbbGlzdDJdO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgbGlzdDIuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJ1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lIFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBSdWxlci5wcm90b3R5cGUuZW5hYmxlT25seSA9IGZ1bmN0aW9uKGxpc3QyLCBpZ25vcmVJbnZhbGlkKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdDIpKSB7XG4gICAgICAgIGxpc3QyID0gW2xpc3QyXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICBydWxlLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbmFibGUobGlzdDIsIGlnbm9yZUludmFsaWQpO1xuICAgIH07XG4gICAgUnVsZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbihsaXN0MiwgaWdub3JlSW52YWxpZCkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QyKSkge1xuICAgICAgICBsaXN0MiA9IFtsaXN0Ml07XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBsaXN0Mi5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVsZXMgbWFuYWdlcjogaW52YWxpZCBydWxlIG5hbWUgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fcnVsZXNfX1tpZHhdLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBSdWxlci5wcm90b3R5cGUuZ2V0UnVsZXMgPSBmdW5jdGlvbihjaGFpbk5hbWUpIHtcbiAgICAgIGlmICh0aGlzLl9fY2FjaGVfXyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9fY29tcGlsZV9fKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX2NhY2hlX19bY2hhaW5OYW1lXSB8fCBbXTtcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gUnVsZXI7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzXG52YXIgcmVxdWlyZV9ub3JtYWxpemUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIE5FV0xJTkVTX1JFID0gL1xcclxcbj98XFxuL2c7XG4gICAgdmFyIE5VTExfUkUgPSAvXFwwL2c7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemUoc3RhdGUpIHtcbiAgICAgIHZhciBzdHI7XG4gICAgICBzdHIgPSBzdGF0ZS5zcmMucmVwbGFjZShORVdMSU5FU19SRSwgXCJcXG5cIik7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShOVUxMX1JFLCBcIlxcdUZGRkRcIik7XG4gICAgICBzdGF0ZS5zcmMgPSBzdHI7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ibG9jay5qc1xudmFyIHJlcXVpcmVfYmxvY2sgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2suanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrNChzdGF0ZSkge1xuICAgICAgdmFyIHRva2VuO1xuICAgICAgaWYgKHN0YXRlLmlubGluZU1vZGUpIHtcbiAgICAgICAgdG9rZW4gPSBuZXcgc3RhdGUuVG9rZW4oXCJpbmxpbmVcIiwgXCJcIiwgMCk7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5zcmM7XG4gICAgICAgIHRva2VuLm1hcCA9IFswLCAxXTtcbiAgICAgICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgc3RhdGUudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubWQuYmxvY2sucGFyc2Uoc3RhdGUuc3JjLCBzdGF0ZS5tZCwgc3RhdGUuZW52LCBzdGF0ZS50b2tlbnMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvaW5saW5lLmpzXG52YXIgcmVxdWlyZV9pbmxpbmUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvaW5saW5lLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmU0KHN0YXRlKSB7XG4gICAgICB2YXIgdG9rZW5zID0gc3RhdGUudG9rZW5zLCB0b2ssIGksIGw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0b2sgPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICh0b2sudHlwZSA9PT0gXCJpbmxpbmVcIikge1xuICAgICAgICAgIHN0YXRlLm1kLmlubGluZS5wYXJzZSh0b2suY29udGVudCwgc3RhdGUubWQsIHN0YXRlLmVudiwgdG9rLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qc1xudmFyIHJlcXVpcmVfbGlua2lmeSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGFycmF5UmVwbGFjZUF0ID0gcmVxdWlyZV91dGlscygpLmFycmF5UmVwbGFjZUF0O1xuICAgIGZ1bmN0aW9uIGlzTGlua09wZW4oc3RyKSB7XG4gICAgICByZXR1cm4gL148YVs+XFxzXS9pLnRlc3Qoc3RyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNMaW5rQ2xvc2Uoc3RyKSB7XG4gICAgICByZXR1cm4gL148XFwvYVxccyo+L2kudGVzdChzdHIpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmtpZnkoc3RhdGUpIHtcbiAgICAgIHZhciBpLCBqLCBsLCB0b2tlbnMsIHRva2VuLCBjdXJyZW50VG9rZW4sIG5vZGVzLCBsbiwgdGV4dDIsIHBvcywgbGFzdFBvcywgbGV2ZWwsIGh0bWxMaW5rTGV2ZWwsIHVybCwgZnVsbFVybCwgdXJsVGV4dCwgYmxvY2tUb2tlbnMgPSBzdGF0ZS50b2tlbnMsIGxpbmtzO1xuICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmxpbmtpZnkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMCwgbCA9IGJsb2NrVG9rZW5zLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICBpZiAoYmxvY2tUb2tlbnNbal0udHlwZSAhPT0gXCJpbmxpbmVcIiB8fCAhc3RhdGUubWQubGlua2lmeS5wcmV0ZXN0KGJsb2NrVG9rZW5zW2pdLmNvbnRlbnQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zID0gYmxvY2tUb2tlbnNbal0uY2hpbGRyZW47XG4gICAgICAgIGh0bWxMaW5rTGV2ZWwgPSAwO1xuICAgICAgICBmb3IgKGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjdXJyZW50VG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSBcImxpbmtfY2xvc2VcIikge1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgd2hpbGUgKHRva2Vuc1tpXS5sZXZlbCAhPT0gY3VycmVudFRva2VuLmxldmVsICYmIHRva2Vuc1tpXS50eXBlICE9PSBcImxpbmtfb3BlblwiKSB7XG4gICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09IFwiaHRtbF9pbmxpbmVcIikge1xuICAgICAgICAgICAgaWYgKGlzTGlua09wZW4oY3VycmVudFRva2VuLmNvbnRlbnQpICYmIGh0bWxMaW5rTGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICAgIGh0bWxMaW5rTGV2ZWwtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0xpbmtDbG9zZShjdXJyZW50VG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgICAgICAgaHRtbExpbmtMZXZlbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaHRtbExpbmtMZXZlbCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09IFwidGV4dFwiICYmIHN0YXRlLm1kLmxpbmtpZnkudGVzdChjdXJyZW50VG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgICAgIHRleHQyID0gY3VycmVudFRva2VuLmNvbnRlbnQ7XG4gICAgICAgICAgICBsaW5rcyA9IHN0YXRlLm1kLmxpbmtpZnkubWF0Y2godGV4dDIpO1xuICAgICAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGxldmVsID0gY3VycmVudFRva2VuLmxldmVsO1xuICAgICAgICAgICAgbGFzdFBvcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxuID0gMDsgbG4gPCBsaW5rcy5sZW5ndGg7IGxuKyspIHtcbiAgICAgICAgICAgICAgdXJsID0gbGlua3NbbG5dLnVybDtcbiAgICAgICAgICAgICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1cmxUZXh0ID0gbGlua3NbbG5dLnRleHQ7XG4gICAgICAgICAgICAgIGlmICghbGlua3NbbG5dLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dChcImh0dHA6Ly9cIiArIHVybFRleHQpLnJlcGxhY2UoL15odHRwOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmtzW2xuXS5zY2hlbWEgPT09IFwibWFpbHRvOlwiICYmICEvXm1haWx0bzovaS50ZXN0KHVybFRleHQpKSB7XG4gICAgICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KFwibWFpbHRvOlwiICsgdXJsVGV4dCkucmVwbGFjZSgvXm1haWx0bzovLCBcIlwiKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsVGV4dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG9zID0gbGlua3NbbG5dLmluZGV4O1xuICAgICAgICAgICAgICBpZiAocG9zID4gbGFzdFBvcykge1xuICAgICAgICAgICAgICAgIHRva2VuID0gbmV3IHN0YXRlLlRva2VuKFwidGV4dFwiLCBcIlwiLCAwKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdGV4dDIuc2xpY2UobGFzdFBvcywgcG9zKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5sZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRva2VuID0gbmV3IHN0YXRlLlRva2VuKFwibGlua19vcGVuXCIsIFwiYVwiLCAxKTtcbiAgICAgICAgICAgICAgdG9rZW4uYXR0cnMgPSBbW1wiaHJlZlwiLCBmdWxsVXJsXV07XG4gICAgICAgICAgICAgIHRva2VuLmxldmVsID0gbGV2ZWwrKztcbiAgICAgICAgICAgICAgdG9rZW4ubWFya3VwID0gXCJsaW5raWZ5XCI7XG4gICAgICAgICAgICAgIHRva2VuLmluZm8gPSBcImF1dG9cIjtcbiAgICAgICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIHRva2VuID0gbmV3IHN0YXRlLlRva2VuKFwidGV4dFwiLCBcIlwiLCAwKTtcbiAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHVybFRleHQ7XG4gICAgICAgICAgICAgIHRva2VuLmxldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICB0b2tlbiA9IG5ldyBzdGF0ZS5Ub2tlbihcImxpbmtfY2xvc2VcIiwgXCJhXCIsIC0xKTtcbiAgICAgICAgICAgICAgdG9rZW4ubGV2ZWwgPSAtLWxldmVsO1xuICAgICAgICAgICAgICB0b2tlbi5tYXJrdXAgPSBcImxpbmtpZnlcIjtcbiAgICAgICAgICAgICAgdG9rZW4uaW5mbyA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgbGFzdFBvcyA9IGxpbmtzW2xuXS5sYXN0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdFBvcyA8IHRleHQyLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0b2tlbiA9IG5ldyBzdGF0ZS5Ub2tlbihcInRleHRcIiwgXCJcIiwgMCk7XG4gICAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0Mi5zbGljZShsYXN0UG9zKTtcbiAgICAgICAgICAgICAgdG9rZW4ubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbiA9IHRva2VucyA9IGFycmF5UmVwbGFjZUF0KHRva2VucywgaSwgbm9kZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzXG52YXIgcmVxdWlyZV9yZXBsYWNlbWVudHMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIFJBUkVfUkUgPSAvXFwrLXxcXC5cXC58XFw/XFw/XFw/XFw/fCEhISF8LCx8LS0vO1xuICAgIHZhciBTQ09QRURfQUJCUl9URVNUX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaTtcbiAgICB2YXIgU0NPUEVEX0FCQlJfUkUgPSAvXFwoKGN8dG18cnxwKVxcKS9pZztcbiAgICB2YXIgU0NPUEVEX0FCQlIgPSB7XG4gICAgICBjOiBcIlxceEE5XCIsXG4gICAgICByOiBcIlxceEFFXCIsXG4gICAgICBwOiBcIlxceEE3XCIsXG4gICAgICB0bTogXCJcXHUyMTIyXCJcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VGbihtYXRjaCwgbmFtZSkge1xuICAgICAgcmV0dXJuIFNDT1BFRF9BQkJSW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxhY2Vfc2NvcGVkKGlubGluZVRva2Vucykge1xuICAgICAgdmFyIGksIHRva2VuLCBpbnNpZGVfYXV0b2xpbmsgPSAwO1xuICAgICAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgIWluc2lkZV9hdXRvbGluaykge1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5jb250ZW50LnJlcGxhY2UoU0NPUEVEX0FCQlJfUkUsIHJlcGxhY2VGbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFwibGlua19vcGVuXCIgJiYgdG9rZW4uaW5mbyA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICBpbnNpZGVfYXV0b2xpbmstLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJsaW5rX2Nsb3NlXCIgJiYgdG9rZW4uaW5mbyA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXBsYWNlX3JhcmUoaW5saW5lVG9rZW5zKSB7XG4gICAgICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG4gICAgICBmb3IgKGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBcInRleHRcIiAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICAgICAgaWYgKFJBUkVfUkUudGVzdCh0b2tlbi5jb250ZW50KSkge1xuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnQucmVwbGFjZSgvXFwrLS9nLCBcIlxceEIxXCIpLnJlcGxhY2UoL1xcLnsyLH0vZywgXCJcXHUyMDI2XCIpLnJlcGxhY2UoLyhbPyFdKeKApi9nLCBcIiQxLi5cIikucmVwbGFjZSgvKFs/IV0pezQsfS9nLCBcIiQxJDEkMVwiKS5yZXBsYWNlKC8sezIsfS9nLCBcIixcIikucmVwbGFjZSgvKF58W14tXSktLS0oPz1bXi1dfCQpL21nLCBcIiQxXFx1MjAxNFwiKS5yZXBsYWNlKC8oXnxcXHMpLS0oPz1cXHN8JCkvbWcsIFwiJDFcXHUyMDEzXCIpLnJlcGxhY2UoLyhefFteLVxcc10pLS0oPz1bXi1cXHNdfCQpL21nLCBcIiQxXFx1MjAxM1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFwibGlua19vcGVuXCIgJiYgdG9rZW4uaW5mbyA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICBpbnNpZGVfYXV0b2xpbmstLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJsaW5rX2Nsb3NlXCIgJiYgdG9rZW4uaW5mbyA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAgICAgIHZhciBibGtJZHg7XG4gICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG4gICAgICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFNDT1BFRF9BQkJSX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgICAgIHJlcGxhY2Vfc2NvcGVkKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoUkFSRV9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICAgICAgcmVwbGFjZV9yYXJlKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanNcbnZhciByZXF1aXJlX3NtYXJ0cXVvdGVzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGlzV2hpdGVTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1doaXRlU3BhY2U7XG4gICAgdmFyIGlzUHVuY3RDaGFyID0gcmVxdWlyZV91dGlscygpLmlzUHVuY3RDaGFyO1xuICAgIHZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmVfdXRpbHMoKS5pc01kQXNjaWlQdW5jdDtcbiAgICB2YXIgUVVPVEVfVEVTVF9SRSA9IC9bJ1wiXS87XG4gICAgdmFyIFFVT1RFX1JFID0gL1snXCJdL2c7XG4gICAgdmFyIEFQT1NUUk9QSEUgPSBcIlxcdTIwMTlcIjtcbiAgICBmdW5jdGlvbiByZXBsYWNlQXQoc3RyLCBpbmRleCwgY2gpIHtcbiAgICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIGluZGV4KSArIGNoICsgc3RyLnN1YnN0cihpbmRleCArIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzX2lubGluZXModG9rZW5zLCBzdGF0ZSkge1xuICAgICAgdmFyIGksIHRva2VuLCB0ZXh0MiwgdCwgcG9zLCBtYXgyLCB0aGlzTGV2ZWwsIGl0ZW0yLCBsYXN0Q2hhciwgbmV4dENoYXIsIGlzTGFzdFB1bmN0Q2hhciwgaXNOZXh0UHVuY3RDaGFyLCBpc0xhc3RXaGl0ZVNwYWNlLCBpc05leHRXaGl0ZVNwYWNlLCBjYW5PcGVuLCBjYW5DbG9zZSwgaiwgaXNTaW5nbGUsIHN0YWNrLCBvcGVuUXVvdGUsIGNsb3NlUXVvdGU7XG4gICAgICBzdGFjayA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgdGhpc0xldmVsID0gdG9rZW5zW2ldLmxldmVsO1xuICAgICAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8PSB0aGlzTGV2ZWwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5sZW5ndGggPSBqICsgMTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dDIgPSB0b2tlbi5jb250ZW50O1xuICAgICAgICBwb3MgPSAwO1xuICAgICAgICBtYXgyID0gdGV4dDIubGVuZ3RoO1xuICAgICAgICBPVVRFUjpcbiAgICAgICAgICB3aGlsZSAocG9zIDwgbWF4Mikge1xuICAgICAgICAgICAgUVVPVEVfUkUubGFzdEluZGV4ID0gcG9zO1xuICAgICAgICAgICAgdCA9IFFVT1RFX1JFLmV4ZWModGV4dDIpO1xuICAgICAgICAgICAgaWYgKCF0KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FuT3BlbiA9IGNhbkNsb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgIHBvcyA9IHQuaW5kZXggKyAxO1xuICAgICAgICAgICAgaXNTaW5nbGUgPSB0WzBdID09PSBcIidcIjtcbiAgICAgICAgICAgIGxhc3RDaGFyID0gMzI7XG4gICAgICAgICAgICBpZiAodC5pbmRleCAtIDEgPj0gMCkge1xuICAgICAgICAgICAgICBsYXN0Q2hhciA9IHRleHQyLmNoYXJDb2RlQXQodC5pbmRleCAtIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlID09PSBcInNvZnRicmVha1wiIHx8IHRva2Vuc1tqXS50eXBlID09PSBcImhhcmRicmVha1wiKVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbnNbal0uY29udGVudClcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxhc3RDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCh0b2tlbnNbal0uY29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dENoYXIgPSAzMjtcbiAgICAgICAgICAgIGlmIChwb3MgPCBtYXgyKSB7XG4gICAgICAgICAgICAgIG5leHRDaGFyID0gdGV4dDIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zW2pdLnR5cGUgPT09IFwic29mdGJyZWFrXCIgfHwgdG9rZW5zW2pdLnR5cGUgPT09IFwiaGFyZGJyZWFrXCIpXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIXRva2Vuc1tqXS5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbmV4dENoYXIgPSB0b2tlbnNbal0uY29udGVudC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xuICAgICAgICAgICAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcbiAgICAgICAgICAgIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICAgICAgICAgICAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG4gICAgICAgICAgICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xuICAgICAgICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmV4dFB1bmN0Q2hhcikge1xuICAgICAgICAgICAgICBpZiAoIShpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgICAgICAgICAgIGNhbkNsb3NlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgICAgICAgICAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICAgICAgICBjYW5DbG9zZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dENoYXIgPT09IDM0ICYmIHRbMF0gPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RDaGFyID49IDQ4ICYmIGxhc3RDaGFyIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgY2FuQ2xvc2UgPSBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5PcGVuICYmIGNhbkNsb3NlKSB7XG4gICAgICAgICAgICAgIGNhbk9wZW4gPSBpc0xhc3RQdW5jdENoYXI7XG4gICAgICAgICAgICAgIGNhbkNsb3NlID0gaXNOZXh0UHVuY3RDaGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYW5PcGVuICYmICFjYW5DbG9zZSkge1xuICAgICAgICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbkNsb3NlKSB7XG4gICAgICAgICAgICAgIGZvciAoaiA9IHN0YWNrLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgaXRlbTIgPSBzdGFja1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tbal0ubGV2ZWwgPCB0aGlzTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXRlbTIuc2luZ2xlID09PSBpc1NpbmdsZSAmJiBzdGFja1tqXS5sZXZlbCA9PT0gdGhpc0xldmVsKSB7XG4gICAgICAgICAgICAgICAgICBpdGVtMiA9IHN0YWNrW2pdO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5RdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzJdO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZVF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbM107XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VRdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBjbG9zZVF1b3RlKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vuc1tpdGVtMi50b2tlbl0uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbnNbaXRlbTIudG9rZW5dLmNvbnRlbnQsIGl0ZW0yLnBvcywgb3BlblF1b3RlKTtcbiAgICAgICAgICAgICAgICAgIHBvcyArPSBjbG9zZVF1b3RlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbTIudG9rZW4gPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IG9wZW5RdW90ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGV4dDIgPSB0b2tlbi5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgbWF4MiA9IHRleHQyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGo7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZSBPVVRFUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5PcGVuKSB7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIHRva2VuOiBpLFxuICAgICAgICAgICAgICAgIHBvczogdC5pbmRleCxcbiAgICAgICAgICAgICAgICBzaW5nbGU6IGlzU2luZ2xlLFxuICAgICAgICAgICAgICAgIGxldmVsOiB0aGlzTGV2ZWxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNhbkNsb3NlICYmIGlzU2luZ2xlKSB7XG4gICAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgQVBPU1RST1BIRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNtYXJ0cXVvdGVzKHN0YXRlKSB7XG4gICAgICB2YXIgYmxrSWR4O1xuICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLnR5cG9ncmFwaGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoYmxrSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDE7IGJsa0lkeCA+PSAwOyBibGtJZHgtLSkge1xuICAgICAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gXCJpbmxpbmVcIiB8fCAhUVVPVEVfVEVTVF9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc19pbmxpbmVzKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvdG9rZW4uanNcbnZhciByZXF1aXJlX3Rva2VuID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi90b2tlbi5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGZ1bmN0aW9uIFRva2VuKHR5cGUsIHRhZywgbmVzdGluZykge1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgdGhpcy5hdHRycyA9IG51bGw7XG4gICAgICB0aGlzLm1hcCA9IG51bGw7XG4gICAgICB0aGlzLm5lc3RpbmcgPSBuZXN0aW5nO1xuICAgICAgdGhpcy5sZXZlbCA9IDA7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGVudCA9IFwiXCI7XG4gICAgICB0aGlzLm1hcmt1cCA9IFwiXCI7XG4gICAgICB0aGlzLmluZm8gPSBcIlwiO1xuICAgICAgdGhpcy5tZXRhID0gbnVsbDtcbiAgICAgIHRoaXMuYmxvY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICAgIFRva2VuLnByb3RvdHlwZS5hdHRySW5kZXggPSBmdW5jdGlvbiBhdHRySW5kZXgobmFtZSkge1xuICAgICAgdmFyIGF0dHJzLCBpLCBsZW47XG4gICAgICBpZiAoIXRoaXMuYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gYXR0cnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGF0dHJzW2ldWzBdID09PSBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5hdHRyUHVzaCA9IGZ1bmN0aW9uIGF0dHJQdXNoKGF0dHJEYXRhKSB7XG4gICAgICBpZiAodGhpcy5hdHRycykge1xuICAgICAgICB0aGlzLmF0dHJzLnB1c2goYXR0ckRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IFthdHRyRGF0YV07XG4gICAgICB9XG4gICAgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuYXR0clNldCA9IGZ1bmN0aW9uIGF0dHJTZXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSwgYXR0ckRhdGEgPSBbbmFtZSwgdmFsdWVdO1xuICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgdGhpcy5hdHRyUHVzaChhdHRyRGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHJzW2lkeF0gPSBhdHRyRGF0YTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5hdHRyR2V0ID0gZnVuY3Rpb24gYXR0ckdldChuYW1lKSB7XG4gICAgICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSksIHZhbHVlID0gbnVsbDtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuYXR0cnNbaWR4XVsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5hdHRySm9pbiA9IGZ1bmN0aW9uIGF0dHJKb2luKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSk7XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICB0aGlzLmF0dHJQdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hdHRyc1tpZHhdWzFdID0gdGhpcy5hdHRyc1tpZHhdWzFdICsgXCIgXCIgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gVG9rZW47XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc3RhdGVfY29yZS5qc1xudmFyIHJlcXVpcmVfc3RhdGVfY29yZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zdGF0ZV9jb3JlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIFRva2VuID0gcmVxdWlyZV90b2tlbigpO1xuICAgIGZ1bmN0aW9uIFN0YXRlQ29yZShzcmMsIG1kLCBlbnYpIHtcbiAgICAgIHRoaXMuc3JjID0gc3JjO1xuICAgICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgdGhpcy5pbmxpbmVNb2RlID0gZmFsc2U7XG4gICAgICB0aGlzLm1kID0gbWQ7XG4gICAgfVxuICAgIFN0YXRlQ29yZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0YXRlQ29yZTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2NvcmUuanNcbnZhciByZXF1aXJlX3BhcnNlcl9jb3JlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBSdWxlciA9IHJlcXVpcmVfcnVsZXIoKTtcbiAgICB2YXIgX3J1bGVzID0gW1xuICAgICAgW1wibm9ybWFsaXplXCIsIHJlcXVpcmVfbm9ybWFsaXplKCldLFxuICAgICAgW1wiYmxvY2tcIiwgcmVxdWlyZV9ibG9jaygpXSxcbiAgICAgIFtcImlubGluZVwiLCByZXF1aXJlX2lubGluZSgpXSxcbiAgICAgIFtcImxpbmtpZnlcIiwgcmVxdWlyZV9saW5raWZ5KCldLFxuICAgICAgW1wicmVwbGFjZW1lbnRzXCIsIHJlcXVpcmVfcmVwbGFjZW1lbnRzKCldLFxuICAgICAgW1wic21hcnRxdW90ZXNcIiwgcmVxdWlyZV9zbWFydHF1b3RlcygpXVxuICAgIF07XG4gICAgZnVuY3Rpb24gQ29yZSgpIHtcbiAgICAgIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIENvcmUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgdmFyIGksIGwsIHJ1bGVzO1xuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKFwiXCIpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBydWxlc1tpXShzdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmVfc3RhdGVfY29yZSgpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gQ29yZTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svdGFibGUuanNcbnZhciByZXF1aXJlX3RhYmxlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBpc1NwYWNlID0gcmVxdWlyZV91dGlscygpLmlzU3BhY2U7XG4gICAgZnVuY3Rpb24gZ2V0TGluZTIoc3RhdGUsIGxpbmUpIHtcbiAgICAgIHZhciBwb3MgPSBzdGF0ZS5iTWFya3NbbGluZV0gKyBzdGF0ZS50U2hpZnRbbGluZV0sIG1heDIgPSBzdGF0ZS5lTWFya3NbbGluZV07XG4gICAgICByZXR1cm4gc3RhdGUuc3JjLnN1YnN0cihwb3MsIG1heDIgLSBwb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVkU3BsaXQoc3RyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIHBvcyA9IDAsIG1heDIgPSBzdHIubGVuZ3RoLCBjaCwgaXNFc2NhcGVkID0gZmFsc2UsIGxhc3RQb3MgPSAwLCBjdXJyZW50ID0gXCJcIjtcbiAgICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgyKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMTI0KSB7XG4gICAgICAgICAgaWYgKCFpc0VzY2FwZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQgKyBzdHIuc3Vic3RyaW5nKGxhc3RQb3MsIHBvcykpO1xuICAgICAgICAgICAgY3VycmVudCA9IFwiXCI7XG4gICAgICAgICAgICBsYXN0UG9zID0gcG9zICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudCArPSBzdHIuc3Vic3RyaW5nKGxhc3RQb3MsIHBvcyAtIDEpO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNFc2NhcGVkID0gY2ggPT09IDkyO1xuICAgICAgICBwb3MrKztcbiAgICAgICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goY3VycmVudCArIHN0ci5zdWJzdHJpbmcobGFzdFBvcykpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0YWJsZTMoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gICAgICB2YXIgY2gsIGxpbmVUZXh0LCBwb3MsIGksIGwsIG5leHRMaW5lLCBjb2x1bW5zLCBjb2x1bW5Db3VudCwgdG9rZW4sIGFsaWducywgdCwgdGFibGVMaW5lcywgdGJvZHlMaW5lcywgb2xkUGFyZW50VHlwZSwgdGVybWluYXRlLCB0ZXJtaW5hdG9yUnVsZXMsIGZpcnN0Q2gsIHNlY29uZENoO1xuICAgICAgaWYgKHN0YXJ0TGluZSArIDIgPiBlbmRMaW5lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcbiAgICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIGlmIChwb3MgPj0gc3RhdGUuZU1hcmtzW25leHRMaW5lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmaXJzdENoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAgICAgaWYgKGZpcnN0Q2ggIT09IDEyNCAmJiBmaXJzdENoICE9PSA0NSAmJiBmaXJzdENoICE9PSA1OCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocG9zID49IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc2Vjb25kQ2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICBpZiAoc2Vjb25kQ2ggIT09IDEyNCAmJiBzZWNvbmRDaCAhPT0gNDUgJiYgc2Vjb25kQ2ggIT09IDU4ICYmICFpc1NwYWNlKHNlY29uZENoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RDaCA9PT0gNDUgJiYgaXNTcGFjZShzZWNvbmRDaCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvcyA8IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoY2ggIT09IDEyNCAmJiBjaCAhPT0gNDUgJiYgY2ggIT09IDU4ICYmICFpc1NwYWNlKGNoKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICAgIGxpbmVUZXh0ID0gZ2V0TGluZTIoc3RhdGUsIHN0YXJ0TGluZSArIDEpO1xuICAgICAgY29sdW1ucyA9IGxpbmVUZXh0LnNwbGl0KFwifFwiKTtcbiAgICAgIGFsaWducyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdCA9IGNvbHVtbnNbaV0udHJpbSgpO1xuICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBjb2x1bW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghL146Py0rOj8kLy50ZXN0KHQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0LmNoYXJDb2RlQXQodC5sZW5ndGggLSAxKSA9PT0gNTgpIHtcbiAgICAgICAgICBhbGlnbnMucHVzaCh0LmNoYXJDb2RlQXQoMCkgPT09IDU4ID8gXCJjZW50ZXJcIiA6IFwicmlnaHRcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodC5jaGFyQ29kZUF0KDApID09PSA1OCkge1xuICAgICAgICAgIGFsaWducy5wdXNoKFwibGVmdFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGlnbnMucHVzaChcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGluZVRleHQgPSBnZXRMaW5lMihzdGF0ZSwgc3RhcnRMaW5lKS50cmltKCk7XG4gICAgICBpZiAobGluZVRleHQuaW5kZXhPZihcInxcIikgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dCk7XG4gICAgICBpZiAoY29sdW1ucy5sZW5ndGggJiYgY29sdW1uc1swXSA9PT0gXCJcIilcbiAgICAgICAgY29sdW1ucy5zaGlmdCgpO1xuICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoICYmIGNvbHVtbnNbY29sdW1ucy5sZW5ndGggLSAxXSA9PT0gXCJcIilcbiAgICAgICAgY29sdW1ucy5wb3AoKTtcbiAgICAgIGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGg7XG4gICAgICBpZiAoY29sdW1uQ291bnQgPT09IDAgfHwgY29sdW1uQ291bnQgIT09IGFsaWducy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICAgICAgc3RhdGUucGFyZW50VHlwZSA9IFwidGFibGVcIjtcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKFwiYmxvY2txdW90ZVwiKTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRhYmxlX29wZW5cIiwgXCJ0YWJsZVwiLCAxKTtcbiAgICAgIHRva2VuLm1hcCA9IHRhYmxlTGluZXMgPSBbc3RhcnRMaW5lLCAwXTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRoZWFkX29wZW5cIiwgXCJ0aGVhZFwiLCAxKTtcbiAgICAgIHRva2VuLm1hcCA9IFtzdGFydExpbmUsIHN0YXJ0TGluZSArIDFdO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidHJfb3BlblwiLCBcInRyXCIsIDEpO1xuICAgICAgdG9rZW4ubWFwID0gW3N0YXJ0TGluZSwgc3RhcnRMaW5lICsgMV07XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJ0aF9vcGVuXCIsIFwidGhcIiwgMSk7XG4gICAgICAgIGlmIChhbGlnbnNbaV0pIHtcbiAgICAgICAgICB0b2tlbi5hdHRycyA9IFtbXCJzdHlsZVwiLCBcInRleHQtYWxpZ246XCIgKyBhbGlnbnNbaV1dXTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJpbmxpbmVcIiwgXCJcIiwgMCk7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBjb2x1bW5zW2ldLnRyaW0oKTtcbiAgICAgICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidGhfY2xvc2VcIiwgXCJ0aFwiLCAtMSk7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJ0cl9jbG9zZVwiLCBcInRyXCIsIC0xKTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRoZWFkX2Nsb3NlXCIsIFwidGhlYWRcIiwgLTEpO1xuICAgICAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDI7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGVybWluYXRlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGluZVRleHQgPSBnZXRMaW5lMihzdGF0ZSwgbmV4dExpbmUpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFsaW5lVGV4dCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbHVtbnMgPSBlc2NhcGVkU3BsaXQobGluZVRleHQpO1xuICAgICAgICBpZiAoY29sdW1ucy5sZW5ndGggJiYgY29sdW1uc1swXSA9PT0gXCJcIilcbiAgICAgICAgICBjb2x1bW5zLnNoaWZ0KCk7XG4gICAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCAmJiBjb2x1bW5zW2NvbHVtbnMubGVuZ3RoIC0gMV0gPT09IFwiXCIpXG4gICAgICAgICAgY29sdW1ucy5wb3AoKTtcbiAgICAgICAgaWYgKG5leHRMaW5lID09PSBzdGFydExpbmUgKyAyKSB7XG4gICAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidGJvZHlfb3BlblwiLCBcInRib2R5XCIsIDEpO1xuICAgICAgICAgIHRva2VuLm1hcCA9IHRib2R5TGluZXMgPSBbc3RhcnRMaW5lICsgMiwgMF07XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidHJfb3BlblwiLCBcInRyXCIsIDEpO1xuICAgICAgICB0b2tlbi5tYXAgPSBbbmV4dExpbmUsIG5leHRMaW5lICsgMV07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidGRfb3BlblwiLCBcInRkXCIsIDEpO1xuICAgICAgICAgIGlmIChhbGlnbnNbaV0pIHtcbiAgICAgICAgICAgIHRva2VuLmF0dHJzID0gW1tcInN0eWxlXCIsIFwidGV4dC1hbGlnbjpcIiArIGFsaWduc1tpXV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJpbmxpbmVcIiwgXCJcIiwgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IGNvbHVtbnNbaV0gPyBjb2x1bW5zW2ldLnRyaW0oKSA6IFwiXCI7XG4gICAgICAgICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJ0ZF9jbG9zZVwiLCBcInRkXCIsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJ0cl9jbG9zZVwiLCBcInRyXCIsIC0xKTtcbiAgICAgIH1cbiAgICAgIGlmICh0Ym9keUxpbmVzKSB7XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRib2R5X2Nsb3NlXCIsIFwidGJvZHlcIiwgLTEpO1xuICAgICAgICB0Ym9keUxpbmVzWzFdID0gbmV4dExpbmU7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJ0YWJsZV9jbG9zZVwiLCBcInRhYmxlXCIsIC0xKTtcbiAgICAgIHRhYmxlTGluZXNbMV0gPSBuZXh0TGluZTtcbiAgICAgIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICAgICAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qc1xudmFyIHJlcXVpcmVfY29kZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29kZTIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICAgICAgaWYgKHN0YXRlLm1kLm9wdGlvbnMuYWxsb3dJbmRlbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dExpbmUsIGxhc3QsIHRva2VuO1xuICAgICAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50IDwgNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsYXN0ID0gbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuICAgICAgd2hpbGUgKG5leHRMaW5lIDwgZW5kTGluZSkge1xuICAgICAgICBpZiAoc3RhdGUuaXNFbXB0eShuZXh0TGluZSkpIHtcbiAgICAgICAgICBuZXh0TGluZSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgICAgICBuZXh0TGluZSsrO1xuICAgICAgICAgIGxhc3QgPSBuZXh0TGluZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxpbmUgPSBsYXN0O1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiY29kZV9ibG9ja1wiLCBcImNvZGVcIiwgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBsYXN0LCA0ICsgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkgKyBcIlxcblwiO1xuICAgICAgdG9rZW4ubWFwID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZV07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9mZW5jZS5qc1xudmFyIHJlcXVpcmVfZmVuY2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2ZlbmNlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmZW5jZTMoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gICAgICB2YXIgbWFya2VyLCBsZW4sIHBhcmFtcywgbmV4dExpbmUsIG1lbSwgdG9rZW4sIG1hcmt1cCwgaGF2ZUVuZE1hcmtlciA9IGZhbHNlLCBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLCBtYXgyID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG4gICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuYWxsb3dJbmRlbnRhdGlvbiAmJiBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwb3MgKyAzID4gbWF4Mikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKG1hcmtlciAhPT0gMTI2ICYmIG1hcmtlciAhPT0gOTYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbWVtID0gcG9zO1xuICAgICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcbiAgICAgIGxlbiA9IHBvcyAtIG1lbTtcbiAgICAgIGlmIChsZW4gPCAzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG1hcmt1cCA9IHN0YXRlLnNyYy5zbGljZShtZW0sIHBvcyk7XG4gICAgICBwYXJhbXMgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgyKTtcbiAgICAgIGlmIChtYXJrZXIgPT09IDk2KSB7XG4gICAgICAgIGlmIChwYXJhbXMuaW5kZXhPZihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpID49IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICBuZXh0TGluZSsrO1xuICAgICAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IG1lbSA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgICBtYXgyID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcbiAgICAgICAgaWYgKHBvcyA8IG1heDIgJiYgc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBtYXJrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuYWxsb3dJbmRlbnRhdGlvbiAmJiBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuICAgICAgICBpZiAocG9zIC0gbWVtIDwgbGVuKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuICAgICAgICBpZiAocG9zIDwgbWF4Mikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGhhdmVFbmRNYXJrZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxlbiA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdO1xuICAgICAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgKGhhdmVFbmRNYXJrZXIgPyAxIDogMCk7XG4gICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJmZW5jZVwiLCBcImNvZGVcIiwgMCk7XG4gICAgICB0b2tlbi5pbmZvID0gcGFyYW1zO1xuICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSArIDEsIG5leHRMaW5lLCBsZW4sIHRydWUpO1xuICAgICAgdG9rZW4ubWFya3VwID0gbWFya3VwO1xuICAgICAgdG9rZW4ubWFwID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZV07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9ibG9ja3F1b3RlLmpzXG52YXIgcmVxdWlyZV9ibG9ja3F1b3RlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9ibG9ja3F1b3RlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGlzU3BhY2UgPSByZXF1aXJlX3V0aWxzKCkuaXNTcGFjZTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUyKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICAgICAgdmFyIGFkanVzdFRhYiwgY2gsIGksIGluaXRpYWwsIGwsIGxhc3RMaW5lRW1wdHksIGxpbmVzLCBuZXh0TGluZSwgb2Zmc2V0LCBvbGRCTWFya3MsIG9sZEJTQ291bnQsIG9sZEluZGVudCwgb2xkUGFyZW50VHlwZSwgb2xkU0NvdW50LCBvbGRUU2hpZnQsIHNwYWNlQWZ0ZXJNYXJrZXIsIHRlcm1pbmF0ZSwgdGVybWluYXRvclJ1bGVzLCB0b2tlbiwgaXNPdXRkZW50ZWQsIG9sZExpbmVNYXggPSBzdGF0ZS5saW5lTWF4LCBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLCBtYXgyID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG4gICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuYWxsb3dJbmRlbnRhdGlvbiAmJiBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKykgIT09IDYyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyAxO1xuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDMyKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBpbml0aWFsKys7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDkpIHtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gICAgICAgIGlmICgoc3RhdGUuYnNDb3VudFtzdGFydExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBpbml0aWFsKys7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRqdXN0VGFiID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgb2xkQk1hcmtzID0gW3N0YXRlLmJNYXJrc1tzdGFydExpbmVdXTtcbiAgICAgIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdID0gcG9zO1xuICAgICAgd2hpbGUgKHBvcyA8IG1heDIpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDkpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbc3RhcnRMaW5lXSArIChhZGp1c3RUYWIgPyAxIDogMCkpICUgNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuICAgICAgb2xkQlNDb3VudCA9IFtzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV1dO1xuICAgICAgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG4gICAgICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDI7XG4gICAgICBvbGRTQ291bnQgPSBbc3RhdGUuc0NvdW50W3N0YXJ0TGluZV1dO1xuICAgICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvZmZzZXQgLSBpbml0aWFsO1xuICAgICAgb2xkVFNoaWZ0ID0gW3N0YXRlLnRTaGlmdFtzdGFydExpbmVdXTtcbiAgICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcyhcImJsb2NrcXVvdGVcIik7XG4gICAgICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgICAgIHN0YXRlLnBhcmVudFR5cGUgPSBcImJsb2NrcXVvdGVcIjtcbiAgICAgIGZvciAobmV4dExpbmUgPSBzdGFydExpbmUgKyAxOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICAgICAgaXNPdXRkZW50ZWQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50O1xuICAgICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgICAgbWF4MiA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG4gICAgICAgIGlmIChwb3MgPj0gbWF4Mikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKykgPT09IDYyICYmICFpc091dGRlbnRlZCkge1xuICAgICAgICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgMTtcbiAgICAgICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMzIpIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICAgICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gOSkge1xuICAgICAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIGluaXRpYWwrKztcbiAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRqdXN0VGFiID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICAgICAgICBzdGF0ZS5iTWFya3NbbmV4dExpbmVdID0gcG9zO1xuICAgICAgICAgIHdoaWxlIChwb3MgPCBtYXgyKSB7XG4gICAgICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSA5KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RMaW5lRW1wdHkgPSBwb3MgPj0gbWF4MjtcbiAgICAgICAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICAgIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcbiAgICAgICAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdID0gb2Zmc2V0IC0gaW5pdGlhbDtcbiAgICAgICAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICAgICAgICBzdGF0ZS50U2hpZnRbbmV4dExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW25leHRMaW5lXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdExpbmVFbXB0eSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGVybWluYXRlKSB7XG4gICAgICAgICAgc3RhdGUubGluZU1heCA9IG5leHRMaW5lO1xuICAgICAgICAgIGlmIChzdGF0ZS5ibGtJbmRlbnQgIT09IDApIHtcbiAgICAgICAgICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgICAgICAgICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC09IHN0YXRlLmJsa0luZGVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IC0xO1xuICAgICAgfVxuICAgICAgb2xkSW5kZW50ID0gc3RhdGUuYmxrSW5kZW50O1xuICAgICAgc3RhdGUuYmxrSW5kZW50ID0gMDtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImJsb2NrcXVvdGVfb3BlblwiLCBcImJsb2NrcXVvdGVcIiwgMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgPSBcIj5cIjtcbiAgICAgIHRva2VuLm1hcCA9IGxpbmVzID0gW3N0YXJ0TGluZSwgMF07XG4gICAgICBzdGF0ZS5tZC5ibG9jay50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSk7XG4gICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJibG9ja3F1b3RlX2Nsb3NlXCIsIFwiYmxvY2txdW90ZVwiLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgPSBcIj5cIjtcbiAgICAgIHN0YXRlLmxpbmVNYXggPSBvbGRMaW5lTWF4O1xuICAgICAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG4gICAgICBsaW5lc1sxXSA9IHN0YXRlLmxpbmU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb2xkVFNoaWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlLmJNYXJrc1tpICsgc3RhcnRMaW5lXSA9IG9sZEJNYXJrc1tpXTtcbiAgICAgICAgc3RhdGUudFNoaWZ0W2kgKyBzdGFydExpbmVdID0gb2xkVFNoaWZ0W2ldO1xuICAgICAgICBzdGF0ZS5zQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRTQ291bnRbaV07XG4gICAgICAgIHN0YXRlLmJzQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRCU0NvdW50W2ldO1xuICAgICAgfVxuICAgICAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHIuanNcbnZhciByZXF1aXJlX2hyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oci5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBpc1NwYWNlID0gcmVxdWlyZV91dGlscygpLmlzU3BhY2U7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBocjIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gICAgICB2YXIgbWFya2VyLCBjbnQsIGNoLCB0b2tlbiwgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSwgbWF4MiA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmFsbG93SW5kZW50YXRpb24gJiYgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICBpZiAobWFya2VyICE9PSA0MiAmJiBtYXJrZXIgIT09IDQ1ICYmIG1hcmtlciAhPT0gOTUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY250ID0gMTtcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgyKSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAgICAgICBpZiAoY2ggIT09IG1hcmtlciAmJiAhaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSBtYXJrZXIpIHtcbiAgICAgICAgICBjbnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNudCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiaHJcIiwgXCJoclwiLCAwKTtcbiAgICAgIHRva2VuLm1hcCA9IFtzdGFydExpbmUsIHN0YXRlLmxpbmVdO1xuICAgICAgdG9rZW4ubWFya3VwID0gQXJyYXkoY250ICsgMSkuam9pbihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qc1xudmFyIHJlcXVpcmVfbGlzdCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBpc1NwYWNlID0gcmVxdWlyZV91dGlscygpLmlzU3BhY2U7XG4gICAgZnVuY3Rpb24gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICAgICAgdmFyIG1hcmtlciwgcG9zLCBtYXgyLCBjaDtcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgICBtYXgyID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICBpZiAobWFya2VyICE9PSA0MiAmJiBtYXJrZXIgIT09IDQ1ICYmIG1hcmtlciAhPT0gNDMpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHBvcyA8IG1heDIpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICAgICAgdmFyIGNoLCBzdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sIHBvcyA9IHN0YXJ0LCBtYXgyID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG4gICAgICBpZiAocG9zICsgMSA+PSBtYXgyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAgICAgaWYgKGNoIDwgNDggfHwgY2ggPiA1Nykge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgaWYgKHBvcyA+PSBtYXgyKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAgICAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTcpIHtcbiAgICAgICAgICBpZiAocG9zIC0gc3RhcnQgPj0gMTApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSA0MSB8fCBjaCA9PT0gNDYpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAocG9zIDwgbWF4Mikge1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGlkeCkge1xuICAgICAgdmFyIGksIGwsIGxldmVsID0gc3RhdGUubGV2ZWwgKyAyO1xuICAgICAgZm9yIChpID0gaWR4ICsgMiwgbCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChzdGF0ZS50b2tlbnNbaV0ubGV2ZWwgPT09IGxldmVsICYmIHN0YXRlLnRva2Vuc1tpXS50eXBlID09PSBcInBhcmFncmFwaF9vcGVuXCIpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbnNbaSArIDJdLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgc3RhdGUudG9rZW5zW2ldLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlzdDIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gICAgICB2YXIgY2gsIGNvbnRlbnRTdGFydCwgaSwgaW5kZW50LCBpbmRlbnRBZnRlck1hcmtlciwgaW5pdGlhbCwgaXNPcmRlcmVkLCBpdGVtTGluZXMsIGwsIGxpc3RMaW5lcywgbGlzdFRva0lkeCwgbWFya2VyQ2hhckNvZGUsIG1hcmtlclZhbHVlLCBtYXgyLCBuZXh0TGluZSwgb2Zmc2V0LCBvbGRMaXN0SW5kZW50LCBvbGRQYXJlbnRUeXBlLCBvbGRTQ291bnQsIG9sZFRTaGlmdCwgb2xkVGlnaHQsIHBvcywgcG9zQWZ0ZXJNYXJrZXIsIHByZXZFbXB0eUVuZCwgc3RhcnQsIHRlcm1pbmF0ZSwgdGVybWluYXRvclJ1bGVzLCB0b2tlbiwgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IGZhbHNlLCB0aWdodCA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuYWxsb3dJbmRlbnRhdGlvbiAmJiBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLmxpc3RJbmRlbnQgPj0gMCAmJiBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmxpc3RJbmRlbnQgPj0gNCAmJiBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc2lsZW50ICYmIHN0YXRlLnBhcmVudFR5cGUgPT09IFwicGFyYWdyYXBoXCIpIHtcbiAgICAgICAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgICAgIGlzVGVybWluYXRpbmdQYXJhZ3JhcGggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKHBvc0FmdGVyTWFya2VyID0gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgICAgIGlzT3JkZXJlZCA9IHRydWU7XG4gICAgICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICAgICAgbWFya2VyVmFsdWUgPSBOdW1iZXIoc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3NBZnRlck1hcmtlciAtIDEpKTtcbiAgICAgICAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGggJiYgbWFya2VyVmFsdWUgIT09IDEpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSkgPj0gMCkge1xuICAgICAgICBpc09yZGVyZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoKSB7XG4gICAgICAgIGlmIChzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKSA+PSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBtYXJrZXJDaGFyQ29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvc0FmdGVyTWFya2VyIC0gMSk7XG4gICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbGlzdFRva0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG4gICAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcIm9yZGVyZWRfbGlzdF9vcGVuXCIsIFwib2xcIiwgMSk7XG4gICAgICAgIGlmIChtYXJrZXJWYWx1ZSAhPT0gMSkge1xuICAgICAgICAgIHRva2VuLmF0dHJzID0gW1tcInN0YXJ0XCIsIG1hcmtlclZhbHVlXV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImJ1bGxldF9saXN0X29wZW5cIiwgXCJ1bFwiLCAxKTtcbiAgICAgIH1cbiAgICAgIHRva2VuLm1hcCA9IGxpc3RMaW5lcyA9IFtzdGFydExpbmUsIDBdO1xuICAgICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcbiAgICAgIHByZXZFbXB0eUVuZCA9IGZhbHNlO1xuICAgICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoXCJsaXN0XCIpO1xuICAgICAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gXCJsaXN0XCI7XG4gICAgICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgICAgIHBvcyA9IHBvc0FmdGVyTWFya2VyO1xuICAgICAgICBtYXgyID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcbiAgICAgICAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyBwb3NBZnRlck1hcmtlciAtIChzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdKTtcbiAgICAgICAgd2hpbGUgKHBvcyA8IG1heDIpIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgaWYgKGNoID09PSA5KSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSkgJSA0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDMyKSB7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnRTdGFydCA9IHBvcztcbiAgICAgICAgaWYgKGNvbnRlbnRTdGFydCA+PSBtYXgyKSB7XG4gICAgICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGVudEFmdGVyTWFya2VyID0gb2Zmc2V0IC0gaW5pdGlhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuYWxsb3dJbmRlbnRhdGlvbiAmJiBpbmRlbnRBZnRlck1hcmtlciA+IDQpIHtcbiAgICAgICAgICBpbmRlbnRBZnRlck1hcmtlciA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZW50ID0gaW5pdGlhbCArIGluZGVudEFmdGVyTWFya2VyO1xuICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJsaXN0X2l0ZW1fb3BlblwiLCBcImxpXCIsIDEpO1xuICAgICAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcbiAgICAgICAgdG9rZW4ubWFwID0gaXRlbUxpbmVzID0gW3N0YXJ0TGluZSwgMF07XG4gICAgICAgIGlmIChpc09yZGVyZWQpIHtcbiAgICAgICAgICB0b2tlbi5pbmZvID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3NBZnRlck1hcmtlciAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIG9sZFRpZ2h0ID0gc3RhdGUudGlnaHQ7XG4gICAgICAgIG9sZFRTaGlmdCA9IHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICAgICAgICBvbGRTQ291bnQgPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXTtcbiAgICAgICAgb2xkTGlzdEluZGVudCA9IHN0YXRlLmxpc3RJbmRlbnQ7XG4gICAgICAgIHN0YXRlLmxpc3RJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgICAgIHN0YXRlLmJsa0luZGVudCA9IGluZGVudDtcbiAgICAgICAgc3RhdGUudGlnaHQgPSB0cnVlO1xuICAgICAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IGNvbnRlbnRTdGFydCAtIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuICAgICAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldDtcbiAgICAgICAgaWYgKGNvbnRlbnRTdGFydCA+PSBtYXgyICYmIHN0YXRlLmlzRW1wdHkoc3RhcnRMaW5lICsgMSkpIHtcbiAgICAgICAgICBzdGF0ZS5saW5lID0gTWF0aC5taW4oc3RhdGUubGluZSArIDIsIGVuZExpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGUudGlnaHQgfHwgcHJldkVtcHR5RW5kKSB7XG4gICAgICAgICAgdGlnaHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2RW1wdHlFbmQgPSBzdGF0ZS5saW5lIC0gc3RhcnRMaW5lID4gMSAmJiBzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKTtcbiAgICAgICAgc3RhdGUuYmxrSW5kZW50ID0gc3RhdGUubGlzdEluZGVudDtcbiAgICAgICAgc3RhdGUubGlzdEluZGVudCA9IG9sZExpc3RJbmRlbnQ7XG4gICAgICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gb2xkVFNoaWZ0O1xuICAgICAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9sZFNDb3VudDtcbiAgICAgICAgc3RhdGUudGlnaHQgPSBvbGRUaWdodDtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwibGlzdF9pdGVtX2Nsb3NlXCIsIFwibGlcIiwgLTEpO1xuICAgICAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcbiAgICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgICBpdGVtTGluZXNbMV0gPSBuZXh0TGluZTtcbiAgICAgICAgY29udGVudFN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG4gICAgICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuYWxsb3dJbmRlbnRhdGlvbiAmJiBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICAgICAgcG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICAgICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJDaGFyQ29kZSAhPT0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcIm9yZGVyZWRfbGlzdF9jbG9zZVwiLCBcIm9sXCIsIC0xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImJ1bGxldF9saXN0X2Nsb3NlXCIsIFwidWxcIiwgLTEpO1xuICAgICAgfVxuICAgICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG4gICAgICBsaXN0TGluZXNbMV0gPSBuZXh0TGluZTtcbiAgICAgIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgICAgIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICAgICAgaWYgKHRpZ2h0KSB7XG4gICAgICAgIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGxpc3RUb2tJZHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLmpzXG52YXIgcmVxdWlyZV9yZWZlcmVuY2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBub3JtYWxpemVSZWZlcmVuY2UgPSByZXF1aXJlX3V0aWxzKCkubm9ybWFsaXplUmVmZXJlbmNlO1xuICAgIHZhciBpc1NwYWNlID0gcmVxdWlyZV91dGlscygpLmlzU3BhY2U7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWZlcmVuY2Uoc3RhdGUsIHN0YXJ0TGluZSwgX2VuZExpbmUsIHNpbGVudCkge1xuICAgICAgdmFyIGNoLCBkZXN0RW5kUG9zLCBkZXN0RW5kTGluZU5vLCBlbmRMaW5lLCBocmVmLCBpLCBsLCBsYWJlbCwgbGFiZWxFbmQsIG9sZFBhcmVudFR5cGUsIHJlcywgc3RhcnQsIHN0ciwgdGVybWluYXRlLCB0ZXJtaW5hdG9yUnVsZXMsIHRpdGxlLCBsaW5lcyA9IDAsIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sIG1heDIgPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSwgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmFsbG93SW5kZW50YXRpb24gJiYgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gOTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrcG9zIDwgbWF4Mikge1xuICAgICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gOTMgJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zIC0gMSkgIT09IDkyKSB7XG4gICAgICAgICAgaWYgKHBvcyArIDEgPT09IG1heDIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpICE9PSA1OCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcyhcInJlZmVyZW5jZVwiKTtcbiAgICAgIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICAgICAgc3RhdGUucGFyZW50VHlwZSA9IFwicmVmZXJlbmNlXCI7XG4gICAgICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuYWxsb3dJbmRlbnRhdGlvbiAmJiBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGVybWluYXRlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0ciA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcbiAgICAgIG1heDIgPSBzdHIubGVuZ3RoO1xuICAgICAgZm9yIChwb3MgPSAxOyBwb3MgPCBtYXgyOyBwb3MrKykge1xuICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChjaCA9PT0gOTEpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkzKSB7XG4gICAgICAgICAgbGFiZWxFbmQgPSBwb3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDEwKSB7XG4gICAgICAgICAgbGluZXMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBpZiAocG9zIDwgbWF4MiAmJiBzdHIuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xuICAgICAgICAgICAgbGluZXMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYWJlbEVuZCA8IDAgfHwgc3RyLmNoYXJDb2RlQXQobGFiZWxFbmQgKyAxKSAhPT0gNTgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChwb3MgPSBsYWJlbEVuZCArIDI7IHBvcyA8IG1heDI7IHBvcysrKSB7XG4gICAgICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGNoID09PSAxMCkge1xuICAgICAgICAgIGxpbmVzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4Mik7XG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICBsaW5lcyArPSByZXMubGluZXM7XG4gICAgICBkZXN0RW5kUG9zID0gcG9zO1xuICAgICAgZGVzdEVuZExpbmVObyA9IGxpbmVzO1xuICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICBmb3IgKDsgcG9zIDwgbWF4MjsgcG9zKyspIHtcbiAgICAgICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoY2ggPT09IDEwKSB7XG4gICAgICAgICAgbGluZXMrKztcbiAgICAgICAgfSBlbHNlIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0ciwgcG9zLCBtYXgyKTtcbiAgICAgIGlmIChwb3MgPCBtYXgyICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgICAgbGluZXMgKz0gcmVzLmxpbmVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGUgPSBcIlwiO1xuICAgICAgICBwb3MgPSBkZXN0RW5kUG9zO1xuICAgICAgICBsaW5lcyA9IGRlc3RFbmRMaW5lTm87XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zIDwgbWF4Mikge1xuICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICAgIGlmIChwb3MgPCBtYXgyICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgIT09IDEwKSB7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgIHRpdGxlID0gXCJcIjtcbiAgICAgICAgICBwb3MgPSBkZXN0RW5kUG9zO1xuICAgICAgICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcbiAgICAgICAgICB3aGlsZSAocG9zIDwgbWF4Mikge1xuICAgICAgICAgICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvcyA8IG1heDIgJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMTApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbGFiZWwgPSBub3JtYWxpemVSZWZlcmVuY2Uoc3RyLnNsaWNlKDEsIGxhYmVsRW5kKSk7XG4gICAgICBpZiAoIWxhYmVsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzID0ge307XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzdGF0ZS5lbnYucmVmZXJlbmNlc1tsYWJlbF0gPSB7IHRpdGxlLCBocmVmIH07XG4gICAgICB9XG4gICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcbiAgICAgIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyBsaW5lcyArIDE7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9ibG9ja3MuanNcbnZhciByZXF1aXJlX2h0bWxfYmxvY2tzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9ibG9ja3MuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFtcbiAgICAgIFwiYWRkcmVzc1wiLFxuICAgICAgXCJhcnRpY2xlXCIsXG4gICAgICBcImFzaWRlXCIsXG4gICAgICBcImJhc2VcIixcbiAgICAgIFwiYmFzZWZvbnRcIixcbiAgICAgIFwiYmxvY2txdW90ZVwiLFxuICAgICAgXCJib2R5XCIsXG4gICAgICBcImNhcHRpb25cIixcbiAgICAgIFwiY2VudGVyXCIsXG4gICAgICBcImNvbFwiLFxuICAgICAgXCJjb2xncm91cFwiLFxuICAgICAgXCJkZFwiLFxuICAgICAgXCJkZXRhaWxzXCIsXG4gICAgICBcImRpYWxvZ1wiLFxuICAgICAgXCJkaXJcIixcbiAgICAgIFwiZGl2XCIsXG4gICAgICBcImRsXCIsXG4gICAgICBcImR0XCIsXG4gICAgICBcImZpZWxkc2V0XCIsXG4gICAgICBcImZpZ2NhcHRpb25cIixcbiAgICAgIFwiZmlndXJlXCIsXG4gICAgICBcImZvb3RlclwiLFxuICAgICAgXCJmb3JtXCIsXG4gICAgICBcImZyYW1lXCIsXG4gICAgICBcImZyYW1lc2V0XCIsXG4gICAgICBcImgxXCIsXG4gICAgICBcImgyXCIsXG4gICAgICBcImgzXCIsXG4gICAgICBcImg0XCIsXG4gICAgICBcImg1XCIsXG4gICAgICBcImg2XCIsXG4gICAgICBcImhlYWRcIixcbiAgICAgIFwiaGVhZGVyXCIsXG4gICAgICBcImhyXCIsXG4gICAgICBcImh0bWxcIixcbiAgICAgIFwiaWZyYW1lXCIsXG4gICAgICBcImxlZ2VuZFwiLFxuICAgICAgXCJsaVwiLFxuICAgICAgXCJsaW5rXCIsXG4gICAgICBcIm1haW5cIixcbiAgICAgIFwibWVudVwiLFxuICAgICAgXCJtZW51aXRlbVwiLFxuICAgICAgXCJuYXZcIixcbiAgICAgIFwibm9mcmFtZXNcIixcbiAgICAgIFwib2xcIixcbiAgICAgIFwib3B0Z3JvdXBcIixcbiAgICAgIFwib3B0aW9uXCIsXG4gICAgICBcInBcIixcbiAgICAgIFwicGFyYW1cIixcbiAgICAgIFwic2VjdGlvblwiLFxuICAgICAgXCJzb3VyY2VcIixcbiAgICAgIFwic3VtbWFyeVwiLFxuICAgICAgXCJ0YWJsZVwiLFxuICAgICAgXCJ0Ym9keVwiLFxuICAgICAgXCJ0ZFwiLFxuICAgICAgXCJ0Zm9vdFwiLFxuICAgICAgXCJ0aFwiLFxuICAgICAgXCJ0aGVhZFwiLFxuICAgICAgXCJ0aXRsZVwiLFxuICAgICAgXCJ0clwiLFxuICAgICAgXCJ0cmFja1wiLFxuICAgICAgXCJ1bFwiXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfcmUuanNcbnZhciByZXF1aXJlX2h0bWxfcmUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX3JlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGF0dHJfbmFtZSA9IFwiW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSpcIjtcbiAgICB2YXIgdW5xdW90ZWQgPSBcIlteXFxcIic9PD5gXFxcXHgwMC1cXFxceDIwXStcIjtcbiAgICB2YXIgc2luZ2xlX3F1b3RlZCA9IFwiJ1teJ10qJ1wiO1xuICAgIHZhciBkb3VibGVfcXVvdGVkID0gJ1wiW15cIl0qXCInO1xuICAgIHZhciBhdHRyX3ZhbHVlID0gXCIoPzpcIiArIHVucXVvdGVkICsgXCJ8XCIgKyBzaW5nbGVfcXVvdGVkICsgXCJ8XCIgKyBkb3VibGVfcXVvdGVkICsgXCIpXCI7XG4gICAgdmFyIGF0dHJpYnV0ZSA9IFwiKD86XFxcXHMrXCIgKyBhdHRyX25hbWUgKyBcIig/OlxcXFxzKj1cXFxccypcIiArIGF0dHJfdmFsdWUgKyBcIik/KVwiO1xuICAgIHZhciBvcGVuX3RhZyA9IFwiPFtBLVphLXpdW0EtWmEtejAtOVxcXFwtXSpcIiArIGF0dHJpYnV0ZSArIFwiKlxcXFxzKlxcXFwvPz5cIjtcbiAgICB2YXIgY2xvc2VfdGFnID0gXCI8XFxcXC9bQS1aYS16XVtBLVphLXowLTlcXFxcLV0qXFxcXHMqPlwiO1xuICAgIHZhciBjb21tZW50MiA9IFwiPCEtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPlwiO1xuICAgIHZhciBwcm9jZXNzaW5nID0gXCI8Wz9dW1xcXFxzXFxcXFNdKj9bP10+XCI7XG4gICAgdmFyIGRlY2xhcmF0aW9uID0gXCI8IVtBLVpdK1xcXFxzK1tePl0qPlwiO1xuICAgIHZhciBjZGF0YSA9IFwiPCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+XCI7XG4gICAgdmFyIEhUTUxfVEFHX1JFID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG9wZW5fdGFnICsgXCJ8XCIgKyBjbG9zZV90YWcgKyBcInxcIiArIGNvbW1lbnQyICsgXCJ8XCIgKyBwcm9jZXNzaW5nICsgXCJ8XCIgKyBkZWNsYXJhdGlvbiArIFwifFwiICsgY2RhdGEgKyBcIilcIik7XG4gICAgdmFyIEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgb3Blbl90YWcgKyBcInxcIiArIGNsb3NlX3RhZyArIFwiKVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0cy5IVE1MX1RBR19SRSA9IEhUTUxfVEFHX1JFO1xuICAgIG1vZHVsZS5leHBvcnRzLkhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzXG52YXIgcmVxdWlyZV9odG1sX2Jsb2NrID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGJsb2NrX25hbWVzID0gcmVxdWlyZV9odG1sX2Jsb2NrcygpO1xuICAgIHZhciBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFID0gcmVxdWlyZV9odG1sX3JlKCkuSFRNTF9PUEVOX0NMT1NFX1RBR19SRTtcbiAgICB2YXIgSFRNTF9TRVFVRU5DRVMgPSBbXG4gICAgICBbL148KHNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpKD89KFxcc3w+fCQpKS9pLCAvPFxcLyhzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKT4vaSwgdHJ1ZV0sXG4gICAgICBbL148IS0tLywgLy0tPi8sIHRydWVdLFxuICAgICAgWy9ePFxcPy8sIC9cXD8+LywgdHJ1ZV0sXG4gICAgICBbL148IVtBLVpdLywgLz4vLCB0cnVlXSxcbiAgICAgIFsvXjwhXFxbQ0RBVEFcXFsvLCAvXFxdXFxdPi8sIHRydWVdLFxuICAgICAgW25ldyBSZWdFeHAoXCJePC8/KFwiICsgYmxvY2tfbmFtZXMuam9pbihcInxcIikgKyBcIikoPz0oXFxcXHN8Lz8+fCQpKVwiLCBcImlcIiksIC9eJC8sIHRydWVdLFxuICAgICAgW25ldyBSZWdFeHAoSFRNTF9PUEVOX0NMT1NFX1RBR19SRS5zb3VyY2UgKyBcIlxcXFxzKiRcIiksIC9eJC8sIGZhbHNlXVxuICAgIF07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sX2Jsb2NrKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICAgICAgdmFyIGksIG5leHRMaW5lLCB0b2tlbiwgbGluZVRleHQsIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sIG1heDIgPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcbiAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDYwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4Mik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgSFRNTF9TRVFVRU5DRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzBdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBIVE1MX1NFUVVFTkNFUy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICByZXR1cm4gSFRNTF9TRVFVRU5DRVNbaV1bMl07XG4gICAgICB9XG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG4gICAgICBpZiAoIUhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICAgICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgICAgIG1heDIgPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuICAgICAgICAgIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4Mik7XG4gICAgICAgICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgICAgICBpZiAobGluZVRleHQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIG5leHRMaW5lKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImh0bWxfYmxvY2tcIiwgXCJcIiwgMCk7XG4gICAgICB0b2tlbi5tYXAgPSBbc3RhcnRMaW5lLCBuZXh0TGluZV07XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCB0cnVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanNcbnZhciByZXF1aXJlX2hlYWRpbmcgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaXNTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1NwYWNlO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGVhZGluZzIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gICAgICB2YXIgY2gsIGxldmVsLCB0bXAsIHRva2VuLCBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLCBtYXgyID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG4gICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuYWxsb3dJbmRlbnRhdGlvbiAmJiBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChjaCAhPT0gMzUgfHwgcG9zID49IG1heDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbGV2ZWwgPSAxO1xuICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gICAgICB3aGlsZSAoY2ggPT09IDM1ICYmIHBvcyA8IG1heDIgJiYgbGV2ZWwgPD0gNikge1xuICAgICAgICBsZXZlbCsrO1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbCA+IDYgfHwgcG9zIDwgbWF4MiAmJiAhaXNTcGFjZShjaCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG1heDIgPSBzdGF0ZS5za2lwU3BhY2VzQmFjayhtYXgyLCBwb3MpO1xuICAgICAgdG1wID0gc3RhdGUuc2tpcENoYXJzQmFjayhtYXgyLCAzNSwgcG9zKTtcbiAgICAgIGlmICh0bXAgPiBwb3MgJiYgaXNTcGFjZShzdGF0ZS5zcmMuY2hhckNvZGVBdCh0bXAgLSAxKSkpIHtcbiAgICAgICAgbWF4MiA9IHRtcDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiaGVhZGluZ19vcGVuXCIsIFwiaFwiICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgPSBcIiMjIyMjIyMjXCIuc2xpY2UoMCwgbGV2ZWwpO1xuICAgICAgdG9rZW4ubWFwID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZV07XG4gICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJpbmxpbmVcIiwgXCJcIiwgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4MikudHJpbSgpO1xuICAgICAgdG9rZW4ubWFwID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZV07XG4gICAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiaGVhZGluZ19jbG9zZVwiLCBcImhcIiArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCA9IFwiIyMjIyMjIyNcIi5zbGljZSgwLCBsZXZlbCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saGVhZGluZy5qc1xudmFyIHJlcXVpcmVfbGhlYWRpbmcgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lKSB7XG4gICAgICB2YXIgY29udGVudCwgdGVybWluYXRlLCBpLCBsLCB0b2tlbiwgcG9zLCBtYXgyLCBsZXZlbCwgbWFya2VyLCBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsIG9sZFBhcmVudFR5cGUsIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKFwicGFyYWdyYXBoXCIpO1xuICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmFsbG93SW5kZW50YXRpb24gJiYgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgICAgIHN0YXRlLnBhcmVudFR5cGUgPSBcInBhcmFncmFwaFwiO1xuICAgICAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmFsbG93SW5kZW50YXRpb24gJiYgc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA+PSBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgICAgICBtYXgyID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcbiAgICAgICAgICBpZiAocG9zIDwgbWF4Mikge1xuICAgICAgICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IDQ1IHx8IG1hcmtlciA9PT0gNjEpIHtcbiAgICAgICAgICAgICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcbiAgICAgICAgICAgICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuICAgICAgICAgICAgICBpZiAocG9zID49IG1heDIpIHtcbiAgICAgICAgICAgICAgICBsZXZlbCA9IG1hcmtlciA9PT0gNjEgPyAxIDogMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlcm1pbmF0ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWxldmVsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG4gICAgICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAxO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiaGVhZGluZ19vcGVuXCIsIFwiaFwiICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG4gICAgICB0b2tlbi5tYXAgPSBbc3RhcnRMaW5lLCBzdGF0ZS5saW5lXTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImlubGluZVwiLCBcIlwiLCAwKTtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgdG9rZW4ubWFwID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZSAtIDFdO1xuICAgICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImhlYWRpbmdfY2xvc2VcIiwgXCJoXCIgKyBTdHJpbmcobGV2ZWwpLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG4gICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3BhcmFncmFwaC5qc1xudmFyIHJlcXVpcmVfcGFyYWdyYXBoID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9wYXJhZ3JhcGguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcmFncmFwaDIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICAgICAgdmFyIGNvbnRlbnQsIHRlcm1pbmF0ZSwgaSwgbCwgdG9rZW4sIG9sZFBhcmVudFR5cGUsIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSwgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoXCJwYXJhZ3JhcGhcIiksIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xuICAgICAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gXCJwYXJhZ3JhcGhcIjtcbiAgICAgIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcbiAgICAgIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInBhcmFncmFwaF9vcGVuXCIsIFwicFwiLCAxKTtcbiAgICAgIHRva2VuLm1hcCA9IFtzdGFydExpbmUsIHN0YXRlLmxpbmVdO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiaW5saW5lXCIsIFwiXCIsIDApO1xuICAgICAgdG9rZW4uY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB0b2tlbi5tYXAgPSBbc3RhcnRMaW5lLCBzdGF0ZS5saW5lXTtcbiAgICAgIHRva2VuLmNoaWxkcmVuID0gW107XG4gICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJwYXJhZ3JhcGhfY2xvc2VcIiwgXCJwXCIsIC0xKTtcbiAgICAgIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2suanNcbnZhciByZXF1aXJlX3N0YXRlX2Jsb2NrID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9zdGF0ZV9ibG9jay5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBUb2tlbiA9IHJlcXVpcmVfdG9rZW4oKTtcbiAgICB2YXIgaXNTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1NwYWNlO1xuICAgIGZ1bmN0aW9uIFN0YXRlQmxvY2soc3JjLCBtZCwgZW52LCB0b2tlbnMpIHtcbiAgICAgIHZhciBjaCwgczIsIHN0YXJ0LCBwb3MsIGxlbiwgaW5kZW50LCBvZmZzZXQsIGluZGVudF9mb3VuZDtcbiAgICAgIHRoaXMuc3JjID0gc3JjO1xuICAgICAgdGhpcy5tZCA9IG1kO1xuICAgICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgIHRoaXMuYk1hcmtzID0gW107XG4gICAgICB0aGlzLmVNYXJrcyA9IFtdO1xuICAgICAgdGhpcy50U2hpZnQgPSBbXTtcbiAgICAgIHRoaXMuc0NvdW50ID0gW107XG4gICAgICB0aGlzLmJzQ291bnQgPSBbXTtcbiAgICAgIHRoaXMuYmxrSW5kZW50ID0gMDtcbiAgICAgIHRoaXMubGluZSA9IDA7XG4gICAgICB0aGlzLmxpbmVNYXggPSAwO1xuICAgICAgdGhpcy50aWdodCA9IGZhbHNlO1xuICAgICAgdGhpcy5kZEluZGVudCA9IC0xO1xuICAgICAgdGhpcy5saXN0SW5kZW50ID0gLTE7XG4gICAgICB0aGlzLnBhcmVudFR5cGUgPSBcInJvb3RcIjtcbiAgICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgICAgdGhpcy5yZXN1bHQgPSBcIlwiO1xuICAgICAgczIgPSB0aGlzLnNyYztcbiAgICAgIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuICAgICAgZm9yIChzdGFydCA9IHBvcyA9IGluZGVudCA9IG9mZnNldCA9IDAsIGxlbiA9IHMyLmxlbmd0aDsgcG9zIDwgbGVuOyBwb3MrKykge1xuICAgICAgICBjaCA9IHMyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpbmRlbnRfZm91bmQpIHtcbiAgICAgICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICAgICAgaWYgKGNoID09PSA5KSB7XG4gICAgICAgICAgICAgIG9mZnNldCArPSA0IC0gb2Zmc2V0ICUgNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGVudF9mb3VuZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gMTAgfHwgcG9zID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgaWYgKGNoICE9PSAxMCkge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYk1hcmtzLnB1c2goc3RhcnQpO1xuICAgICAgICAgIHRoaXMuZU1hcmtzLnB1c2gocG9zKTtcbiAgICAgICAgICB0aGlzLnRTaGlmdC5wdXNoKGluZGVudCk7XG4gICAgICAgICAgdGhpcy5zQ291bnQucHVzaChvZmZzZXQpO1xuICAgICAgICAgIHRoaXMuYnNDb3VudC5wdXNoKDApO1xuICAgICAgICAgIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYk1hcmtzLnB1c2goczIubGVuZ3RoKTtcbiAgICAgIHRoaXMuZU1hcmtzLnB1c2goczIubGVuZ3RoKTtcbiAgICAgIHRoaXMudFNoaWZ0LnB1c2goMCk7XG4gICAgICB0aGlzLnNDb3VudC5wdXNoKDApO1xuICAgICAgdGhpcy5ic0NvdW50LnB1c2goMCk7XG4gICAgICB0aGlzLmxpbmVNYXggPSB0aGlzLmJNYXJrcy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBTdGF0ZUJsb2NrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24odHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gICAgICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcbiAgICAgIHRva2VuLmJsb2NrID0gdHJ1ZTtcbiAgICAgIGlmIChuZXN0aW5nIDwgMClcbiAgICAgICAgdGhpcy5sZXZlbC0tO1xuICAgICAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgaWYgKG5lc3RpbmcgPiAwKVxuICAgICAgICB0aGlzLmxldmVsKys7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9O1xuICAgIFN0YXRlQmxvY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KGxpbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmJNYXJrc1tsaW5lXSArIHRoaXMudFNoaWZ0W2xpbmVdID49IHRoaXMuZU1hcmtzW2xpbmVdO1xuICAgIH07XG4gICAgU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcEVtcHR5TGluZXMgPSBmdW5jdGlvbiBza2lwRW1wdHlMaW5lcyhmcm9tKSB7XG4gICAgICBmb3IgKHZhciBtYXgyID0gdGhpcy5saW5lTWF4OyBmcm9tIDwgbWF4MjsgZnJvbSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmJNYXJrc1tmcm9tXSArIHRoaXMudFNoaWZ0W2Zyb21dIDwgdGhpcy5lTWFya3NbZnJvbV0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb207XG4gICAgfTtcbiAgICBTdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzID0gZnVuY3Rpb24gc2tpcFNwYWNlcyhwb3MpIHtcbiAgICAgIHZhciBjaDtcbiAgICAgIGZvciAodmFyIG1heDIgPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDI7IHBvcysrKSB7XG4gICAgICAgIGNoID0gdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfTtcbiAgICBTdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzQmFjayA9IGZ1bmN0aW9uIHNraXBTcGFjZXNCYWNrKHBvcywgbWluKSB7XG4gICAgICBpZiAocG9zIDw9IG1pbikge1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvcyA+IG1pbikge1xuICAgICAgICBpZiAoIWlzU3BhY2UodGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpKSB7XG4gICAgICAgICAgcmV0dXJuIHBvcyArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfTtcbiAgICBTdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnMgPSBmdW5jdGlvbiBza2lwQ2hhcnMocG9zLCBjb2RlMikge1xuICAgICAgZm9yICh2YXIgbWF4MiA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4MjsgcG9zKyspIHtcbiAgICAgICAgaWYgKHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gY29kZTIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuICAgIFN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFyc0JhY2sgPSBmdW5jdGlvbiBza2lwQ2hhcnNCYWNrKHBvcywgY29kZTIsIG1pbikge1xuICAgICAgaWYgKHBvcyA8PSBtaW4pIHtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICAgICAgaWYgKGNvZGUyICE9PSB0aGlzLnNyYy5jaGFyQ29kZUF0KC0tcG9zKSkge1xuICAgICAgICAgIHJldHVybiBwb3MgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgU3RhdGVCbG9jay5wcm90b3R5cGUuZ2V0TGluZXMgPSBmdW5jdGlvbiBnZXRMaW5lcyhiZWdpbiwgZW5kLCBpbmRlbnQsIGtlZXBMYXN0TEYpIHtcbiAgICAgIHZhciBpLCBsaW5lSW5kZW50LCBjaCwgZmlyc3QsIGxhc3QsIHF1ZXVlLCBsaW5lU3RhcnQsIGxpbmUgPSBiZWdpbjtcbiAgICAgIGlmIChiZWdpbiA+PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBxdWV1ZSA9IG5ldyBBcnJheShlbmQgLSBiZWdpbik7XG4gICAgICBmb3IgKGkgPSAwOyBsaW5lIDwgZW5kOyBsaW5lKyssIGkrKykge1xuICAgICAgICBsaW5lSW5kZW50ID0gMDtcbiAgICAgICAgbGluZVN0YXJ0ID0gZmlyc3QgPSB0aGlzLmJNYXJrc1tsaW5lXTtcbiAgICAgICAgaWYgKGxpbmUgKyAxIDwgZW5kIHx8IGtlZXBMYXN0TEYpIHtcbiAgICAgICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV0gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSB0aGlzLmVNYXJrc1tsaW5lXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZmlyc3QgPCBsYXN0ICYmIGxpbmVJbmRlbnQgPCBpbmRlbnQpIHtcbiAgICAgICAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoZmlyc3QpO1xuICAgICAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICAgICAgaWYgKGNoID09PSA5KSB7XG4gICAgICAgICAgICAgIGxpbmVJbmRlbnQgKz0gNCAtIChsaW5lSW5kZW50ICsgdGhpcy5ic0NvdW50W2xpbmVdKSAlIDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdCAtIGxpbmVTdGFydCA8IHRoaXMudFNoaWZ0W2xpbmVdKSB7XG4gICAgICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaXJzdCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lSW5kZW50ID4gaW5kZW50KSB7XG4gICAgICAgICAgcXVldWVbaV0gPSBuZXcgQXJyYXkobGluZUluZGVudCAtIGluZGVudCArIDEpLmpvaW4oXCIgXCIpICsgdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1ZXVlW2ldID0gdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVldWUuam9pbihcIlwiKTtcbiAgICB9O1xuICAgIFN0YXRlQmxvY2sucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUJsb2NrO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanNcbnZhciByZXF1aXJlX3BhcnNlcl9ibG9jayA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2Jsb2NrLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIFJ1bGVyID0gcmVxdWlyZV9ydWxlcigpO1xuICAgIHZhciBfcnVsZXMgPSBbXG4gICAgICBbXCJ0YWJsZVwiLCByZXF1aXJlX3RhYmxlKCksIFtcInBhcmFncmFwaFwiLCBcInJlZmVyZW5jZVwiXV0sXG4gICAgICBbXCJjb2RlXCIsIHJlcXVpcmVfY29kZSgpXSxcbiAgICAgIFtcImZlbmNlXCIsIHJlcXVpcmVfZmVuY2UoKSwgW1wicGFyYWdyYXBoXCIsIFwicmVmZXJlbmNlXCIsIFwiYmxvY2txdW90ZVwiLCBcImxpc3RcIl1dLFxuICAgICAgW1wiYmxvY2txdW90ZVwiLCByZXF1aXJlX2Jsb2NrcXVvdGUoKSwgW1wicGFyYWdyYXBoXCIsIFwicmVmZXJlbmNlXCIsIFwiYmxvY2txdW90ZVwiLCBcImxpc3RcIl1dLFxuICAgICAgW1wiaHJcIiwgcmVxdWlyZV9ocigpLCBbXCJwYXJhZ3JhcGhcIiwgXCJyZWZlcmVuY2VcIiwgXCJibG9ja3F1b3RlXCIsIFwibGlzdFwiXV0sXG4gICAgICBbXCJsaXN0XCIsIHJlcXVpcmVfbGlzdCgpLCBbXCJwYXJhZ3JhcGhcIiwgXCJyZWZlcmVuY2VcIiwgXCJibG9ja3F1b3RlXCJdXSxcbiAgICAgIFtcInJlZmVyZW5jZVwiLCByZXF1aXJlX3JlZmVyZW5jZSgpXSxcbiAgICAgIFtcImh0bWxfYmxvY2tcIiwgcmVxdWlyZV9odG1sX2Jsb2NrKCksIFtcInBhcmFncmFwaFwiLCBcInJlZmVyZW5jZVwiLCBcImJsb2NrcXVvdGVcIl1dLFxuICAgICAgW1wiaGVhZGluZ1wiLCByZXF1aXJlX2hlYWRpbmcoKSwgW1wicGFyYWdyYXBoXCIsIFwicmVmZXJlbmNlXCIsIFwiYmxvY2txdW90ZVwiXV0sXG4gICAgICBbXCJsaGVhZGluZ1wiLCByZXF1aXJlX2xoZWFkaW5nKCldLFxuICAgICAgW1wicGFyYWdyYXBoXCIsIHJlcXVpcmVfcGFyYWdyYXBoKCldXG4gICAgXTtcbiAgICBmdW5jdGlvbiBQYXJzZXJCbG9jaygpIHtcbiAgICAgIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSwgeyBhbHQ6IChfcnVsZXNbaV1bMl0gfHwgW10pLnNsaWNlKCkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFBhcnNlckJsb2NrLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUpIHtcbiAgICAgIHZhciBvaywgaSwgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKFwiXCIpLCBsZW4gPSBydWxlcy5sZW5ndGgsIGxpbmUgPSBzdGFydExpbmUsIGhhc0VtcHR5TGluZXMgPSBmYWxzZSwgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZztcbiAgICAgIHdoaWxlIChsaW5lIDwgZW5kTGluZSkge1xuICAgICAgICBzdGF0ZS5saW5lID0gbGluZSA9IHN0YXRlLnNraXBFbXB0eUxpbmVzKGxpbmUpO1xuICAgICAgICBpZiAobGluZSA+PSBlbmRMaW5lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnNDb3VudFtsaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5sZXZlbCA+PSBtYXhOZXN0aW5nKSB7XG4gICAgICAgICAgc3RhdGUubGluZSA9IGVuZExpbmU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgbGluZSwgZW5kTGluZSwgZmFsc2UpO1xuICAgICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnRpZ2h0ID0gIWhhc0VtcHR5TGluZXM7XG4gICAgICAgIGlmIChzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKSkge1xuICAgICAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgICBpZiAobGluZSA8IGVuZExpbmUgJiYgc3RhdGUuaXNFbXB0eShsaW5lKSkge1xuICAgICAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICBzdGF0ZS5saW5lID0gbGluZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyQmxvY2sucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgICAgIHZhciBzdGF0ZTtcbiAgICAgIGlmICghc3JjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuICAgICAgdGhpcy50b2tlbml6ZShzdGF0ZSwgc3RhdGUubGluZSwgc3RhdGUubGluZU1heCk7XG4gICAgfTtcbiAgICBQYXJzZXJCbG9jay5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlX3N0YXRlX2Jsb2NrKCk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJCbG9jaztcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanNcbnZhciByZXF1aXJlX3RleHQgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gaXNUZXJtaW5hdG9yQ2hhcihjaCkge1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICBjYXNlIDMzOlxuICAgICAgICBjYXNlIDM1OlxuICAgICAgICBjYXNlIDM2OlxuICAgICAgICBjYXNlIDM3OlxuICAgICAgICBjYXNlIDM4OlxuICAgICAgICBjYXNlIDQyOlxuICAgICAgICBjYXNlIDQzOlxuICAgICAgICBjYXNlIDQ1OlxuICAgICAgICBjYXNlIDU4OlxuICAgICAgICBjYXNlIDYwOlxuICAgICAgICBjYXNlIDYxOlxuICAgICAgICBjYXNlIDYyOlxuICAgICAgICBjYXNlIDY0OlxuICAgICAgICBjYXNlIDkxOlxuICAgICAgICBjYXNlIDkyOlxuICAgICAgICBjYXNlIDkzOlxuICAgICAgICBjYXNlIDk0OlxuICAgICAgICBjYXNlIDk1OlxuICAgICAgICBjYXNlIDk2OlxuICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgIGNhc2UgMTI2OlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0MihzdGF0ZSwgc2lsZW50KSB7XG4gICAgICB2YXIgcG9zID0gc3RhdGUucG9zO1xuICAgICAgd2hpbGUgKHBvcyA8IHN0YXRlLnBvc01heCAmJiAhaXNUZXJtaW5hdG9yQ2hhcihzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICAgIGlmIChwb3MgPT09IHN0YXRlLnBvcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShzdGF0ZS5wb3MsIHBvcyk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBwb3M7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbmV3bGluZS5qc1xudmFyIHJlcXVpcmVfbmV3bGluZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL25ld2xpbmUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaXNTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1NwYWNlO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmV3bGluZShzdGF0ZSwgc2lsZW50KSB7XG4gICAgICB2YXIgcG1heCwgbWF4Miwgd3MsIHBvcyA9IHN0YXRlLnBvcztcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAxMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwbWF4ID0gc3RhdGUucGVuZGluZy5sZW5ndGggLSAxO1xuICAgICAgbWF4MiA9IHN0YXRlLnBvc01heDtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGlmIChwbWF4ID49IDAgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXgpID09PSAzMikge1xuICAgICAgICAgIGlmIChwbWF4ID49IDEgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXggLSAxKSA9PT0gMzIpIHtcbiAgICAgICAgICAgIHdzID0gcG1heCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAod3MgPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQod3MgLSAxKSA9PT0gMzIpXG4gICAgICAgICAgICAgIHdzLS07XG4gICAgICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5zbGljZSgwLCB3cyk7XG4gICAgICAgICAgICBzdGF0ZS5wdXNoKFwiaGFyZGJyZWFrXCIsIFwiYnJcIiwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLnBlbmRpbmcgPSBzdGF0ZS5wZW5kaW5nLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIHN0YXRlLnB1c2goXCJzb2Z0YnJlYWtcIiwgXCJiclwiLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUucHVzaChcInNvZnRicmVha1wiLCBcImJyXCIsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwb3MrKztcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgyICYmIGlzU3BhY2Uoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBwb3M7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZXNjYXBlLmpzXG52YXIgcmVxdWlyZV9lc2NhcGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaXNTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1NwYWNlO1xuICAgIHZhciBFU0NBUEVEID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBFU0NBUEVELnB1c2goMCk7XG4gICAgfVxuICAgIHZhciBpO1xuICAgIFwiXFxcXCFcXFwiIyQlJicoKSorLC4vOjs8PT4/QFtdXl9ge3x9fi1cIi5zcGxpdChcIlwiKS5mb3JFYWNoKGZ1bmN0aW9uKGNoKSB7XG4gICAgICBFU0NBUEVEW2NoLmNoYXJDb2RlQXQoMCldID0gMTtcbiAgICB9KTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZShzdGF0ZSwgc2lsZW50KSB7XG4gICAgICB2YXIgY2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4MiA9IHN0YXRlLnBvc01heDtcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSA5Mikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwb3MrKztcbiAgICAgIGlmIChwb3MgPCBtYXgyKSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGNoIDwgMjU2ICYmIEVTQ0FQRURbY2hdICE9PSAwKSB7XG4gICAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3Bvc107XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLnBvcyArPSAyO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gMTApIHtcbiAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgc3RhdGUucHVzaChcImhhcmRicmVha1wiLCBcImJyXCIsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB3aGlsZSAocG9zIDwgbWF4Mikge1xuICAgICAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5wb3MgPSBwb3M7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MrKztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWNrdGlja3MuanNcbnZhciByZXF1aXJlX2JhY2t0aWNrcyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFja3RpY2soc3RhdGUsIHNpbGVudCkge1xuICAgICAgdmFyIHN0YXJ0LCBtYXgyLCBtYXJrZXIsIHRva2VuLCBtYXRjaFN0YXJ0LCBtYXRjaEVuZCwgb3BlbmVyTGVuZ3RoLCBjbG9zZXJMZW5ndGgsIHBvcyA9IHN0YXRlLnBvcywgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGNoICE9PSA5Nikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHBvcztcbiAgICAgIHBvcysrO1xuICAgICAgbWF4MiA9IHN0YXRlLnBvc01heDtcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgyICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDk2KSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MpO1xuICAgICAgb3BlbmVyTGVuZ3RoID0gbWFya2VyLmxlbmd0aDtcbiAgICAgIGlmIChzdGF0ZS5iYWNrdGlja3NTY2FubmVkICYmIChzdGF0ZS5iYWNrdGlja3Nbb3BlbmVyTGVuZ3RoXSB8fCAwKSA8PSBzdGFydCkge1xuICAgICAgICBpZiAoIXNpbGVudClcbiAgICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlcjtcbiAgICAgICAgc3RhdGUucG9zICs9IG9wZW5lckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBtYXRjaFN0YXJ0ID0gbWF0Y2hFbmQgPSBwb3M7XG4gICAgICB3aGlsZSAoKG1hdGNoU3RhcnQgPSBzdGF0ZS5zcmMuaW5kZXhPZihcImBcIiwgbWF0Y2hFbmQpKSAhPT0gLTEpIHtcbiAgICAgICAgbWF0Y2hFbmQgPSBtYXRjaFN0YXJ0ICsgMTtcbiAgICAgICAgd2hpbGUgKG1hdGNoRW5kIDwgbWF4MiAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChtYXRjaEVuZCkgPT09IDk2KSB7XG4gICAgICAgICAgbWF0Y2hFbmQrKztcbiAgICAgICAgfVxuICAgICAgICBjbG9zZXJMZW5ndGggPSBtYXRjaEVuZCAtIG1hdGNoU3RhcnQ7XG4gICAgICAgIGlmIChjbG9zZXJMZW5ndGggPT09IG9wZW5lckxlbmd0aCkge1xuICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJjb2RlX2lubGluZVwiLCBcImNvZGVcIiwgMCk7XG4gICAgICAgICAgICB0b2tlbi5tYXJrdXAgPSBtYXJrZXI7XG4gICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF0Y2hTdGFydCkucmVwbGFjZSgvXFxuL2csIFwiIFwiKS5yZXBsYWNlKC9eICguKykgJC8sIFwiJDFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLnBvcyA9IG1hdGNoRW5kO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2t0aWNrc1tjbG9zZXJMZW5ndGhdID0gbWF0Y2hTdGFydDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmJhY2t0aWNrc1NjYW5uZWQgPSB0cnVlO1xuICAgICAgaWYgKCFzaWxlbnQpXG4gICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gbWFya2VyO1xuICAgICAgc3RhdGUucG9zICs9IG9wZW5lckxlbmd0aDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoLmpzXG52YXIgcmVxdWlyZV9zdHJpa2V0aHJvdWdoID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSwgc2lsZW50KSB7XG4gICAgICB2YXIgaSwgc2Nhbm5lZCwgdG9rZW4sIGxlbiwgY2gsIHN0YXJ0ID0gc3RhdGUucG9zLCBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG4gICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXJrZXIgIT09IDEyNikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIHRydWUpO1xuICAgICAgbGVuID0gc2Nhbm5lZC5sZW5ndGg7XG4gICAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcbiAgICAgIGlmIChsZW4gPCAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChsZW4gJSAyKSB7XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRleHRcIiwgXCJcIiwgMCk7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBjaDtcbiAgICAgICAgbGVuLS07XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidGV4dFwiLCBcIlwiLCAwKTtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IGNoICsgY2g7XG4gICAgICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICAgICAgbWFya2VyLFxuICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgICB0b2tlbjogc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG4gICAgICAgICAgZW5kOiAtMSxcbiAgICAgICAgICBvcGVuOiBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgICAgIGNsb3NlOiBzY2FubmVkLmNhbl9jbG9zZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcG9zdFByb2Nlc3Moc3RhdGUsIGRlbGltaXRlcnMpIHtcbiAgICAgIHZhciBpLCBqLCBzdGFydERlbGltLCBlbmREZWxpbSwgdG9rZW4sIGxvbmVNYXJrZXJzID0gW10sIG1heDIgPSBkZWxpbWl0ZXJzLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXgyOyBpKyspIHtcbiAgICAgICAgc3RhcnREZWxpbSA9IGRlbGltaXRlcnNbaV07XG4gICAgICAgIGlmIChzdGFydERlbGltLm1hcmtlciAhPT0gMTI2KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVuZERlbGltID0gZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZF07XG4gICAgICAgIHRva2VuID0gc3RhdGUudG9rZW5zW3N0YXJ0RGVsaW0udG9rZW5dO1xuICAgICAgICB0b2tlbi50eXBlID0gXCJzX29wZW5cIjtcbiAgICAgICAgdG9rZW4udGFnID0gXCJzXCI7XG4gICAgICAgIHRva2VuLm5lc3RpbmcgPSAxO1xuICAgICAgICB0b2tlbi5tYXJrdXAgPSBcIn5+XCI7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBcIlwiO1xuICAgICAgICB0b2tlbiA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgICAgIHRva2VuLnR5cGUgPSBcInNfY2xvc2VcIjtcbiAgICAgICAgdG9rZW4udGFnID0gXCJzXCI7XG4gICAgICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICAgICAgdG9rZW4ubWFya3VwID0gXCJ+flwiO1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gXCJcIjtcbiAgICAgICAgaWYgKHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLnR5cGUgPT09IFwidGV4dFwiICYmIHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLmNvbnRlbnQgPT09IFwiflwiKSB7XG4gICAgICAgICAgbG9uZU1hcmtlcnMucHVzaChlbmREZWxpbS50b2tlbiAtIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAobG9uZU1hcmtlcnMubGVuZ3RoKSB7XG4gICAgICAgIGkgPSBsb25lTWFya2Vycy5wb3AoKTtcbiAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICB3aGlsZSAoaiA8IHN0YXRlLnRva2Vucy5sZW5ndGggJiYgc3RhdGUudG9rZW5zW2pdLnR5cGUgPT09IFwic19jbG9zZVwiKSB7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGotLTtcbiAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICB0b2tlbiA9IHN0YXRlLnRva2Vuc1tqXTtcbiAgICAgICAgICBzdGF0ZS50b2tlbnNbal0gPSBzdGF0ZS50b2tlbnNbaV07XG4gICAgICAgICAgc3RhdGUudG9rZW5zW2ldID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMucG9zdFByb2Nlc3MgPSBmdW5jdGlvbiBzdHJpa2V0aHJvdWdoKHN0YXRlKSB7XG4gICAgICB2YXIgY3VyciwgdG9rZW5zX21ldGEgPSBzdGF0ZS50b2tlbnNfbWV0YSwgbWF4MiA9IHN0YXRlLnRva2Vuc19tZXRhLmxlbmd0aDtcbiAgICAgIHBvc3RQcm9jZXNzKHN0YXRlLCBzdGF0ZS5kZWxpbWl0ZXJzKTtcbiAgICAgIGZvciAoY3VyciA9IDA7IGN1cnIgPCBtYXgyOyBjdXJyKyspIHtcbiAgICAgICAgaWYgKHRva2Vuc19tZXRhW2N1cnJdICYmIHRva2Vuc19tZXRhW2N1cnJdLmRlbGltaXRlcnMpIHtcbiAgICAgICAgICBwb3N0UHJvY2VzcyhzdGF0ZSwgdG9rZW5zX21ldGFbY3Vycl0uZGVsaW1pdGVycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMuanNcbnZhciByZXF1aXJlX2VtcGhhc2lzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlLCBzaWxlbnQpIHtcbiAgICAgIHZhciBpLCBzY2FubmVkLCB0b2tlbiwgc3RhcnQgPSBzdGF0ZS5wb3MsIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcbiAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG1hcmtlciAhPT0gOTUgJiYgbWFya2VyICE9PSA0Mikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIG1hcmtlciA9PT0gNDIpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHNjYW5uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidGV4dFwiLCBcIlwiLCAwKTtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcbiAgICAgICAgc3RhdGUuZGVsaW1pdGVycy5wdXNoKHtcbiAgICAgICAgICBtYXJrZXIsXG4gICAgICAgICAgbGVuZ3RoOiBzY2FubmVkLmxlbmd0aCxcbiAgICAgICAgICB0b2tlbjogc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG4gICAgICAgICAgZW5kOiAtMSxcbiAgICAgICAgICBvcGVuOiBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgICAgIGNsb3NlOiBzY2FubmVkLmNhbl9jbG9zZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcG9zdFByb2Nlc3Moc3RhdGUsIGRlbGltaXRlcnMpIHtcbiAgICAgIHZhciBpLCBzdGFydERlbGltLCBlbmREZWxpbSwgdG9rZW4sIGNoLCBpc1N0cm9uZywgbWF4MiA9IGRlbGltaXRlcnMubGVuZ3RoO1xuICAgICAgZm9yIChpID0gbWF4MiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuICAgICAgICBpZiAoc3RhcnREZWxpbS5tYXJrZXIgIT09IDk1ICYmIHN0YXJ0RGVsaW0ubWFya2VyICE9PSA0Mikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydERlbGltLmVuZCA9PT0gLTEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdO1xuICAgICAgICBpc1N0cm9uZyA9IGkgPiAwICYmIGRlbGltaXRlcnNbaSAtIDFdLmVuZCA9PT0gc3RhcnREZWxpbS5lbmQgKyAxICYmIGRlbGltaXRlcnNbaSAtIDFdLm1hcmtlciA9PT0gc3RhcnREZWxpbS5tYXJrZXIgJiYgZGVsaW1pdGVyc1tpIC0gMV0udG9rZW4gPT09IHN0YXJ0RGVsaW0udG9rZW4gLSAxICYmIGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmQgKyAxXS50b2tlbiA9PT0gZW5kRGVsaW0udG9rZW4gKyAxO1xuICAgICAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnREZWxpbS5tYXJrZXIpO1xuICAgICAgICB0b2tlbiA9IHN0YXRlLnRva2Vuc1tzdGFydERlbGltLnRva2VuXTtcbiAgICAgICAgdG9rZW4udHlwZSA9IGlzU3Ryb25nID8gXCJzdHJvbmdfb3BlblwiIDogXCJlbV9vcGVuXCI7XG4gICAgICAgIHRva2VuLnRhZyA9IGlzU3Ryb25nID8gXCJzdHJvbmdcIiA6IFwiZW1cIjtcbiAgICAgICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgICAgIHRva2VuLm1hcmt1cCA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoO1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gXCJcIjtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW5dO1xuICAgICAgICB0b2tlbi50eXBlID0gaXNTdHJvbmcgPyBcInN0cm9uZ19jbG9zZVwiIDogXCJlbV9jbG9zZVwiO1xuICAgICAgICB0b2tlbi50YWcgPSBpc1N0cm9uZyA/IFwic3Ryb25nXCIgOiBcImVtXCI7XG4gICAgICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICAgICAgdG9rZW4ubWFya3VwID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2g7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBcIlwiO1xuICAgICAgICBpZiAoaXNTdHJvbmcpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbnNbZGVsaW1pdGVyc1tpIC0gMV0udG9rZW5dLmNvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kICsgMV0udG9rZW5dLmNvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlKSB7XG4gICAgICB2YXIgY3VyciwgdG9rZW5zX21ldGEgPSBzdGF0ZS50b2tlbnNfbWV0YSwgbWF4MiA9IHN0YXRlLnRva2Vuc19tZXRhLmxlbmd0aDtcbiAgICAgIHBvc3RQcm9jZXNzKHN0YXRlLCBzdGF0ZS5kZWxpbWl0ZXJzKTtcbiAgICAgIGZvciAoY3VyciA9IDA7IGN1cnIgPCBtYXgyOyBjdXJyKyspIHtcbiAgICAgICAgaWYgKHRva2Vuc19tZXRhW2N1cnJdICYmIHRva2Vuc19tZXRhW2N1cnJdLmRlbGltaXRlcnMpIHtcbiAgICAgICAgICBwb3N0UHJvY2VzcyhzdGF0ZSwgdG9rZW5zX21ldGFbY3Vycl0uZGVsaW1pdGVycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbGluay5qc1xudmFyIHJlcXVpcmVfbGluayA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbm9ybWFsaXplUmVmZXJlbmNlID0gcmVxdWlyZV91dGlscygpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbiAgICB2YXIgaXNTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1NwYWNlO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGluazIoc3RhdGUsIHNpbGVudCkge1xuICAgICAgdmFyIGF0dHJzLCBjb2RlMiwgbGFiZWwsIGxhYmVsRW5kLCBsYWJlbFN0YXJ0LCBwb3MsIHJlcywgcmVmLCB0b2tlbiwgaHJlZiA9IFwiXCIsIHRpdGxlID0gXCJcIiwgb2xkUG9zID0gc3RhdGUucG9zLCBtYXgyID0gc3RhdGUucG9zTWF4LCBzdGFydCA9IHN0YXRlLnBvcywgcGFyc2VSZWZlcmVuY2UgPSB0cnVlO1xuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgIT09IDkxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxhYmVsU3RhcnQgPSBzdGF0ZS5wb3MgKyAxO1xuICAgICAgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MsIHRydWUpO1xuICAgICAgaWYgKGxhYmVsRW5kIDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICBpZiAocG9zIDwgbWF4MiAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSA0MCkge1xuICAgICAgICBwYXJzZVJlZmVyZW5jZSA9IGZhbHNlO1xuICAgICAgICBwb3MrKztcbiAgICAgICAgZm9yICg7IHBvcyA8IG1heDI7IHBvcysrKSB7XG4gICAgICAgICAgY29kZTIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgIGlmICghaXNTcGFjZShjb2RlMikgJiYgY29kZTIgIT09IDEwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSBtYXgyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICAgIGZvciAoOyBwb3MgPCBtYXgyOyBwb3MrKykge1xuICAgICAgICAgICAgY29kZTIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUyKSAmJiBjb2RlMiAhPT0gMTApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgICAgICAgaWYgKHBvcyA8IG1heDIgJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgICAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICAgICAgICBmb3IgKDsgcG9zIDwgbWF4MjsgcG9zKyspIHtcbiAgICAgICAgICAgICAgY29kZTIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgICBpZiAoIWlzU3BhY2UoY29kZTIpICYmIGNvZGUyICE9PSAxMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gbWF4MiB8fCBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSA0MSkge1xuICAgICAgICAgIHBhcnNlUmVmZXJlbmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZVJlZmVyZW5jZSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCBtYXgyICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDkxKSB7XG4gICAgICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgICAgIHBvcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHBvcyk7XG4gICAgICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxhYmVsKSB7XG4gICAgICAgICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IHN0YXRlLmVudi5yZWZlcmVuY2VzW25vcm1hbGl6ZVJlZmVyZW5jZShsYWJlbCldO1xuICAgICAgICBpZiAoIXJlZikge1xuICAgICAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgICAgICB0aXRsZSA9IHJlZi50aXRsZTtcbiAgICAgIH1cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IGxhYmVsU3RhcnQ7XG4gICAgICAgIHN0YXRlLnBvc01heCA9IGxhYmVsRW5kO1xuICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJsaW5rX29wZW5cIiwgXCJhXCIsIDEpO1xuICAgICAgICB0b2tlbi5hdHRycyA9IGF0dHJzID0gW1tcImhyZWZcIiwgaHJlZl1dO1xuICAgICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgICBhdHRycy5wdXNoKFtcInRpdGxlXCIsIHRpdGxlXSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubWQuaW5saW5lLnRva2VuaXplKHN0YXRlKTtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwibGlua19jbG9zZVwiLCBcImFcIiwgLTEpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gcG9zO1xuICAgICAgc3RhdGUucG9zTWF4ID0gbWF4MjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qc1xudmFyIHJlcXVpcmVfaW1hZ2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBub3JtYWxpemVSZWZlcmVuY2UgPSByZXF1aXJlX3V0aWxzKCkubm9ybWFsaXplUmVmZXJlbmNlO1xuICAgIHZhciBpc1NwYWNlID0gcmVxdWlyZV91dGlscygpLmlzU3BhY2U7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbWFnZTIoc3RhdGUsIHNpbGVudCkge1xuICAgICAgdmFyIGF0dHJzLCBjb2RlMiwgY29udGVudCwgbGFiZWwsIGxhYmVsRW5kLCBsYWJlbFN0YXJ0LCBwb3MsIHJlZiwgcmVzLCB0aXRsZSwgdG9rZW4sIHRva2Vucywgc3RhcnQsIGhyZWYgPSBcIlwiLCBvbGRQb3MgPSBzdGF0ZS5wb3MsIG1heDIgPSBzdGF0ZS5wb3NNYXg7XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMzMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDEpICE9PSA5MSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsYWJlbFN0YXJ0ID0gc3RhdGUucG9zICsgMjtcbiAgICAgIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zICsgMSwgZmFsc2UpO1xuICAgICAgaWYgKGxhYmVsRW5kIDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICBpZiAocG9zIDwgbWF4MiAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSA0MCkge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgZm9yICg7IHBvcyA8IG1heDI7IHBvcysrKSB7XG4gICAgICAgICAgY29kZTIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgIGlmICghaXNTcGFjZShjb2RlMikgJiYgY29kZTIgIT09IDEwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSBtYXgyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICBmb3IgKDsgcG9zIDwgbWF4MjsgcG9zKyspIHtcbiAgICAgICAgICBjb2RlMiA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUyKSAmJiBjb2RlMiAhPT0gMTApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgICAgICBpZiAocG9zIDwgbWF4MiAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgICAgIGZvciAoOyBwb3MgPCBtYXgyOyBwb3MrKykge1xuICAgICAgICAgICAgY29kZTIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUyKSAmJiBjb2RlMiAhPT0gMTApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpdGxlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IG1heDIgfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gNDEpIHtcbiAgICAgICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zIDwgbWF4MiAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSA5MSkge1xuICAgICAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAgICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcysrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYWJlbCkge1xuICAgICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICAgICAgaWYgKCFyZWYpIHtcbiAgICAgICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSByZWYuaHJlZjtcbiAgICAgICAgdGl0bGUgPSByZWYudGl0bGU7XG4gICAgICB9XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBjb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTtcbiAgICAgICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKGNvbnRlbnQsIHN0YXRlLm1kLCBzdGF0ZS5lbnYsIHRva2VucyA9IFtdKTtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiaW1hZ2VcIiwgXCJpbWdcIiwgMCk7XG4gICAgICAgIHRva2VuLmF0dHJzID0gYXR0cnMgPSBbW1wic3JjXCIsIGhyZWZdLCBbXCJhbHRcIiwgXCJcIl1dO1xuICAgICAgICB0b2tlbi5jaGlsZHJlbiA9IHRva2VucztcbiAgICAgICAgdG9rZW4uY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgIGF0dHJzLnB1c2goW1widGl0bGVcIiwgdGl0bGVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gcG9zO1xuICAgICAgc3RhdGUucG9zTWF4ID0gbWF4MjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qc1xudmFyIHJlcXVpcmVfYXV0b2xpbmsgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBFTUFJTF9SRSA9IC9eKFthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSopJC87XG4gICAgdmFyIEFVVE9MSU5LX1JFID0gL14oW2EtekEtWl1bYS16QS1aMC05Ky5cXC1dezEsMzF9KTooW148PlxceDAwLVxceDIwXSopJC87XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdXRvbGluayhzdGF0ZSwgc2lsZW50KSB7XG4gICAgICB2YXIgdXJsLCBmdWxsVXJsLCB0b2tlbiwgY2gsIHN0YXJ0LCBtYXgyLCBwb3MgPSBzdGF0ZS5wb3M7XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gNjApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgICBtYXgyID0gc3RhdGUucG9zTWF4O1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIGlmICgrK3BvcyA+PSBtYXgyKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoY2ggPT09IDYwKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGNoID09PSA2MilcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHVybCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCArIDEsIHBvcyk7XG4gICAgICBpZiAoQVVUT0xJTktfUkUudGVzdCh1cmwpKSB7XG4gICAgICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHVybCk7XG4gICAgICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGZ1bGxVcmwpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwibGlua19vcGVuXCIsIFwiYVwiLCAxKTtcbiAgICAgICAgICB0b2tlbi5hdHRycyA9IFtbXCJocmVmXCIsIGZ1bGxVcmxdXTtcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgPSBcImF1dG9saW5rXCI7XG4gICAgICAgICAgdG9rZW4uaW5mbyA9IFwiYXV0b1wiO1xuICAgICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRleHRcIiwgXCJcIiwgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XG4gICAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwibGlua19jbG9zZVwiLCBcImFcIiwgLTEpO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCA9IFwiYXV0b2xpbmtcIjtcbiAgICAgICAgICB0b2tlbi5pbmZvID0gXCJhdXRvXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zICs9IHVybC5sZW5ndGggKyAyO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChFTUFJTF9SRS50ZXN0KHVybCkpIHtcbiAgICAgICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsoXCJtYWlsdG86XCIgKyB1cmwpO1xuICAgICAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImxpbmtfb3BlblwiLCBcImFcIiwgMSk7XG4gICAgICAgICAgdG9rZW4uYXR0cnMgPSBbW1wiaHJlZlwiLCBmdWxsVXJsXV07XG4gICAgICAgICAgdG9rZW4ubWFya3VwID0gXCJhdXRvbGlua1wiO1xuICAgICAgICAgIHRva2VuLmluZm8gPSBcImF1dG9cIjtcbiAgICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJ0ZXh0XCIsIFwiXCIsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmwpO1xuICAgICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImxpbmtfY2xvc2VcIiwgXCJhXCIsIC0xKTtcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgPSBcImF1dG9saW5rXCI7XG4gICAgICAgICAgdG9rZW4uaW5mbyA9IFwiYXV0b1wiO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBvcyArPSB1cmwubGVuZ3RoICsgMjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lLmpzXG52YXIgcmVxdWlyZV9odG1sX2lubGluZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIEhUTUxfVEFHX1JFID0gcmVxdWlyZV9odG1sX3JlKCkuSFRNTF9UQUdfUkU7XG4gICAgZnVuY3Rpb24gaXNMZXR0ZXIoY2gpIHtcbiAgICAgIHZhciBsYyA9IGNoIHwgMzI7XG4gICAgICByZXR1cm4gbGMgPj0gOTcgJiYgbGMgPD0gMTIyO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfaW5saW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgICAgIHZhciBjaCwgbWF0Y2gsIG1heDIsIHRva2VuLCBwb3MgPSBzdGF0ZS5wb3M7XG4gICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBtYXgyID0gc3RhdGUucG9zTWF4O1xuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDYwIHx8IHBvcyArIDIgPj0gbWF4Mikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgICAgaWYgKGNoICE9PSAzMyAmJiBjaCAhPT0gNjMgJiYgY2ggIT09IDQ3ICYmICFpc0xldHRlcihjaCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChIVE1MX1RBR19SRSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImh0bWxfaW5saW5lXCIsIFwiXCIsIDApO1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzXG52YXIgcmVxdWlyZV9lbnRpdHkgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZW50aXRpZXMgPSByZXF1aXJlX2VudGl0aWVzMigpO1xuICAgIHZhciBoYXMgPSByZXF1aXJlX3V0aWxzKCkuaGFzO1xuICAgIHZhciBpc1ZhbGlkRW50aXR5Q29kZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1ZhbGlkRW50aXR5Q29kZTtcbiAgICB2YXIgZnJvbUNvZGVQb2ludCA9IHJlcXVpcmVfdXRpbHMoKS5mcm9tQ29kZVBvaW50O1xuICAgIHZhciBESUdJVEFMX1JFID0gL14mIygoPzp4W2EtZjAtOV17MSw2fXxbMC05XXsxLDd9KSk7L2k7XG4gICAgdmFyIE5BTUVEX1JFID0gL14mKFthLXpdW2EtejAtOV17MSwzMX0pOy9pO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW50aXR5KHN0YXRlLCBzaWxlbnQpIHtcbiAgICAgIHZhciBjaCwgY29kZTIsIG1hdGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heDIgPSBzdGF0ZS5wb3NNYXg7XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMzgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHBvcyArIDEgPCBtYXgyKSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgICAgIGlmIChjaCA9PT0gMzUpIHtcbiAgICAgICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKERJR0lUQUxfUkUpO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgICAgY29kZTIgPSBtYXRjaFsxXVswXS50b0xvd2VyQ2FzZSgpID09PSBcInhcIiA/IHBhcnNlSW50KG1hdGNoWzFdLnNsaWNlKDEpLCAxNikgOiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUyKSA/IGZyb21Db2RlUG9pbnQoY29kZTIpIDogZnJvbUNvZGVQb2ludCg2NTUzMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goTkFNRURfUkUpO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgaWYgKGhhcyhlbnRpdGllcywgbWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucGVuZGluZyArPSBlbnRpdGllc1ttYXRjaFsxXV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IFwiJlwiO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycy5qc1xudmFyIHJlcXVpcmVfYmFsYW5jZV9wYWlycyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBwcm9jZXNzRGVsaW1pdGVycyhzdGF0ZSwgZGVsaW1pdGVycykge1xuICAgICAgdmFyIGNsb3NlcklkeCwgb3BlbmVySWR4LCBjbG9zZXIsIG9wZW5lciwgbWluT3BlbmVySWR4LCBuZXdNaW5PcGVuZXJJZHgsIGlzT2RkTWF0Y2gsIGxhc3RKdW1wLCBvcGVuZXJzQm90dG9tID0ge30sIG1heDIgPSBkZWxpbWl0ZXJzLmxlbmd0aDtcbiAgICAgIGlmICghbWF4MilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdmFyIGhlYWRlcklkeCA9IDA7XG4gICAgICB2YXIgbGFzdFRva2VuSWR4ID0gLTI7XG4gICAgICB2YXIganVtcHMgPSBbXTtcbiAgICAgIGZvciAoY2xvc2VySWR4ID0gMDsgY2xvc2VySWR4IDwgbWF4MjsgY2xvc2VySWR4KyspIHtcbiAgICAgICAgY2xvc2VyID0gZGVsaW1pdGVyc1tjbG9zZXJJZHhdO1xuICAgICAgICBqdW1wcy5wdXNoKDApO1xuICAgICAgICBpZiAoZGVsaW1pdGVyc1toZWFkZXJJZHhdLm1hcmtlciAhPT0gY2xvc2VyLm1hcmtlciB8fCBsYXN0VG9rZW5JZHggIT09IGNsb3Nlci50b2tlbiAtIDEpIHtcbiAgICAgICAgICBoZWFkZXJJZHggPSBjbG9zZXJJZHg7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFRva2VuSWR4ID0gY2xvc2VyLnRva2VuO1xuICAgICAgICBjbG9zZXIubGVuZ3RoID0gY2xvc2VyLmxlbmd0aCB8fCAwO1xuICAgICAgICBpZiAoIWNsb3Nlci5jbG9zZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFvcGVuZXJzQm90dG9tLmhhc093blByb3BlcnR5KGNsb3Nlci5tYXJrZXIpKSB7XG4gICAgICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXIubWFya2VyXSA9IFstMSwgLTEsIC0xLCAtMSwgLTEsIC0xXTtcbiAgICAgICAgfVxuICAgICAgICBtaW5PcGVuZXJJZHggPSBvcGVuZXJzQm90dG9tW2Nsb3Nlci5tYXJrZXJdWyhjbG9zZXIub3BlbiA/IDMgOiAwKSArIGNsb3Nlci5sZW5ndGggJSAzXTtcbiAgICAgICAgb3BlbmVySWR4ID0gaGVhZGVySWR4IC0ganVtcHNbaGVhZGVySWR4XSAtIDE7XG4gICAgICAgIG5ld01pbk9wZW5lcklkeCA9IG9wZW5lcklkeDtcbiAgICAgICAgZm9yICg7IG9wZW5lcklkeCA+IG1pbk9wZW5lcklkeDsgb3BlbmVySWR4IC09IGp1bXBzW29wZW5lcklkeF0gKyAxKSB7XG4gICAgICAgICAgb3BlbmVyID0gZGVsaW1pdGVyc1tvcGVuZXJJZHhdO1xuICAgICAgICAgIGlmIChvcGVuZXIubWFya2VyICE9PSBjbG9zZXIubWFya2VyKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgaWYgKG9wZW5lci5vcGVuICYmIG9wZW5lci5lbmQgPCAwKSB7XG4gICAgICAgICAgICBpc09kZE1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAob3BlbmVyLmNsb3NlIHx8IGNsb3Nlci5vcGVuKSB7XG4gICAgICAgICAgICAgIGlmICgob3BlbmVyLmxlbmd0aCArIGNsb3Nlci5sZW5ndGgpICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChvcGVuZXIubGVuZ3RoICUgMyAhPT0gMCB8fCBjbG9zZXIubGVuZ3RoICUgMyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgaXNPZGRNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzT2RkTWF0Y2gpIHtcbiAgICAgICAgICAgICAgbGFzdEp1bXAgPSBvcGVuZXJJZHggPiAwICYmICFkZWxpbWl0ZXJzW29wZW5lcklkeCAtIDFdLm9wZW4gPyBqdW1wc1tvcGVuZXJJZHggLSAxXSArIDEgOiAwO1xuICAgICAgICAgICAgICBqdW1wc1tjbG9zZXJJZHhdID0gY2xvc2VySWR4IC0gb3BlbmVySWR4ICsgbGFzdEp1bXA7XG4gICAgICAgICAgICAgIGp1bXBzW29wZW5lcklkeF0gPSBsYXN0SnVtcDtcbiAgICAgICAgICAgICAgY2xvc2VyLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgb3BlbmVyLmVuZCA9IGNsb3NlcklkeDtcbiAgICAgICAgICAgICAgb3BlbmVyLmNsb3NlID0gZmFsc2U7XG4gICAgICAgICAgICAgIG5ld01pbk9wZW5lcklkeCA9IC0xO1xuICAgICAgICAgICAgICBsYXN0VG9rZW5JZHggPSAtMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdNaW5PcGVuZXJJZHggIT09IC0xKSB7XG4gICAgICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXIubWFya2VyXVsoY2xvc2VyLm9wZW4gPyAzIDogMCkgKyAoY2xvc2VyLmxlbmd0aCB8fCAwKSAlIDNdID0gbmV3TWluT3BlbmVySWR4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua19wYWlycyhzdGF0ZSkge1xuICAgICAgdmFyIGN1cnIsIHRva2Vuc19tZXRhID0gc3RhdGUudG9rZW5zX21ldGEsIG1heDIgPSBzdGF0ZS50b2tlbnNfbWV0YS5sZW5ndGg7XG4gICAgICBwcm9jZXNzRGVsaW1pdGVycyhzdGF0ZSwgc3RhdGUuZGVsaW1pdGVycyk7XG4gICAgICBmb3IgKGN1cnIgPSAwOyBjdXJyIDwgbWF4MjsgY3VycisrKSB7XG4gICAgICAgIGlmICh0b2tlbnNfbWV0YVtjdXJyXSAmJiB0b2tlbnNfbWV0YVtjdXJyXS5kZWxpbWl0ZXJzKSB7XG4gICAgICAgICAgcHJvY2Vzc0RlbGltaXRlcnMoc3RhdGUsIHRva2Vuc19tZXRhW2N1cnJdLmRlbGltaXRlcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UuanNcbnZhciByZXF1aXJlX3RleHRfY29sbGFwc2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0X2NvbGxhcHNlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0X2NvbGxhcHNlKHN0YXRlKSB7XG4gICAgICB2YXIgY3VyciwgbGFzdCwgbGV2ZWwgPSAwLCB0b2tlbnMgPSBzdGF0ZS50b2tlbnMsIG1heDIgPSBzdGF0ZS50b2tlbnMubGVuZ3RoO1xuICAgICAgZm9yIChjdXJyID0gbGFzdCA9IDA7IGN1cnIgPCBtYXgyOyBjdXJyKyspIHtcbiAgICAgICAgaWYgKHRva2Vuc1tjdXJyXS5uZXN0aW5nIDwgMClcbiAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICB0b2tlbnNbY3Vycl0ubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgaWYgKHRva2Vuc1tjdXJyXS5uZXN0aW5nID4gMClcbiAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICBpZiAodG9rZW5zW2N1cnJdLnR5cGUgPT09IFwidGV4dFwiICYmIGN1cnIgKyAxIDwgbWF4MiAmJiB0b2tlbnNbY3VyciArIDFdLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50ID0gdG9rZW5zW2N1cnJdLmNvbnRlbnQgKyB0b2tlbnNbY3VyciArIDFdLmNvbnRlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGN1cnIgIT09IGxhc3QpIHtcbiAgICAgICAgICAgIHRva2Vuc1tsYXN0XSA9IHRva2Vuc1tjdXJyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VyciAhPT0gbGFzdCkge1xuICAgICAgICB0b2tlbnMubGVuZ3RoID0gbGFzdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lLmpzXG52YXIgcmVxdWlyZV9zdGF0ZV9pbmxpbmUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgVG9rZW4gPSByZXF1aXJlX3Rva2VuKCk7XG4gICAgdmFyIGlzV2hpdGVTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1doaXRlU3BhY2U7XG4gICAgdmFyIGlzUHVuY3RDaGFyID0gcmVxdWlyZV91dGlscygpLmlzUHVuY3RDaGFyO1xuICAgIHZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmVfdXRpbHMoKS5pc01kQXNjaWlQdW5jdDtcbiAgICBmdW5jdGlvbiBTdGF0ZUlubGluZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgICB0aGlzLmVudiA9IGVudjtcbiAgICAgIHRoaXMubWQgPSBtZDtcbiAgICAgIHRoaXMudG9rZW5zID0gb3V0VG9rZW5zO1xuICAgICAgdGhpcy50b2tlbnNfbWV0YSA9IEFycmF5KG91dFRva2Vucy5sZW5ndGgpO1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgdGhpcy5wb3NNYXggPSB0aGlzLnNyYy5sZW5ndGg7XG4gICAgICB0aGlzLmxldmVsID0gMDtcbiAgICAgIHRoaXMucGVuZGluZyA9IFwiXCI7XG4gICAgICB0aGlzLnBlbmRpbmdMZXZlbCA9IDA7XG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICB0aGlzLmRlbGltaXRlcnMgPSBbXTtcbiAgICAgIHRoaXMuX3ByZXZfZGVsaW1pdGVycyA9IFtdO1xuICAgICAgdGhpcy5iYWNrdGlja3MgPSB7fTtcbiAgICAgIHRoaXMuYmFja3RpY2tzU2Nhbm5lZCA9IGZhbHNlO1xuICAgIH1cbiAgICBTdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaFBlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbiA9IG5ldyBUb2tlbihcInRleHRcIiwgXCJcIiwgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdGhpcy5wZW5kaW5nO1xuICAgICAgdG9rZW4ubGV2ZWwgPSB0aGlzLnBlbmRpbmdMZXZlbDtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgdGhpcy5wZW5kaW5nID0gXCJcIjtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9O1xuICAgIFN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24odHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nKSB7XG4gICAgICAgIHRoaXMucHVzaFBlbmRpbmcoKTtcbiAgICAgIH1cbiAgICAgIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpO1xuICAgICAgdmFyIHRva2VuX21ldGEgPSBudWxsO1xuICAgICAgaWYgKG5lc3RpbmcgPCAwKSB7XG4gICAgICAgIHRoaXMubGV2ZWwtLTtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gdGhpcy5fcHJldl9kZWxpbWl0ZXJzLnBvcCgpO1xuICAgICAgfVxuICAgICAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgaWYgKG5lc3RpbmcgPiAwKSB7XG4gICAgICAgIHRoaXMubGV2ZWwrKztcbiAgICAgICAgdGhpcy5fcHJldl9kZWxpbWl0ZXJzLnB1c2godGhpcy5kZWxpbWl0ZXJzKTtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gW107XG4gICAgICAgIHRva2VuX21ldGEgPSB7IGRlbGltaXRlcnM6IHRoaXMuZGVsaW1pdGVycyB9O1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nTGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB0aGlzLnRva2Vuc19tZXRhLnB1c2godG9rZW5fbWV0YSk7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbiAgICBTdGF0ZUlubGluZS5wcm90b3R5cGUuc2NhbkRlbGltcyA9IGZ1bmN0aW9uKHN0YXJ0LCBjYW5TcGxpdFdvcmQpIHtcbiAgICAgIHZhciBwb3MgPSBzdGFydCwgbGFzdENoYXIsIG5leHRDaGFyLCBjb3VudCwgY2FuX29wZW4sIGNhbl9jbG9zZSwgaXNMYXN0V2hpdGVTcGFjZSwgaXNMYXN0UHVuY3RDaGFyLCBpc05leHRXaGl0ZVNwYWNlLCBpc05leHRQdW5jdENoYXIsIGxlZnRfZmxhbmtpbmcgPSB0cnVlLCByaWdodF9mbGFua2luZyA9IHRydWUsIG1heDIgPSB0aGlzLnBvc01heCwgbWFya2VyID0gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCk7XG4gICAgICBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IDMyO1xuICAgICAgd2hpbGUgKHBvcyA8IG1heDIgJiYgdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpID09PSBtYXJrZXIpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICB9XG4gICAgICBjb3VudCA9IHBvcyAtIHN0YXJ0O1xuICAgICAgbmV4dENoYXIgPSBwb3MgPCBtYXgyID8gdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpIDogMzI7XG4gICAgICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xuICAgICAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICAgICAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG4gICAgICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xuICAgICAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTmV4dFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgICAgIHJpZ2h0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNhblNwbGl0V29yZCkge1xuICAgICAgICBjYW5fb3BlbiA9IGxlZnRfZmxhbmtpbmcgJiYgKCFyaWdodF9mbGFua2luZyB8fCBpc0xhc3RQdW5jdENoYXIpO1xuICAgICAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZyAmJiAoIWxlZnRfZmxhbmtpbmcgfHwgaXNOZXh0UHVuY3RDaGFyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbl9vcGVuID0gbGVmdF9mbGFua2luZztcbiAgICAgICAgY2FuX2Nsb3NlID0gcmlnaHRfZmxhbmtpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW5fb3BlbixcbiAgICAgICAgY2FuX2Nsb3NlLFxuICAgICAgICBsZW5ndGg6IGNvdW50XG4gICAgICB9O1xuICAgIH07XG4gICAgU3RhdGVJbmxpbmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUlubGluZTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2lubGluZS5qc1xudmFyIHJlcXVpcmVfcGFyc2VyX2lubGluZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2lubGluZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBSdWxlciA9IHJlcXVpcmVfcnVsZXIoKTtcbiAgICB2YXIgX3J1bGVzID0gW1xuICAgICAgW1widGV4dFwiLCByZXF1aXJlX3RleHQoKV0sXG4gICAgICBbXCJuZXdsaW5lXCIsIHJlcXVpcmVfbmV3bGluZSgpXSxcbiAgICAgIFtcImVzY2FwZVwiLCByZXF1aXJlX2VzY2FwZSgpXSxcbiAgICAgIFtcImJhY2t0aWNrc1wiLCByZXF1aXJlX2JhY2t0aWNrcygpXSxcbiAgICAgIFtcInN0cmlrZXRocm91Z2hcIiwgcmVxdWlyZV9zdHJpa2V0aHJvdWdoKCkudG9rZW5pemVdLFxuICAgICAgW1wiZW1waGFzaXNcIiwgcmVxdWlyZV9lbXBoYXNpcygpLnRva2VuaXplXSxcbiAgICAgIFtcImxpbmtcIiwgcmVxdWlyZV9saW5rKCldLFxuICAgICAgW1wiaW1hZ2VcIiwgcmVxdWlyZV9pbWFnZSgpXSxcbiAgICAgIFtcImF1dG9saW5rXCIsIHJlcXVpcmVfYXV0b2xpbmsoKV0sXG4gICAgICBbXCJodG1sX2lubGluZVwiLCByZXF1aXJlX2h0bWxfaW5saW5lKCldLFxuICAgICAgW1wiZW50aXR5XCIsIHJlcXVpcmVfZW50aXR5KCldXG4gICAgXTtcbiAgICB2YXIgX3J1bGVzMiA9IFtcbiAgICAgIFtcImJhbGFuY2VfcGFpcnNcIiwgcmVxdWlyZV9iYWxhbmNlX3BhaXJzKCldLFxuICAgICAgW1wic3RyaWtldGhyb3VnaFwiLCByZXF1aXJlX3N0cmlrZXRocm91Z2goKS5wb3N0UHJvY2Vzc10sXG4gICAgICBbXCJlbXBoYXNpc1wiLCByZXF1aXJlX2VtcGhhc2lzKCkucG9zdFByb2Nlc3NdLFxuICAgICAgW1widGV4dF9jb2xsYXBzZVwiLCByZXF1aXJlX3RleHRfY29sbGFwc2UoKV1cbiAgICBdO1xuICAgIGZ1bmN0aW9uIFBhcnNlcklubGluZSgpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5ydWxlcjIgPSBuZXcgUnVsZXIoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucnVsZXIyLnB1c2goX3J1bGVzMltpXVswXSwgX3J1bGVzMltpXVsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIFBhcnNlcklubGluZS5wcm90b3R5cGUuc2tpcFRva2VuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBvaywgaSwgcG9zID0gc3RhdGUucG9zLCBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoXCJcIiksIGxlbiA9IHJ1bGVzLmxlbmd0aCwgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZywgY2FjaGUgPSBzdGF0ZS5jYWNoZTtcbiAgICAgIGlmICh0eXBlb2YgY2FjaGVbcG9zXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzdGF0ZS5wb3MgPSBjYWNoZVtwb3NdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUubGV2ZWwgPCBtYXhOZXN0aW5nKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHN0YXRlLmxldmVsKys7XG4gICAgICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgdHJ1ZSk7XG4gICAgICAgICAgc3RhdGUubGV2ZWwtLTtcbiAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucG9zID0gc3RhdGUucG9zTWF4O1xuICAgICAgfVxuICAgICAgaWYgKCFvaykge1xuICAgICAgICBzdGF0ZS5wb3MrKztcbiAgICAgIH1cbiAgICAgIGNhY2hlW3Bvc10gPSBzdGF0ZS5wb3M7XG4gICAgfTtcbiAgICBQYXJzZXJJbmxpbmUucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBvaywgaSwgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKFwiXCIpLCBsZW4gPSBydWxlcy5sZW5ndGgsIGVuZCA9IHN0YXRlLnBvc01heCwgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZztcbiAgICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBpZiAoc3RhdGUucG9zID49IGVuZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3N0YXRlLnBvcysrXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5wZW5kaW5nKSB7XG4gICAgICAgIHN0YXRlLnB1c2hQZW5kaW5nKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBQYXJzZXJJbmxpbmUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgICAgIHZhciBpLCBydWxlcywgbGVuO1xuICAgICAgdmFyIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuICAgICAgdGhpcy50b2tlbml6ZShzdGF0ZSk7XG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIyLmdldFJ1bGVzKFwiXCIpO1xuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlcklubGluZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlX3N0YXRlX2lubGluZSgpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gUGFyc2VySW5saW5lO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvbGliL3JlLmpzXG52YXIgcmVxdWlyZV9yZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9saW5raWZ5LWl0L2xpYi9yZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgdmFyIHJlID0ge307XG4gICAgICByZS5zcmNfQW55ID0gcmVxdWlyZV9yZWdleDIoKS5zb3VyY2U7XG4gICAgICByZS5zcmNfQ2MgPSByZXF1aXJlX3JlZ2V4MygpLnNvdXJjZTtcbiAgICAgIHJlLnNyY19aID0gcmVxdWlyZV9yZWdleDUoKS5zb3VyY2U7XG4gICAgICByZS5zcmNfUCA9IHJlcXVpcmVfcmVnZXgoKS5zb3VyY2U7XG4gICAgICByZS5zcmNfWlBDYyA9IFtyZS5zcmNfWiwgcmUuc3JjX1AsIHJlLnNyY19DY10uam9pbihcInxcIik7XG4gICAgICByZS5zcmNfWkNjID0gW3JlLnNyY19aLCByZS5zcmNfQ2NdLmpvaW4oXCJ8XCIpO1xuICAgICAgdmFyIHRleHRfc2VwYXJhdG9ycyA9IFwiWz48XFx1RkY1Q11cIjtcbiAgICAgIHJlLnNyY19wc2V1ZG9fbGV0dGVyID0gXCIoPzooPyFcIiArIHRleHRfc2VwYXJhdG9ycyArIFwifFwiICsgcmUuc3JjX1pQQ2MgKyBcIilcIiArIHJlLnNyY19BbnkgKyBcIilcIjtcbiAgICAgIHJlLnNyY19pcDQgPSBcIig/OigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFxcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcIjtcbiAgICAgIHJlLnNyY19hdXRoID0gXCIoPzooPzooPyFcIiArIHJlLnNyY19aQ2MgKyBcInxbQC9cXFxcW1xcXFxdKCldKS4pK0ApP1wiO1xuICAgICAgcmUuc3JjX3BvcnQgPSBcIig/OjooPzo2KD86WzAtNF1cXFxcZHszfXw1KD86WzAtNF1cXFxcZHsyfXw1KD86WzAtMl1cXFxcZHwzWzAtNV0pKSl8WzEtNV0/XFxcXGR7MSw0fSkpP1wiO1xuICAgICAgcmUuc3JjX2hvc3RfdGVybWluYXRvciA9IFwiKD89JHxcIiArIHRleHRfc2VwYXJhdG9ycyArIFwifFwiICsgcmUuc3JjX1pQQ2MgKyBcIikoPyEtfF98OlxcXFxkfFxcXFwuLXxcXFxcLig/ISR8XCIgKyByZS5zcmNfWlBDYyArIFwiKSlcIjtcbiAgICAgIHJlLnNyY19wYXRoID0gXCIoPzpbLz8jXSg/Oig/IVwiICsgcmUuc3JjX1pDYyArIFwifFwiICsgdGV4dF9zZXBhcmF0b3JzICsgYHxbKClbXFxcXF17fS4sXCInPyFcXFxcLTtdKS58XFxcXFsoPzooPyFgICsgcmUuc3JjX1pDYyArIFwifFxcXFxdKS4pKlxcXFxdfFxcXFwoKD86KD8hXCIgKyByZS5zcmNfWkNjICsgXCJ8WyldKS4pKlxcXFwpfFxcXFx7KD86KD8hXCIgKyByZS5zcmNfWkNjICsgJ3xbfV0pLikqXFxcXH18XFxcXFwiKD86KD8hJyArIHJlLnNyY19aQ2MgKyBgfFtcIl0pLikrXFxcXFwifFxcXFwnKD86KD8hYCArIHJlLnNyY19aQ2MgKyBcInxbJ10pLikrXFxcXCd8XFxcXCcoPz1cIiArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgXCJ8Wy1dKS58XFxcXC57Mix9W2EtekEtWjAtOSUvJl18XFxcXC4oPyFcIiArIHJlLnNyY19aQ2MgKyBcInxbLl0pLnxcIiArIChvcHRzICYmIG9wdHNbXCItLS1cIl0gPyBcIlxcXFwtKD8hLS0oPzpbXi1dfCQpKSg/Oi0qKXxcIiA6IFwiXFxcXC0rfFwiKSArIFwiLCg/IVwiICsgcmUuc3JjX1pDYyArIFwiKS58Oyg/IVwiICsgcmUuc3JjX1pDYyArIFwiKS58XFxcXCErKD8hXCIgKyByZS5zcmNfWkNjICsgXCJ8WyFdKS58XFxcXD8oPyFcIiArIHJlLnNyY19aQ2MgKyBcInxbP10pLikrfFxcXFwvKT9cIjtcbiAgICAgIHJlLnNyY19lbWFpbF9uYW1lID0gJ1tcXFxcLTs6Jj1cXFxcK1xcXFwkLFxcXFwuYS16QS1aMC05X11bXFxcXC07OiY9XFxcXCtcXFxcJCxcXFxcXCJcXFxcLmEtekEtWjAtOV9dKic7XG4gICAgICByZS5zcmNfeG4gPSBcInhuLS1bYS16MC05XFxcXC1dezEsNTl9XCI7XG4gICAgICByZS5zcmNfZG9tYWluX3Jvb3QgPSBcIig/OlwiICsgcmUuc3JjX3huICsgXCJ8XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArIFwiezEsNjN9KVwiO1xuICAgICAgcmUuc3JjX2RvbWFpbiA9IFwiKD86XCIgKyByZS5zcmNfeG4gKyBcInwoPzpcIiArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgXCIpfCg/OlwiICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyBcIig/Oi18XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArIFwiKXswLDYxfVwiICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyBcIikpXCI7XG4gICAgICByZS5zcmNfaG9zdCA9IFwiKD86KD86KD86KD86XCIgKyByZS5zcmNfZG9tYWluICsgXCIpXFxcXC4pKlwiICsgcmUuc3JjX2RvbWFpbiArIFwiKSlcIjtcbiAgICAgIHJlLnRwbF9ob3N0X2Z1enp5ID0gXCIoPzpcIiArIHJlLnNyY19pcDQgKyBcInwoPzooPzooPzpcIiArIHJlLnNyY19kb21haW4gKyBcIilcXFxcLikrKD86JVRMRFMlKSkpXCI7XG4gICAgICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSA9IFwiKD86KD86KD86XCIgKyByZS5zcmNfZG9tYWluICsgXCIpXFxcXC4pKyg/OiVUTERTJSkpXCI7XG4gICAgICByZS5zcmNfaG9zdF9zdHJpY3QgPSByZS5zcmNfaG9zdCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG4gICAgICByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgPSByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG4gICAgICByZS5zcmNfaG9zdF9wb3J0X3N0cmljdCA9IHJlLnNyY19ob3N0ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuICAgICAgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgPSByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcbiAgICAgIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ID0gcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG4gICAgICByZS50cGxfaG9zdF9mdXp6eV90ZXN0ID0gXCJsb2NhbGhvc3R8d3d3XFxcXC58XFxcXC5cXFxcZHsxLDN9XFxcXC58KD86XFxcXC4oPzolVExEUyUpKD86XCIgKyByZS5zcmNfWlBDYyArIFwifD58JCkpXCI7XG4gICAgICByZS50cGxfZW1haWxfZnV6enkgPSBcIihefFwiICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xcInxcXFxcKHwnICsgcmUuc3JjX1pDYyArIFwiKShcIiArIHJlLnNyY19lbWFpbF9uYW1lICsgXCJAXCIgKyByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgKyBcIilcIjtcbiAgICAgIHJlLnRwbF9saW5rX2Z1enp5ID0gXCIoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1RkY1Q118XCIgKyByZS5zcmNfWlBDYyArIFwiKSkoKD8hWyQrPD0+XmB8XFx1RkY1Q10pXCIgKyByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgXCIpXCI7XG4gICAgICByZS50cGxfbGlua19ub19pcF9mdXp6eSA9IFwiKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdUZGNUNdfFwiICsgcmUuc3JjX1pQQ2MgKyBcIikpKCg/IVskKzw9Pl5gfFxcdUZGNUNdKVwiICsgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArIFwiKVwiO1xuICAgICAgcmV0dXJuIHJlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbGlua2lmeS1pdC9pbmRleC5qc1xudmFyIHJlcXVpcmVfbGlua2lmeV9pdCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9saW5raWZ5LWl0L2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gYXNzaWduKG9iaikge1xuICAgICAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9jbGFzcyhvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgICByZXR1cm4gX2NsYXNzKG9iaikgPT09IFwiW29iamVjdCBTdHJpbmddXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgICAgcmV0dXJuIF9jbGFzcyhvYmopID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICAgIHJldHVybiBfY2xhc3Mob2JqKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbjIob2JqKSB7XG4gICAgICByZXR1cm4gX2NsYXNzKG9iaikgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgXCJcXFxcJCZcIik7XG4gICAgfVxuICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGZ1enp5TGluazogdHJ1ZSxcbiAgICAgIGZ1enp5RW1haWw6IHRydWUsXG4gICAgICBmdXp6eUlQOiBmYWxzZVxuICAgIH07XG4gICAgZnVuY3Rpb24gaXNPcHRpb25zT2JqKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaiB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uKGFjYywgaykge1xuICAgICAgICByZXR1cm4gYWNjIHx8IGRlZmF1bHRPcHRpb25zLmhhc093blByb3BlcnR5KGspO1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cbiAgICB2YXIgZGVmYXVsdFNjaGVtYXMgPSB7XG4gICAgICBcImh0dHA6XCI6IHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKHRleHQyLCBwb3MsIHNlbGYpIHtcbiAgICAgICAgICB2YXIgdGFpbCA9IHRleHQyLnNsaWNlKHBvcyk7XG4gICAgICAgICAgaWYgKCFzZWxmLnJlLmh0dHApIHtcbiAgICAgICAgICAgIHNlbGYucmUuaHR0cCA9IG5ldyBSZWdFeHAoXCJeXFxcXC9cXFxcL1wiICsgc2VsZi5yZS5zcmNfYXV0aCArIHNlbGYucmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgKyBzZWxmLnJlLnNyY19wYXRoLCBcImlcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxmLnJlLmh0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5odHRwKVswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJodHRwczpcIjogXCJodHRwOlwiLFxuICAgICAgXCJmdHA6XCI6IFwiaHR0cDpcIixcbiAgICAgIFwiLy9cIjoge1xuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24odGV4dDIsIHBvcywgc2VsZikge1xuICAgICAgICAgIHZhciB0YWlsID0gdGV4dDIuc2xpY2UocG9zKTtcbiAgICAgICAgICBpZiAoIXNlbGYucmUubm9faHR0cCkge1xuICAgICAgICAgICAgc2VsZi5yZS5ub19odHRwID0gbmV3IFJlZ0V4cChcIl5cIiArIHNlbGYucmUuc3JjX2F1dGggKyBcIig/OmxvY2FsaG9zdHwoPzooPzpcIiArIHNlbGYucmUuc3JjX2RvbWFpbiArIFwiKVxcXFwuKStcIiArIHNlbGYucmUuc3JjX2RvbWFpbl9yb290ICsgXCIpXCIgKyBzZWxmLnJlLnNyY19wb3J0ICsgc2VsZi5yZS5zcmNfaG9zdF90ZXJtaW5hdG9yICsgc2VsZi5yZS5zcmNfcGF0aCwgXCJpXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VsZi5yZS5ub19odHRwLnRlc3QodGFpbCkpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gMyAmJiB0ZXh0Mltwb3MgLSAzXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dDJbcG9zIC0gM10gPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5ub19odHRwKVswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJtYWlsdG86XCI6IHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKHRleHQyLCBwb3MsIHNlbGYpIHtcbiAgICAgICAgICB2YXIgdGFpbCA9IHRleHQyLnNsaWNlKHBvcyk7XG4gICAgICAgICAgaWYgKCFzZWxmLnJlLm1haWx0bykge1xuICAgICAgICAgICAgc2VsZi5yZS5tYWlsdG8gPSBuZXcgUmVnRXhwKFwiXlwiICsgc2VsZi5yZS5zcmNfZW1haWxfbmFtZSArIFwiQFwiICsgc2VsZi5yZS5zcmNfaG9zdF9zdHJpY3QsIFwiaVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGYucmUubWFpbHRvLnRlc3QodGFpbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubWFpbHRvKVswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgdGxkc18yY2hfc3JjX3JlID0gXCJhW2NkZWZnaWxtbm9xcnN0dXd4el18YlthYmRlZmdoaWptbm9yc3R2d3l6XXxjW2FjZGZnaGlrbG1ub3J1dnd4eXpdfGRbZWprbW96XXxlW2NlZ3JzdHVdfGZbaWprbW9yXXxnW2FiZGVmZ2hpbG1ucHFyc3R1d3ldfGhba21ucnR1XXxpW2RlbG1ub3Fyc3RdfGpbZW1vcF18a1tlZ2hpbW5wcnd5el18bFthYmNpa3JzdHV2eV18bVthY2RlZ2hrbG1ub3BxcnN0dXZ3eHl6XXxuW2FjZWZnaWxvcHJ1el18b218cFthZWZnaGtsbW5yc3R3eV18cWF8cltlb3N1d118c1thYmNkZWdoaWprbG1ub3J0dXZ4eXpdfHRbY2RmZ2hqa2xtbm9ydHZ3el18dVthZ2tzeXpdfHZbYWNlZ2ludV18d1tmc118eVtldF18elthbXddXCI7XG4gICAgdmFyIHRsZHNfZGVmYXVsdCA9IFwiYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfFxcdTA0NDBcXHUwNDQ0XCIuc3BsaXQoXCJ8XCIpO1xuICAgIGZ1bmN0aW9uIHJlc2V0U2NhbkNhY2hlKHNlbGYpIHtcbiAgICAgIHNlbGYuX19pbmRleF9fID0gLTE7XG4gICAgICBzZWxmLl9fdGV4dF9jYWNoZV9fID0gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVmFsaWRhdG9yKHJlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odGV4dDIsIHBvcykge1xuICAgICAgICB2YXIgdGFpbCA9IHRleHQyLnNsaWNlKHBvcyk7XG4gICAgICAgIGlmIChyZS50ZXN0KHRhaWwpKSB7XG4gICAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2gocmUpWzBdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vcm1hbGl6ZXIoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24obWF0Y2gsIHNlbGYpIHtcbiAgICAgICAgc2VsZi5ub3JtYWxpemUobWF0Y2gpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGlsZShzZWxmKSB7XG4gICAgICB2YXIgcmUgPSBzZWxmLnJlID0gcmVxdWlyZV9yZSgpKHNlbGYuX19vcHRzX18pO1xuICAgICAgdmFyIHRsZHMgPSBzZWxmLl9fdGxkc19fLnNsaWNlKCk7XG4gICAgICBzZWxmLm9uQ29tcGlsZSgpO1xuICAgICAgaWYgKCFzZWxmLl9fdGxkc19yZXBsYWNlZF9fKSB7XG4gICAgICAgIHRsZHMucHVzaCh0bGRzXzJjaF9zcmNfcmUpO1xuICAgICAgfVxuICAgICAgdGxkcy5wdXNoKHJlLnNyY194bik7XG4gICAgICByZS5zcmNfdGxkcyA9IHRsZHMuam9pbihcInxcIik7XG4gICAgICBmdW5jdGlvbiB1bnRwbCh0cGwpIHtcbiAgICAgICAgcmV0dXJuIHRwbC5yZXBsYWNlKFwiJVRMRFMlXCIsIHJlLnNyY190bGRzKTtcbiAgICAgIH1cbiAgICAgIHJlLmVtYWlsX2Z1enp5ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9lbWFpbF9mdXp6eSksIFwiaVwiKTtcbiAgICAgIHJlLmxpbmtfZnV6enkgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfZnV6enkpLCBcImlcIik7XG4gICAgICByZS5saW5rX25vX2lwX2Z1enp5ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX25vX2lwX2Z1enp5KSwgXCJpXCIpO1xuICAgICAgcmUuaG9zdF9mdXp6eV90ZXN0ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QpLCBcImlcIik7XG4gICAgICB2YXIgYWxpYXNlcyA9IFtdO1xuICAgICAgc2VsZi5fX2NvbXBpbGVkX18gPSB7fTtcbiAgICAgIGZ1bmN0aW9uIHNjaGVtYUVycm9yKG5hbWUsIHZhbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyhMaW5raWZ5SXQpIEludmFsaWQgc2NoZW1hIFwiJyArIG5hbWUgKyAnXCI6ICcgKyB2YWwpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMoc2VsZi5fX3NjaGVtYXNfXykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciB2YWwgPSBzZWxmLl9fc2NoZW1hc19fW25hbWVdO1xuICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21waWxlZCA9IHsgdmFsaWRhdGU6IG51bGwsIGxpbms6IG51bGwgfTtcbiAgICAgICAgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV0gPSBjb21waWxlZDtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICBpZiAoaXNSZWdFeHAodmFsLnZhbGlkYXRlKSkge1xuICAgICAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0b3IodmFsLnZhbGlkYXRlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24yKHZhbC52YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gdmFsLnZhbGlkYXRlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbjIodmFsLm5vcm1hbGl6ZSkpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IHZhbC5ub3JtYWxpemU7XG4gICAgICAgICAgfSBlbHNlIGlmICghdmFsLm5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gY3JlYXRlTm9ybWFsaXplcigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgICBhbGlhc2VzLnB1c2gobmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9KTtcbiAgICAgIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbihhbGlhcykge1xuICAgICAgICBpZiAoIXNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10udmFsaWRhdGUgPSBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0udmFsaWRhdGU7XG4gICAgICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS5ub3JtYWxpemUgPSBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0ubm9ybWFsaXplO1xuICAgICAgfSk7XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tcIlwiXSA9IHsgdmFsaWRhdGU6IG51bGwsIG5vcm1hbGl6ZTogY3JlYXRlTm9ybWFsaXplcigpIH07XG4gICAgICB2YXIgc2xpc3QgPSBPYmplY3Qua2V5cyhzZWxmLl9fY29tcGlsZWRfXykuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUubGVuZ3RoID4gMCAmJiBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXTtcbiAgICAgIH0pLm1hcChlc2NhcGVSRSkuam9pbihcInxcIik7XG4gICAgICBzZWxmLnJlLnNjaGVtYV90ZXN0ID0gUmVnRXhwKFwiKF58KD8hXykoPzpbPjxcXHVGRjVDXXxcIiArIHJlLnNyY19aUENjICsgXCIpKShcIiArIHNsaXN0ICsgXCIpXCIsIFwiaVwiKTtcbiAgICAgIHNlbGYucmUuc2NoZW1hX3NlYXJjaCA9IFJlZ0V4cChcIihefCg/IV8pKD86Wz48XFx1RkY1Q118XCIgKyByZS5zcmNfWlBDYyArIFwiKSkoXCIgKyBzbGlzdCArIFwiKVwiLCBcImlnXCIpO1xuICAgICAgc2VsZi5yZS5wcmV0ZXN0ID0gUmVnRXhwKFwiKFwiICsgc2VsZi5yZS5zY2hlbWFfdGVzdC5zb3VyY2UgKyBcIil8KFwiICsgc2VsZi5yZS5ob3N0X2Z1enp5X3Rlc3Quc291cmNlICsgXCIpfEBcIiwgXCJpXCIpO1xuICAgICAgcmVzZXRTY2FuQ2FjaGUoc2VsZik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gICAgICB2YXIgc3RhcnQgPSBzZWxmLl9faW5kZXhfXywgZW5kID0gc2VsZi5fX2xhc3RfaW5kZXhfXywgdGV4dDIgPSBzZWxmLl9fdGV4dF9jYWNoZV9fLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgdGhpcy5zY2hlbWEgPSBzZWxmLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMuaW5kZXggPSBzdGFydCArIHNoaWZ0O1xuICAgICAgdGhpcy5sYXN0SW5kZXggPSBlbmQgKyBzaGlmdDtcbiAgICAgIHRoaXMucmF3ID0gdGV4dDI7XG4gICAgICB0aGlzLnRleHQgPSB0ZXh0MjtcbiAgICAgIHRoaXMudXJsID0gdGV4dDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSBuZXcgTWF0Y2goc2VsZiwgc2hpZnQpO1xuICAgICAgc2VsZi5fX2NvbXBpbGVkX19bbWF0Y2guc2NoZW1hXS5ub3JtYWxpemUobWF0Y2gsIHNlbGYpO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucykge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpbmtpZnlJdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzT3B0aW9uc09iaihzY2hlbWFzKSkge1xuICAgICAgICAgIG9wdGlvbnMgPSBzY2hlbWFzO1xuICAgICAgICAgIHNjaGVtYXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAtMTtcbiAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSAtMTtcbiAgICAgIHRoaXMuX19zY2hlbWFfXyA9IFwiXCI7XG4gICAgICB0aGlzLl9fdGV4dF9jYWNoZV9fID0gXCJcIjtcbiAgICAgIHRoaXMuX19zY2hlbWFzX18gPSBhc3NpZ24oe30sIGRlZmF1bHRTY2hlbWFzLCBzY2hlbWFzKTtcbiAgICAgIHRoaXMuX19jb21waWxlZF9fID0ge307XG4gICAgICB0aGlzLl9fdGxkc19fID0gdGxkc19kZWZhdWx0O1xuICAgICAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyA9IGZhbHNlO1xuICAgICAgdGhpcy5yZSA9IHt9O1xuICAgICAgY29tcGlsZSh0aGlzKTtcbiAgICB9XG4gICAgTGlua2lmeUl0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoc2NoZW1hLCBkZWZpbml0aW9uKSB7XG4gICAgICB0aGlzLl9fc2NoZW1hc19fW3NjaGVtYV0gPSBkZWZpbml0aW9uO1xuICAgICAgY29tcGlsZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTGlua2lmeUl0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICAgICAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih0aGlzLl9fb3B0c19fLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdCh0ZXh0Mikge1xuICAgICAgdGhpcy5fX3RleHRfY2FjaGVfXyA9IHRleHQyO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAtMTtcbiAgICAgIGlmICghdGV4dDIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBtLCBtbCwgbWUsIGxlbiwgc2hpZnQsIG5leHQsIHJlLCB0bGRfcG9zLCBhdF9wb3M7XG4gICAgICBpZiAodGhpcy5yZS5zY2hlbWFfdGVzdC50ZXN0KHRleHQyKSkge1xuICAgICAgICByZSA9IHRoaXMucmUuc2NoZW1hX3NlYXJjaDtcbiAgICAgICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKChtID0gcmUuZXhlYyh0ZXh0MikpICE9PSBudWxsKSB7XG4gICAgICAgICAgbGVuID0gdGhpcy50ZXN0U2NoZW1hQXQodGV4dDIsIG1bMl0sIHJlLmxhc3RJbmRleCk7XG4gICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgdGhpcy5fX3NjaGVtYV9fID0gbVsyXTtcbiAgICAgICAgICAgIHRoaXMuX19pbmRleF9fID0gbS5pbmRleCArIG1bMV0ubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aCArIGxlbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlMaW5rICYmIHRoaXMuX19jb21waWxlZF9fW1wiaHR0cDpcIl0pIHtcbiAgICAgICAgdGxkX3BvcyA9IHRleHQyLnNlYXJjaCh0aGlzLnJlLmhvc3RfZnV6enlfdGVzdCk7XG4gICAgICAgIGlmICh0bGRfcG9zID49IDApIHtcbiAgICAgICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHRsZF9wb3MgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICAgICAgaWYgKChtbCA9IHRleHQyLm1hdGNoKHRoaXMuX19vcHRzX18uZnV6enlJUCA/IHRoaXMucmUubGlua19mdXp6eSA6IHRoaXMucmUubGlua19ub19pcF9mdXp6eSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHNoaWZ0ID0gbWwuaW5kZXggKyBtbFsxXS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICAgICAgICAgIHRoaXMuX19zY2hlbWFfXyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2luZGV4X18gPSBzaGlmdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbWwuaW5kZXggKyBtbFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5RW1haWwgJiYgdGhpcy5fX2NvbXBpbGVkX19bXCJtYWlsdG86XCJdKSB7XG4gICAgICAgIGF0X3BvcyA9IHRleHQyLmluZGV4T2YoXCJAXCIpO1xuICAgICAgICBpZiAoYXRfcG9zID49IDApIHtcbiAgICAgICAgICBpZiAoKG1lID0gdGV4dDIubWF0Y2godGhpcy5yZS5lbWFpbF9mdXp6eSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzaGlmdCA9IG1lLmluZGV4ICsgbWVbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG1lLmluZGV4ICsgbWVbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fIHx8IHNoaWZ0ID09PSB0aGlzLl9faW5kZXhfXyAmJiBuZXh0ID4gdGhpcy5fX2xhc3RfaW5kZXhfXykge1xuICAgICAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gPSBcIm1haWx0bzpcIjtcbiAgICAgICAgICAgICAgdGhpcy5fX2luZGV4X18gPSBzaGlmdDtcbiAgICAgICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX2luZGV4X18gPj0gMDtcbiAgICB9O1xuICAgIExpbmtpZnlJdC5wcm90b3R5cGUucHJldGVzdCA9IGZ1bmN0aW9uIHByZXRlc3QodGV4dDIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlLnByZXRlc3QudGVzdCh0ZXh0Mik7XG4gICAgfTtcbiAgICBMaW5raWZ5SXQucHJvdG90eXBlLnRlc3RTY2hlbWFBdCA9IGZ1bmN0aW9uIHRlc3RTY2hlbWFBdCh0ZXh0Miwgc2NoZW1hLCBwb3MpIHtcbiAgICAgIGlmICghdGhpcy5fX2NvbXBpbGVkX19bc2NoZW1hLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXS52YWxpZGF0ZSh0ZXh0MiwgcG9zLCB0aGlzKTtcbiAgICB9O1xuICAgIExpbmtpZnlJdC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCh0ZXh0Mikge1xuICAgICAgdmFyIHNoaWZ0ID0gMCwgcmVzdWx0ID0gW107XG4gICAgICBpZiAodGhpcy5fX2luZGV4X18gPj0gMCAmJiB0aGlzLl9fdGV4dF9jYWNoZV9fID09PSB0ZXh0Mikge1xuICAgICAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuICAgICAgICBzaGlmdCA9IHRoaXMuX19sYXN0X2luZGV4X187XG4gICAgICB9XG4gICAgICB2YXIgdGFpbCA9IHNoaWZ0ID8gdGV4dDIuc2xpY2Uoc2hpZnQpIDogdGV4dDI7XG4gICAgICB3aGlsZSAodGhpcy50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG4gICAgICAgIHRhaWwgPSB0YWlsLnNsaWNlKHRoaXMuX19sYXN0X2luZGV4X18pO1xuICAgICAgICBzaGlmdCArPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTGlua2lmeUl0LnByb3RvdHlwZS50bGRzID0gZnVuY3Rpb24gdGxkcyhsaXN0Miwga2VlcE9sZCkge1xuICAgICAgbGlzdDIgPSBBcnJheS5pc0FycmF5KGxpc3QyKSA/IGxpc3QyIDogW2xpc3QyXTtcbiAgICAgIGlmICgha2VlcE9sZCkge1xuICAgICAgICB0aGlzLl9fdGxkc19fID0gbGlzdDIuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyA9IHRydWU7XG4gICAgICAgIGNvbXBpbGUodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3RsZHNfXyA9IHRoaXMuX190bGRzX18uY29uY2F0KGxpc3QyKS5zb3J0KCkuZmlsdGVyKGZ1bmN0aW9uKGVsLCBpZHgsIGFycikge1xuICAgICAgICByZXR1cm4gZWwgIT09IGFycltpZHggLSAxXTtcbiAgICAgIH0pLnJldmVyc2UoKTtcbiAgICAgIGNvbXBpbGUodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIExpbmtpZnlJdC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG1hdGNoKSB7XG4gICAgICBpZiAoIW1hdGNoLnNjaGVtYSkge1xuICAgICAgICBtYXRjaC51cmwgPSBcImh0dHA6Ly9cIiArIG1hdGNoLnVybDtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5zY2hlbWEgPT09IFwibWFpbHRvOlwiICYmICEvXm1haWx0bzovaS50ZXN0KG1hdGNoLnVybCkpIHtcbiAgICAgICAgbWF0Y2gudXJsID0gXCJtYWlsdG86XCIgKyBtYXRjaC51cmw7XG4gICAgICB9XG4gICAgfTtcbiAgICBMaW5raWZ5SXQucHJvdG90eXBlLm9uQ29tcGlsZSA9IGZ1bmN0aW9uIG9uQ29tcGlsZSgpIHtcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gTGlua2lmeUl0O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzXG52YXIgcmVxdWlyZV9wdW55Y29kZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBtYXhJbnQgPSAyMTQ3NDgzNjQ3O1xuICAgIHZhciBiYXNlID0gMzY7XG4gICAgdmFyIHRNaW4gPSAxO1xuICAgIHZhciB0TWF4ID0gMjY7XG4gICAgdmFyIHNrZXcgPSAzODtcbiAgICB2YXIgZGFtcCA9IDcwMDtcbiAgICB2YXIgaW5pdGlhbEJpYXMgPSA3MjtcbiAgICB2YXIgaW5pdGlhbE4gPSAxMjg7XG4gICAgdmFyIGRlbGltaXRlciA9IFwiLVwiO1xuICAgIHZhciByZWdleFB1bnljb2RlID0gL154bi0tLztcbiAgICB2YXIgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHg3RV0vO1xuICAgIHZhciByZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nO1xuICAgIHZhciBlcnJvcnMgPSB7XG4gICAgICBcIm92ZXJmbG93XCI6IFwiT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3NcIixcbiAgICAgIFwibm90LWJhc2ljXCI6IFwiSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KVwiLFxuICAgICAgXCJpbnZhbGlkLWlucHV0XCI6IFwiSW52YWxpZCBpbnB1dFwiXG4gICAgfTtcbiAgICB2YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgZnVuY3Rpb24gZXJyb3IyKHR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgbGV0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gc3RyaW5nLnNwbGl0KFwiQFwiKTtcbiAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gcGFydHNbMF0gKyBcIkBcIjtcbiAgICAgICAgc3RyaW5nID0gcGFydHNbMV07XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsIFwiLlwiKTtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHN0cmluZy5zcGxpdChcIi5cIik7XG4gICAgICBjb25zdCBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oXCIuXCIpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSA1NTI5NiAmJiB2YWx1ZSA8PSA1NjMxOSAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICAgIGlmICgoZXh0cmEgJiA2NDUxMikgPT0gNTYzMjApIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKCgodmFsdWUgJiAxMDIzKSA8PCAxMCkgKyAoZXh0cmEgJiAxMDIzKSArIDY1NTM2KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIHZhciB1Y3MyZW5jb2RlID0gKGFycmF5KSA9PiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5hcnJheSk7XG4gICAgdmFyIGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xuICAgICAgaWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfTtcbiAgICB2YXIgZGlnaXRUb0Jhc2ljID0gZnVuY3Rpb24oZGlnaXQsIGZsYWcpIHtcbiAgICAgIHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG4gICAgfTtcbiAgICB2YXIgYWRhcHQgPSBmdW5jdGlvbihkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiAgICAgIGxldCBrID0gMDtcbiAgICAgIGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG4gICAgICBkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG4gICAgICBmb3IgKDsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcbiAgICAgICAgZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG4gICAgfTtcbiAgICB2YXIgZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBsZXQgbiA9IGluaXRpYWxOO1xuICAgICAgbGV0IGJpYXMgPSBpbml0aWFsQmlhcztcbiAgICAgIGxldCBiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG4gICAgICBpZiAoYmFzaWMgPCAwKSB7XG4gICAgICAgIGJhc2ljID0gMDtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAxMjgpIHtcbiAgICAgICAgICBlcnJvcjIoXCJub3QtYmFzaWNcIik7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7ICkge1xuICAgICAgICBsZXQgb2xkaSA9IGk7XG4gICAgICAgIGZvciAobGV0IHcgPSAxLCBrID0gYmFzZTsgOyBrICs9IGJhc2UpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgICAgIGVycm9yMihcImludmFsaWQtaW5wdXRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuICAgICAgICAgIGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcbiAgICAgICAgICAgIGVycm9yMihcIm92ZXJmbG93XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpICs9IGRpZ2l0ICogdztcbiAgICAgICAgICBjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG4gICAgICAgICAgaWYgKGRpZ2l0IDwgdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcbiAgICAgICAgICBpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG4gICAgICAgICAgICBlcnJvcjIoXCJvdmVyZmxvd1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdyAqPSBiYXNlTWludXNUO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuICAgICAgICBiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcbiAgICAgICAgaWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuICAgICAgICAgIGVycm9yMihcIm92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIG4gKz0gZmxvb3IoaSAvIG91dCk7XG4gICAgICAgIGkgJT0gb3V0O1xuICAgICAgICBvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4ub3V0cHV0KTtcbiAgICB9O1xuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICBpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuICAgICAgbGV0IGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgbGV0IG4gPSBpbml0aWFsTjtcbiAgICAgIGxldCBkZWx0YSA9IDA7XG4gICAgICBsZXQgYmlhcyA9IGluaXRpYWxCaWFzO1xuICAgICAgZm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IDEyOCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcbiAgICAgIGxldCBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuICAgICAgaWYgKGJhc2ljTGVuZ3RoKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuICAgICAgICBsZXQgbSA9IG1heEludDtcbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcbiAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuICAgICAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuICAgICAgICBpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuICAgICAgICAgIGVycm9yMihcIm92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG4gICAgICAgIG4gPSBtO1xuICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcbiAgICAgICAgICAgIGVycm9yMihcIm92ZXJmbG93XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09IG4pIHtcbiAgICAgICAgICAgIGxldCBxID0gZGVsdGE7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gYmFzZTsgOyBrICs9IGJhc2UpIHtcbiAgICAgICAgICAgICAgY29uc3QgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuICAgICAgICAgICAgICBpZiAocSA8IHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBxTWludXNUID0gcSAtIHQ7XG4gICAgICAgICAgICAgIGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcbiAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKSk7XG4gICAgICAgICAgICAgIHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG4gICAgICAgICAgICBiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuICAgICAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICAgICAgKytoYW5kbGVkQ1BDb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKytkZWx0YTtcbiAgICAgICAgKytuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xuICAgIH07XG4gICAgdmFyIHRvVW5pY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICByZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpID8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKSA6IHN0cmluZztcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIHRvQVNDSUkgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgcmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKSA/IFwieG4tLVwiICsgZW5jb2RlKHN0cmluZykgOiBzdHJpbmc7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBwdW55Y29kZSA9IHtcbiAgICAgIFwidmVyc2lvblwiOiBcIjIuMS4wXCIsXG4gICAgICBcInVjczJcIjoge1xuICAgICAgICBcImRlY29kZVwiOiB1Y3MyZGVjb2RlLFxuICAgICAgICBcImVuY29kZVwiOiB1Y3MyZW5jb2RlXG4gICAgICB9LFxuICAgICAgXCJkZWNvZGVcIjogZGVjb2RlLFxuICAgICAgXCJlbmNvZGVcIjogZW5jb2RlLFxuICAgICAgXCJ0b0FTQ0lJXCI6IHRvQVNDSUksXG4gICAgICBcInRvVW5pY29kZVwiOiB0b1VuaWNvZGVcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5qc1xudmFyIHJlcXVpcmVfZGVmYXVsdCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9kZWZhdWx0LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGh0bWw6IGZhbHNlLFxuICAgICAgICB4aHRtbE91dDogZmFsc2UsXG4gICAgICAgIGJyZWFrczogZmFsc2UsXG4gICAgICAgIGxhbmdQcmVmaXg6IFwibGFuZ3VhZ2UtXCIsXG4gICAgICAgIGxpbmtpZnk6IGZhbHNlLFxuICAgICAgICB0eXBvZ3JhcGhlcjogZmFsc2UsXG4gICAgICAgIHF1b3RlczogXCJcXHUyMDFDXFx1MjAxRFxcdTIwMThcXHUyMDE5XCIsXG4gICAgICAgIGhpZ2hsaWdodDogbnVsbCxcbiAgICAgICAgbWF4TmVzdGluZzogMTAwXG4gICAgICB9LFxuICAgICAgY29tcG9uZW50czoge1xuICAgICAgICBjb3JlOiB7fSxcbiAgICAgICAgYmxvY2s6IHt9LFxuICAgICAgICBpbmxpbmU6IHt9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzXG52YXIgcmVxdWlyZV96ZXJvID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL3plcm8uanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgaHRtbDogZmFsc2UsXG4gICAgICAgIHhodG1sT3V0OiBmYWxzZSxcbiAgICAgICAgYnJlYWtzOiBmYWxzZSxcbiAgICAgICAgbGFuZ1ByZWZpeDogXCJsYW5ndWFnZS1cIixcbiAgICAgICAgbGlua2lmeTogZmFsc2UsXG4gICAgICAgIHR5cG9ncmFwaGVyOiBmYWxzZSxcbiAgICAgICAgcXVvdGVzOiBcIlxcdTIwMUNcXHUyMDFEXFx1MjAxOFxcdTIwMTlcIixcbiAgICAgICAgaGlnaGxpZ2h0OiBudWxsLFxuICAgICAgICBtYXhOZXN0aW5nOiAyMFxuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgY29yZToge1xuICAgICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgICBcIm5vcm1hbGl6ZVwiLFxuICAgICAgICAgICAgXCJibG9ja1wiLFxuICAgICAgICAgICAgXCJpbmxpbmVcIlxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICBydWxlczogW1xuICAgICAgICAgICAgXCJwYXJhZ3JhcGhcIlxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgaW5saW5lOiB7XG4gICAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAgIFwidGV4dFwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBydWxlczI6IFtcbiAgICAgICAgICAgIFwiYmFsYW5jZV9wYWlyc1wiLFxuICAgICAgICAgICAgXCJ0ZXh0X2NvbGxhcHNlXCJcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanNcbnZhciByZXF1aXJlX2NvbW1vbm1hcmsgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvY29tbW9ubWFyay5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICBodG1sOiB0cnVlLFxuICAgICAgICB4aHRtbE91dDogdHJ1ZSxcbiAgICAgICAgYnJlYWtzOiBmYWxzZSxcbiAgICAgICAgbGFuZ1ByZWZpeDogXCJsYW5ndWFnZS1cIixcbiAgICAgICAgbGlua2lmeTogZmFsc2UsXG4gICAgICAgIHR5cG9ncmFwaGVyOiBmYWxzZSxcbiAgICAgICAgcXVvdGVzOiBcIlxcdTIwMUNcXHUyMDFEXFx1MjAxOFxcdTIwMTlcIixcbiAgICAgICAgaGlnaGxpZ2h0OiBudWxsLFxuICAgICAgICBtYXhOZXN0aW5nOiAyMFxuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgY29yZToge1xuICAgICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgICBcIm5vcm1hbGl6ZVwiLFxuICAgICAgICAgICAgXCJibG9ja1wiLFxuICAgICAgICAgICAgXCJpbmxpbmVcIlxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICBydWxlczogW1xuICAgICAgICAgICAgXCJibG9ja3F1b3RlXCIsXG4gICAgICAgICAgICBcImNvZGVcIixcbiAgICAgICAgICAgIFwiZmVuY2VcIixcbiAgICAgICAgICAgIFwiaGVhZGluZ1wiLFxuICAgICAgICAgICAgXCJoclwiLFxuICAgICAgICAgICAgXCJodG1sX2Jsb2NrXCIsXG4gICAgICAgICAgICBcImxoZWFkaW5nXCIsXG4gICAgICAgICAgICBcImxpc3RcIixcbiAgICAgICAgICAgIFwicmVmZXJlbmNlXCIsXG4gICAgICAgICAgICBcInBhcmFncmFwaFwiXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBpbmxpbmU6IHtcbiAgICAgICAgICBydWxlczogW1xuICAgICAgICAgICAgXCJhdXRvbGlua1wiLFxuICAgICAgICAgICAgXCJiYWNrdGlja3NcIixcbiAgICAgICAgICAgIFwiZW1waGFzaXNcIixcbiAgICAgICAgICAgIFwiZW50aXR5XCIsXG4gICAgICAgICAgICBcImVzY2FwZVwiLFxuICAgICAgICAgICAgXCJodG1sX2lubGluZVwiLFxuICAgICAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICAgICAgXCJsaW5rXCIsXG4gICAgICAgICAgICBcIm5ld2xpbmVcIixcbiAgICAgICAgICAgIFwidGV4dFwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBydWxlczI6IFtcbiAgICAgICAgICAgIFwiYmFsYW5jZV9wYWlyc1wiLFxuICAgICAgICAgICAgXCJlbXBoYXNpc1wiLFxuICAgICAgICAgICAgXCJ0ZXh0X2NvbGxhcHNlXCJcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9pbmRleC5qc1xudmFyIHJlcXVpcmVfbGliID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB1dGlscyA9IHJlcXVpcmVfdXRpbHMoKTtcbiAgICB2YXIgaGVscGVycyA9IHJlcXVpcmVfaGVscGVycygpO1xuICAgIHZhciBSZW5kZXJlciA9IHJlcXVpcmVfcmVuZGVyZXIoKTtcbiAgICB2YXIgUGFyc2VyQ29yZSA9IHJlcXVpcmVfcGFyc2VyX2NvcmUoKTtcbiAgICB2YXIgUGFyc2VyQmxvY2sgPSByZXF1aXJlX3BhcnNlcl9ibG9jaygpO1xuICAgIHZhciBQYXJzZXJJbmxpbmUgPSByZXF1aXJlX3BhcnNlcl9pbmxpbmUoKTtcbiAgICB2YXIgTGlua2lmeUl0ID0gcmVxdWlyZV9saW5raWZ5X2l0KCk7XG4gICAgdmFyIG1kdXJsID0gcmVxdWlyZV9tZHVybCgpO1xuICAgIHZhciBwdW55Y29kZSA9IHJlcXVpcmVfcHVueWNvZGUoKTtcbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgZGVmYXVsdDogcmVxdWlyZV9kZWZhdWx0KCksXG4gICAgICB6ZXJvOiByZXF1aXJlX3plcm8oKSxcbiAgICAgIGNvbW1vbm1hcms6IHJlcXVpcmVfY29tbW9ubWFyaygpXG4gICAgfTtcbiAgICB2YXIgQkFEX1BST1RPX1JFID0gL14odmJzY3JpcHR8amF2YXNjcmlwdHxmaWxlfGRhdGEpOi87XG4gICAgdmFyIEdPT0RfREFUQV9SRSA9IC9eZGF0YTppbWFnZVxcLyhnaWZ8cG5nfGpwZWd8d2VicCk7LztcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUxpbmsodXJsKSB7XG4gICAgICB2YXIgc3RyID0gdXJsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIEJBRF9QUk9UT19SRS50ZXN0KHN0cikgPyBHT09EX0RBVEFfUkUudGVzdChzdHIpID8gdHJ1ZSA6IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG4gICAgdmFyIFJFQ09ERV9IT1NUTkFNRV9GT1IgPSBbXCJodHRwOlwiLCBcImh0dHBzOlwiLCBcIm1haWx0bzpcIl07XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTGluayh1cmwpIHtcbiAgICAgIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xuICAgICAgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgICAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCBSRUNPREVfSE9TVE5BTUVfRk9SLmluZGV4T2YocGFyc2VkLnByb3RvY29sKSA+PSAwKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkocGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1kdXJsLmVuY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmtUZXh0KHVybCkge1xuICAgICAgdmFyIHBhcnNlZCA9IG1kdXJsLnBhcnNlKHVybCwgdHJ1ZSk7XG4gICAgICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9Vbmljb2RlKHBhcnNlZC5ob3N0bmFtZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZHVybC5kZWNvZGUobWR1cmwuZm9ybWF0KHBhcnNlZCksIG1kdXJsLmRlY29kZS5kZWZhdWx0Q2hhcnMgKyBcIiVcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1hcmtkb3duSXQzKHByZXNldE5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXJrZG93bkl0MykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrZG93bkl0MyhwcmVzZXROYW1lLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHByZXNldE5hbWUpKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHByZXNldE5hbWUgfHwge307XG4gICAgICAgICAgcHJlc2V0TmFtZSA9IFwiZGVmYXVsdFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmlubGluZSA9IG5ldyBQYXJzZXJJbmxpbmUoKTtcbiAgICAgIHRoaXMuYmxvY2sgPSBuZXcgUGFyc2VyQmxvY2soKTtcbiAgICAgIHRoaXMuY29yZSA9IG5ldyBQYXJzZXJDb3JlKCk7XG4gICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG4gICAgICB0aGlzLmxpbmtpZnkgPSBuZXcgTGlua2lmeUl0KCk7XG4gICAgICB0aGlzLnZhbGlkYXRlTGluayA9IHZhbGlkYXRlTGluaztcbiAgICAgIHRoaXMubm9ybWFsaXplTGluayA9IG5vcm1hbGl6ZUxpbms7XG4gICAgICB0aGlzLm5vcm1hbGl6ZUxpbmtUZXh0ID0gbm9ybWFsaXplTGlua1RleHQ7XG4gICAgICB0aGlzLnV0aWxzID0gdXRpbHM7XG4gICAgICB0aGlzLmhlbHBlcnMgPSB1dGlscy5hc3NpZ24oe30sIGhlbHBlcnMpO1xuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmNvbmZpZ3VyZShwcmVzZXROYW1lKTtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2V0KG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBNYXJrZG93bkl0My5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdXRpbHMuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hcmtkb3duSXQzLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbihwcmVzZXRzKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsIHByZXNldE5hbWU7XG4gICAgICBpZiAodXRpbHMuaXNTdHJpbmcocHJlc2V0cykpIHtcbiAgICAgICAgcHJlc2V0TmFtZSA9IHByZXNldHM7XG4gICAgICAgIHByZXNldHMgPSBjb25maWdbcHJlc2V0TmFtZV07XG4gICAgICAgIGlmICghcHJlc2V0cykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgYG1hcmtkb3duLWl0YCBwcmVzZXQgXCInICsgcHJlc2V0TmFtZSArICdcIiwgY2hlY2sgbmFtZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXByZXNldHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgYG1hcmtkb3duLWl0YCBwcmVzZXQsIGNhbid0IGJlIGVtcHR5XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMub3B0aW9ucykge1xuICAgICAgICBzZWxmLnNldChwcmVzZXRzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50cykge1xuICAgICAgICBPYmplY3Qua2V5cyhwcmVzZXRzLmNvbXBvbmVudHMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIGlmIChwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpIHtcbiAgICAgICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzMikge1xuICAgICAgICAgICAgc2VsZltuYW1lXS5ydWxlcjIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNYXJrZG93bkl0My5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24obGlzdDIsIGlnbm9yZUludmFsaWQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0MikpIHtcbiAgICAgICAgbGlzdDIgPSBbbGlzdDJdO1xuICAgICAgfVxuICAgICAgW1wiY29yZVwiLCBcImJsb2NrXCIsIFwiaW5saW5lXCJdLmZvckVhY2goZnVuY3Rpb24oY2hhaW4pIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5lbmFibGUobGlzdDIsIHRydWUpKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLmlubGluZS5ydWxlcjIuZW5hYmxlKGxpc3QyLCB0cnVlKSk7XG4gICAgICB2YXIgbWlzc2VkID0gbGlzdDIuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5pbmRleE9mKG5hbWUpIDwgMDtcbiAgICAgIH0pO1xuICAgICAgaWYgKG1pc3NlZC5sZW5ndGggJiYgIWlnbm9yZUludmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFya2Rvd25JdC4gRmFpbGVkIHRvIGVuYWJsZSB1bmtub3duIHJ1bGUocyk6IFwiICsgbWlzc2VkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWFya2Rvd25JdDMucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbihsaXN0MiwgaWdub3JlSW52YWxpZCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QyKSkge1xuICAgICAgICBsaXN0MiA9IFtsaXN0Ml07XG4gICAgICB9XG4gICAgICBbXCJjb3JlXCIsIFwiYmxvY2tcIiwgXCJpbmxpbmVcIl0uZm9yRWFjaChmdW5jdGlvbihjaGFpbikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXNbY2hhaW5dLnJ1bGVyLmRpc2FibGUobGlzdDIsIHRydWUpKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLmlubGluZS5ydWxlcjIuZGlzYWJsZShsaXN0MiwgdHJ1ZSkpO1xuICAgICAgdmFyIG1pc3NlZCA9IGxpc3QyLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuaW5kZXhPZihuYW1lKSA8IDA7XG4gICAgICB9KTtcbiAgICAgIGlmIChtaXNzZWQubGVuZ3RoICYmICFpZ25vcmVJbnZhbGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hcmtkb3duSXQuIEZhaWxlZCB0byBkaXNhYmxlIHVua25vd24gcnVsZShzKTogXCIgKyBtaXNzZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNYXJrZG93bkl0My5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24ocGx1Z2luNCkge1xuICAgICAgdmFyIGFyZ3MgPSBbdGhpc10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgcGx1Z2luNC5hcHBseShwbHVnaW40LCBhcmdzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWFya2Rvd25JdDMucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3JjLCBlbnYpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3JjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgc2hvdWxkIGJlIGEgU3RyaW5nXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXRlID0gbmV3IHRoaXMuY29yZS5TdGF0ZShzcmMsIHRoaXMsIGVudik7XG4gICAgICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5zO1xuICAgIH07XG4gICAgTWFya2Rvd25JdDMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHNyYywgZW52KSB7XG4gICAgICBlbnYgPSBlbnYgfHwge307XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbiAgICB9O1xuICAgIE1hcmtkb3duSXQzLnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uKHNyYywgZW52KSB7XG4gICAgICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcbiAgICAgIHN0YXRlLmlubGluZU1vZGUgPSB0cnVlO1xuICAgICAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VucztcbiAgICB9O1xuICAgIE1hcmtkb3duSXQzLnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbihzcmMsIGVudikge1xuICAgICAgZW52ID0gZW52IHx8IHt9O1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2VJbmxpbmUoc3JjLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudik7XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duSXQzO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2luZGV4LmpzXG52YXIgcmVxdWlyZV9tYXJrZG93bl9pdCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9saWIoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9hc3QvYmFzZS50c1xudmFyIGJhc2VfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoYmFzZV9leHBvcnRzLCB7XG4gIGdldEFzdFZhbHVlczogKCkgPT4gZ2V0QXN0VmFsdWVzLFxuICBpc0FzdDogKCkgPT4gaXNBc3QsXG4gIGlzRnVuY3Rpb246ICgpID0+IGlzRnVuY3Rpb24sXG4gIGlzVmFyaWFibGU6ICgpID0+IGlzVmFyaWFibGUsXG4gIHJlc29sdmU6ICgpID0+IHJlc29sdmVcbn0pO1xuZnVuY3Rpb24gaXNBc3QodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWU/LiQkbWR0eXBlO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWU/LiQkbWR0eXBlID09PSBcIkZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gaXNWYXJpYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWU/LiQkbWR0eXBlID09PSBcIlZhcmlhYmxlXCIpO1xufVxuZnVuY3Rpb24qIGdldEFzdFZhbHVlcyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKVxuICAgICAgeWllbGQqIGdldEFzdFZhbHVlcyh2KTtcbiAgaWYgKGlzQXN0KHZhbHVlKSlcbiAgICB5aWVsZCB2YWx1ZTtcbiAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgIT09IE9iamVjdC5wcm90b3R5cGUpXG4gICAgcmV0dXJuO1xuICBmb3IgKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyh2YWx1ZSkpXG4gICAgeWllbGQqIGdldEFzdFZhbHVlcyh2KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmUodmFsdWUsIGNvbmZpZyA9IHt9KSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gdmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWUubWFwKChpdGVtMikgPT4gcmVzb2x2ZShpdGVtMiwgY29uZmlnKSk7XG4gIGlmIChpc0FzdCh2YWx1ZSkgJiYgdmFsdWU/LnJlc29sdmUgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICByZXR1cm4gdmFsdWUucmVzb2x2ZShjb25maWcpO1xuICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSAhPT0gT2JqZWN0LnByb3RvdHlwZSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IG91dHB1dCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpXG4gICAgb3V0cHV0W2tdID0gcmVzb2x2ZSh2LCBjb25maWcpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBzcmMvdGFnLnRzXG52YXIgVGFnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihuYW1lID0gXCJkaXZcIiwgYXR0cmlidXRlcyA9IHt9LCBjaGlsZHJlbiA9IFtdKSB7XG4gICAgdGhpcy4kJG1kdHlwZSA9IFwiVGFnXCI7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfVxufTtcblRhZy5pc1RhZyA9ICh0YWcpID0+IHtcbiAgcmV0dXJuICEhKHRhZz8uJCRtZHR5cGUgPT09IFwiVGFnXCIpO1xufTtcblxuLy8gc3JjL3NjaGVtYS10eXBlcy9jbGFzcy50c1xudmFyIENsYXNzID0gY2xhc3Mge1xuICB2YWxpZGF0ZSh2YWx1ZSwgX2NvbmZpZywga2V5KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gW107XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYXR0cmlidXRlLXR5cGUtaW52YWxpZFwiLFxuICAgICAgICBsZXZlbDogXCJlcnJvclwiLFxuICAgICAgICBtZXNzYWdlOiBgQXR0cmlidXRlICcke2tleX0nIG11c3QgYmUgdHlwZSAnc3RyaW5nIHwgb2JqZWN0J2BcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIHRyYW5zZm9ybSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IGNsYXNzZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSA/PyB7fSkpXG4gICAgICBpZiAodilcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGspO1xuICAgIHJldHVybiBjbGFzc2VzLmpvaW4oXCIgXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvc2NoZW1hLXR5cGVzL2lkLnRzXG52YXIgSWQgPSBjbGFzcyB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tYXRjaCgvXlthLXpBLVpdLykpXG4gICAgICByZXR1cm4gW107XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYXR0cmlidXRlLXZhbHVlLWludmFsaWRcIixcbiAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogXCJUaGUgJ2lkJyBhdHRyaWJ1dGUgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyXCJcbiAgICAgIH1cbiAgICBdO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMudHNcbnZhciBpbXBvcnRfdGFnID0gX190b01vZHVsZShyZXF1aXJlX3RhZygpKTtcblxuLy8gc3JjL2FzdC92YXJpYWJsZS50c1xudmFyIFZhcmlhYmxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXRoID0gW10pIHtcbiAgICB0aGlzLiQkbWR0eXBlID0gXCJWYXJpYWJsZVwiO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cbiAgcmVzb2x2ZSh7IHZhcmlhYmxlcyB9ID0ge30pIHtcbiAgICByZXR1cm4gdmFyaWFibGVzIGluc3RhbmNlb2YgRnVuY3Rpb24gPyB2YXJpYWJsZXModGhpcy5wYXRoKSA6IHRoaXMucGF0aC5yZWR1Y2UoKG9iaiA9IHt9LCBrZXkpID0+IG9ialtrZXldLCB2YXJpYWJsZXMpO1xuICB9XG59O1xuXG4vLyBzcmMvYXN0L2Z1bmN0aW9uLnRzXG52YXIgRnVuY3Rpb24yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy4kJG1kdHlwZSA9IFwiRnVuY3Rpb25cIjtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gIH1cbiAgcmVzb2x2ZShjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IGZuID0gY29uZmlnPy5mdW5jdGlvbnM/Llt0aGlzLm5hbWVdO1xuICAgIGlmICghZm4pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gcmVzb2x2ZSh0aGlzLnBhcmFtZXRlcnMsIGNvbmZpZyk7XG4gICAgcmV0dXJuIGZuLnRyYW5zZm9ybT8uKHBhcmFtZXRlcnMsIGNvbmZpZyk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIFNUQVRFUztcbihmdW5jdGlvbihTVEFURVMyKSB7XG4gIFNUQVRFUzJbU1RBVEVTMltcIm5vcm1hbFwiXSA9IDBdID0gXCJub3JtYWxcIjtcbiAgU1RBVEVTMltTVEFURVMyW1wic3RyaW5nXCJdID0gMV0gPSBcInN0cmluZ1wiO1xuICBTVEFURVMyW1NUQVRFUzJbXCJlc2NhcGVcIl0gPSAyXSA9IFwiZXNjYXBlXCI7XG59KShTVEFURVMgfHwgKFNUQVRFUyA9IHt9KSk7XG52YXIgT1BFTiA9IFwieyVcIjtcbnZhciBDTE9TRSA9IFwiJX1cIjtcbnZhciBJREVOVElGSUVSX1JFR0VYID0gL15bYS16QS1aMC05Xy1dKyQvO1xuZnVuY3Rpb24gaXNJZGVudGlmaWVyKHMyKSB7XG4gIHJldHVybiB0eXBlb2YgczIgPT09IFwic3RyaW5nXCIgJiYgSURFTlRJRklFUl9SRUdFWC50ZXN0KHMyKTtcbn1cbmZ1bmN0aW9uIGlzUHJvbWlzZShhKSB7XG4gIHJldHVybiBhICYmIHR5cGVvZiBhID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBhLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGZpbmRUYWdFbmQoY29udGVudCwgc3RhcnQgPSAwKSB7XG4gIGxldCBzdGF0ZSA9IDA7XG4gIGZvciAobGV0IHBvcyA9IHN0YXJ0OyBwb3MgPCBjb250ZW50Lmxlbmd0aDsgcG9zKyspIHtcbiAgICBjb25zdCBjaGFyID0gY29udGVudFtwb3NdO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgIHN0YXRlID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICBpZiAoY2hhciA9PT0gJ1wiJylcbiAgICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnQuc3RhcnRzV2l0aChDTE9TRSwgcG9zKSlcbiAgICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlVGFnKGNvbnRlbnQsIGxpbmUsIGNvbnRlbnRTdGFydCkge1xuICB0cnkge1xuICAgIHJldHVybiAoMCwgaW1wb3J0X3RhZy5wYXJzZSkoY29udGVudCwgeyBWYXJpYWJsZSwgRnVuY3Rpb246IEZ1bmN0aW9uMiB9KTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgaWYgKCEoZXJyb3IyIGluc3RhbmNlb2YgaW1wb3J0X3RhZy5TeW50YXhFcnJvcikpXG4gICAgICB0aHJvdyBlcnJvcjI7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZSxcbiAgICAgIGxvY2F0aW9uOiB7IHN0YXJ0LCBlbmQgfVxuICAgIH0gPSBlcnJvcjI7XG4gICAgY29uc3QgbG9jYXRpb24gPSB7XG4gICAgICBzdGFydDogeyBsaW5lLCBjaGFyYWN0ZXI6IHN0YXJ0Lm9mZnNldCArIGNvbnRlbnRTdGFydCB9LFxuICAgICAgZW5kOiB7IGxpbmU6IGxpbmUgKyAxLCBjaGFyYWN0ZXI6IGVuZC5vZmZzZXQgKyBjb250ZW50U3RhcnQgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXRhOiB7IGVycm9yOiB7IG1lc3NhZ2UsIGxvY2F0aW9uIH0gfSB9O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVRhZ3MoY29udGVudCwgZmlyc3RMaW5lID0gMCkge1xuICBsZXQgbGluZSA9IGZpcnN0TGluZSArIDE7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBsZXQgc3RhcnQgPSAwO1xuICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBjb250ZW50Lmxlbmd0aDsgcG9zKyspIHtcbiAgICBpZiAoY29udGVudFtwb3NdID09PSBcIlxcblwiKSB7XG4gICAgICBsaW5lKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFjb250ZW50LnN0YXJ0c1dpdGgoT1BFTiwgcG9zKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGVuZCA9IGZpbmRUYWdFbmQoY29udGVudCwgcG9zKTtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgIHBvcyA9IHBvcyArIE9QRU4ubGVuZ3RoO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRleHQyID0gY29udGVudC5zbGljZShwb3MsIGVuZCArIENMT1NFLmxlbmd0aCk7XG4gICAgY29uc3QgaW5uZXIgPSBjb250ZW50LnNsaWNlKHBvcyArIE9QRU4ubGVuZ3RoLCBlbmQpO1xuICAgIGNvbnN0IGxpbmVTdGFydCA9IGNvbnRlbnQubGFzdEluZGV4T2YoXCJcXG5cIiwgcG9zKTtcbiAgICBjb25zdCBsaW5lRW5kID0gY29udGVudC5pbmRleE9mKFwiXFxuXCIsIGVuZCk7XG4gICAgY29uc3QgbGluZUNvbnRlbnQgPSBjb250ZW50LnNsaWNlKGxpbmVTdGFydCwgbGluZUVuZCk7XG4gICAgY29uc3QgdGFnID0gcGFyc2VUYWcoaW5uZXIudHJpbSgpLCBsaW5lLCBwb3MgLSBsaW5lU3RhcnQpO1xuICAgIGNvbnN0IHByZWNlZGluZ1RleHRFbmQgPSBsaW5lQ29udGVudC50cmltKCkgPT09IHRleHQyID8gbGluZVN0YXJ0IDogcG9zO1xuICAgIGNvbnN0IHByZWNlZGluZ1RleHQgPSBjb250ZW50LnNsaWNlKHN0YXJ0LCBwcmVjZWRpbmdUZXh0RW5kKTtcbiAgICBvdXRwdXQucHVzaCh7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kOiBwb3MgLSAxLFxuICAgICAgY29udGVudDogcHJlY2VkaW5nVGV4dFxuICAgIH0pO1xuICAgIG91dHB1dC5wdXNoKHtcbiAgICAgIG1hcDogW2xpbmUsIGxpbmUgKyAxXSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHN0YXJ0OiBwb3MgLSBsaW5lU3RhcnQsXG4gICAgICAgIGVuZDogcG9zIC0gbGluZVN0YXJ0ICsgdGV4dDIubGVuZ3RoXG4gICAgICB9LFxuICAgICAgc3RhcnQ6IHBvcyxcbiAgICAgIGVuZDogcG9zICsgdGV4dDIubGVuZ3RoIC0gMSxcbiAgICAgIGluZm86IHRleHQyLFxuICAgICAgLi4udGFnXG4gICAgfSk7XG4gICAgc3RhcnQgPSBlbmQgKyBDTE9TRS5sZW5ndGg7XG4gICAgcG9zID0gc3RhcnQgLSAxO1xuICB9XG4gIG91dHB1dC5wdXNoKHtcbiAgICB0eXBlOiBcInRleHRcIixcbiAgICBzdGFydCxcbiAgICBlbmQ6IGNvbnRlbnQubGVuZ3RoIC0gMSxcbiAgICBjb250ZW50OiBjb250ZW50LnNsaWNlKHN0YXJ0KVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVyLnRzXG52YXIgZ2xvYmFsQXR0cmlidXRlcyA9IHtcbiAgY2xhc3M6IHsgdHlwZTogQ2xhc3MsIHJlbmRlcjogdHJ1ZSB9LFxuICBpZDogeyB0eXBlOiBJZCwgcmVuZGVyOiB0cnVlIH1cbn07XG52YXIgdHJhbnNmb3JtZXJfZGVmYXVsdCA9IHtcbiAgZmluZFNjaGVtYShub2RlMiwgeyBub2RlcyA9IHt9LCB0YWdzID0ge30gfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5vZGUyLnRhZyA/IHRhZ3Nbbm9kZTIudGFnXSA6IG5vZGVzW25vZGUyLnR5cGVdO1xuICB9LFxuICBhdHRyaWJ1dGVzKG5vZGUyLCBjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuZmluZFNjaGVtYShub2RlMiwgY29uZmlnKSA/PyB7fTtcbiAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICBjb25zdCBhdHRycyA9IHsgLi4uZ2xvYmFsQXR0cmlidXRlcywgLi4uc2NoZW1hLmF0dHJpYnV0ZXMgfTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGF0dHJdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJzKSkge1xuICAgICAgaWYgKGF0dHIucmVuZGVyID09IGZhbHNlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgYXR0ci5yZW5kZXIgPT09IFwic3RyaW5nXCIgPyBhdHRyLnJlbmRlciA6IGtleTtcbiAgICAgIGxldCB2YWx1ZSA9IG5vZGUyLmF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgYXR0ci50eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgYXR0ci50eXBlKCk7XG4gICAgICAgIGlmIChpbnN0YW5jZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgICB2YWx1ZSA9IGluc3RhbmNlLnRyYW5zZm9ybSh2YWx1ZSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdm9pZCAwID8gYXR0ci5kZWZhdWx0IDogdmFsdWU7XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBvdXRwdXRbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5zbG90cykge1xuICAgICAgZm9yIChjb25zdCBba2V5LCBzbG90Ml0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnNsb3RzKSkge1xuICAgICAgICBpZiAoc2xvdDIucmVuZGVyID09PSBmYWxzZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBzbG90Mi5yZW5kZXIgPT09IFwic3RyaW5nXCIgPyBzbG90Mi5yZW5kZXIgOiBrZXk7XG4gICAgICAgIGlmIChub2RlMi5zbG90c1trZXldKVxuICAgICAgICAgIG91dHB1dFtuYW1lXSA9IHRoaXMubm9kZShub2RlMi5zbG90c1trZXldLCBjb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuICBjaGlsZHJlbihub2RlMiwgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUyLmNoaWxkcmVuLmZsYXRNYXAoKGNoaWxkKSA9PiB0aGlzLm5vZGUoY2hpbGQsIGNvbmZpZykpO1xuICAgIGlmIChjaGlsZHJlbi5zb21lKGlzUHJvbWlzZSkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSxcbiAgbm9kZShub2RlMiwgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBzY2hlbWEgPSB0aGlzLmZpbmRTY2hlbWEobm9kZTIsIGNvbmZpZykgPz8ge307XG4gICAgaWYgKHNjaGVtYSAmJiBzY2hlbWEudHJhbnNmb3JtIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICByZXR1cm4gc2NoZW1hLnRyYW5zZm9ybShub2RlMiwgY29uZmlnKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4obm9kZTIsIGNvbmZpZyk7XG4gICAgaWYgKCFzY2hlbWEgfHwgIXNjaGVtYS5yZW5kZXIpXG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcyhub2RlMiwgY29uZmlnKTtcbiAgICBpZiAoaXNQcm9taXNlKGF0dHJpYnV0ZXMpIHx8IGlzUHJvbWlzZShjaGlsZHJlbikpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbYXR0cmlidXRlcywgY2hpbGRyZW5dKS50aGVuKCh2YWx1ZXMpID0+IG5ldyBUYWcoc2NoZW1hLnJlbmRlciwgLi4udmFsdWVzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGFnKHNjaGVtYS5yZW5kZXIsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKTtcbiAgfVxufTtcblxuLy8gc3JjL2FzdC9ub2RlLnRzXG52YXIgTm9kZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodHlwZSA9IFwibm9kZVwiLCBhdHRyaWJ1dGVzID0ge30sIGNoaWxkcmVuID0gW10sIHRhZykge1xuICAgIHRoaXMuJCRtZHR5cGUgPSBcIk5vZGVcIjtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICB0aGlzLmlubGluZSA9IGZhbHNlO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50YWcgPSB0YWc7XG4gICAgdGhpcy5hbm5vdGF0aW9ucyA9IFtdO1xuICAgIHRoaXMuc2xvdHMgPSB7fTtcbiAgfVxuICAqd2FsaygpIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIFsuLi5PYmplY3QudmFsdWVzKHRoaXMuc2xvdHMpLCAuLi50aGlzLmNoaWxkcmVuXSkge1xuICAgICAgeWllbGQgY2hpbGQ7XG4gICAgICB5aWVsZCogY2hpbGQud2FsaygpO1xuICAgIH1cbiAgfVxuICBwdXNoKG5vZGUyKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKG5vZGUyKTtcbiAgfVxuICByZXNvbHZlKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IE5vZGUoKSwgdGhpcywge1xuICAgICAgY2hpbGRyZW46IHRoaXMuY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQucmVzb2x2ZShjb25maWcpKSxcbiAgICAgIGF0dHJpYnV0ZXM6IHJlc29sdmUodGhpcy5hdHRyaWJ1dGVzLCBjb25maWcpLFxuICAgICAgc2xvdHM6IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0aGlzLnNsb3RzKS5tYXAoKFtuYW1lLCBzbG90Ml0pID0+IFtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc2xvdDIucmVzb2x2ZShjb25maWcpXG4gICAgICBdKSlcbiAgICB9KTtcbiAgfVxuICBmaW5kU2NoZW1hKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyX2RlZmF1bHQuZmluZFNjaGVtYSh0aGlzLCBjb25maWcpO1xuICB9XG4gIHRyYW5zZm9ybUF0dHJpYnV0ZXMoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXJfZGVmYXVsdC5hdHRyaWJ1dGVzKHRoaXMsIGNvbmZpZyk7XG4gIH1cbiAgdHJhbnNmb3JtQ2hpbGRyZW4oY29uZmlnKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyX2RlZmF1bHQuY2hpbGRyZW4odGhpcywgY29uZmlnKTtcbiAgfVxuICB0cmFuc2Zvcm0oY29uZmlnKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyX2RlZmF1bHQubm9kZSh0aGlzLCBjb25maWcpO1xuICB9XG59O1xuXG4vLyBzcmMvYXN0L2luZGV4LnRzXG52YXIgQXN0VHlwZXMgPSB7XG4gIEZ1bmN0aW9uOiBGdW5jdGlvbjIsXG4gIE5vZGUsXG4gIFZhcmlhYmxlXG59O1xuZnVuY3Rpb24gcmV2aXZlcihfLCB2YWx1ZSkge1xuICBpZiAoIXZhbHVlKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgY29uc3Qga2xhc3MgPSBBc3RUeXBlc1t2YWx1ZS4kJG1kdHlwZV07XG4gIHJldHVybiBrbGFzcyA/IE9iamVjdC5hc3NpZ24obmV3IGtsYXNzKCksIHZhbHVlKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZnJvbUpTT04odGV4dDIpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UodGV4dDIsIHJldml2ZXIpO1xufVxudmFyIGFzdF9kZWZhdWx0ID0ge1xuICAuLi5Bc3RUeXBlcyxcbiAgLi4uYmFzZV9leHBvcnRzLFxuICBmcm9tSlNPTlxufTtcblxuLy8gc3JjL2Zvcm1hdHRlci50c1xudmFyIFNQQUNFID0gXCIgXCI7XG52YXIgU0VQID0gXCIsIFwiO1xudmFyIE5MID0gXCJcXG5cIjtcbnZhciBPTCA9IFwiLlwiO1xudmFyIFVMID0gXCItXCI7XG52YXIgTUFYX1RBR19PUEVOSU5HX1dJRFRIID0gODA7XG52YXIgV1JBUFBJTkdfVFlQRVMgPSBbXCJzdHJvbmdcIiwgXCJlbVwiLCBcInNcIl07XG52YXIgbWF4ID0gKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpO1xudmFyIGluY3JlbWVudCA9IChvLCBuID0gMikgPT4gKHtcbiAgLi4ubyxcbiAgaW5kZW50OiAoby5pbmRlbnQgfHwgMCkgKyBuXG59KTtcbmZ1bmN0aW9uKiBmb3JtYXRDaGlsZHJlbihhLCBvcHRpb25zKSB7XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgYS5jaGlsZHJlbikge1xuICAgIHlpZWxkKiBmb3JtYXRWYWx1ZShjaGlsZCwgb3B0aW9ucyk7XG4gIH1cbn1cbmZ1bmN0aW9uKiBmb3JtYXRJbmxpbmUoZykge1xuICB5aWVsZCBbLi4uZ10uam9pbihcIlwiKS50cmltKCk7XG59XG5mdW5jdGlvbiogZm9ybWF0VGFibGVSb3coaXRlbXMpIHtcbiAgeWllbGQgYHwgJHtpdGVtcy5qb2luKFwiIHwgXCIpfSB8YDtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNjYWxhcih2KSB7XG4gIGlmICh2ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChhc3RfZGVmYXVsdC5pc0FzdCh2KSkge1xuICAgIHJldHVybiBmb3JtYXQodik7XG4gIH1cbiAgaWYgKHYgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gXCJbXCIgKyB2Lm1hcChmb3JtYXRTY2FsYXIpLmpvaW4oU0VQKSArIFwiXVwiO1xuICB9XG4gIGlmICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBcIntcIiArIE9iamVjdC5lbnRyaWVzKHYpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtpc0lkZW50aWZpZXIoa2V5KSA/IGtleSA6IGBcIiR7a2V5fVwiYH06ICR7Zm9ybWF0U2NhbGFyKHZhbHVlKX1gKS5qb2luKFNFUCkgKyBcIn1cIjtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59XG5mdW5jdGlvbiBmb3JtYXRBbm5vdGF0aW9uVmFsdWUoYSkge1xuICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdFNjYWxhcihhLnZhbHVlKTtcbiAgaWYgKGZvcm1hdHRlZFZhbHVlID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKGEubmFtZSA9PT0gXCJwcmltYXJ5XCIpXG4gICAgcmV0dXJuIGZvcm1hdHRlZFZhbHVlO1xuICBpZiAoYS5uYW1lID09PSBcImlkXCIgJiYgdHlwZW9mIGEudmFsdWUgPT09IFwic3RyaW5nXCIgJiYgaXNJZGVudGlmaWVyKGEudmFsdWUpKVxuICAgIHJldHVybiBcIiNcIiArIGEudmFsdWU7XG4gIGlmIChhLnR5cGUgPT09IFwiY2xhc3NcIiAmJiBpc0lkZW50aWZpZXIoYS5uYW1lKSlcbiAgICByZXR1cm4gXCIuXCIgKyBhLm5hbWU7XG4gIHJldHVybiBgJHthLm5hbWV9PSR7Zm9ybWF0dGVkVmFsdWV9YDtcbn1cbmZ1bmN0aW9uKiBmb3JtYXRBdHRyaWJ1dGVzKG4pIHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobi5hdHRyaWJ1dGVzKSkge1xuICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIWFzdF9kZWZhdWx0LmlzQXN0KHZhbHVlKSlcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyh2YWx1ZSkpIHtcbiAgICAgICAgeWllbGQgZm9ybWF0QW5ub3RhdGlvblZhbHVlKHsgdHlwZTogXCJjbGFzc1wiLCBuYW1lLCB2YWx1ZSB9KTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICB5aWVsZCBmb3JtYXRBbm5vdGF0aW9uVmFsdWUoeyB0eXBlOiBcImF0dHJpYnV0ZVwiLCBuYW1lOiBrZXksIHZhbHVlIH0pO1xuICB9XG59XG5mdW5jdGlvbiogZm9ybWF0QW5ub3RhdGlvbnMobikge1xuICBpZiAobi5hbm5vdGF0aW9ucy5sZW5ndGgpIHtcbiAgICB5aWVsZCBPUEVOICsgU1BBQ0U7XG4gICAgeWllbGQgbi5hbm5vdGF0aW9ucy5tYXAoZm9ybWF0QW5ub3RhdGlvblZhbHVlKS5qb2luKFNQQUNFKTtcbiAgICB5aWVsZCBTUEFDRSArIENMT1NFO1xuICB9XG59XG5mdW5jdGlvbiogZm9ybWF0VmFyaWFibGUodikge1xuICB5aWVsZCBcIiRcIjtcbiAgeWllbGQgdi5wYXRoLm1hcCgocCwgaSkgPT4ge1xuICAgIGlmIChpID09PSAwKVxuICAgICAgcmV0dXJuIHA7XG4gICAgaWYgKGlzSWRlbnRpZmllcihwKSlcbiAgICAgIHJldHVybiBcIi5cIiArIHA7XG4gICAgaWYgKHR5cGVvZiBwID09PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIGBbJHtwfV1gO1xuICAgIHJldHVybiBgW1wiJHtwfVwiXWA7XG4gIH0pLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiogZm9ybWF0RnVuY3Rpb24oZikge1xuICB5aWVsZCBmLm5hbWU7XG4gIHlpZWxkIFwiKFwiO1xuICB5aWVsZCBPYmplY3QudmFsdWVzKGYucGFyYW1ldGVycykubWFwKGZvcm1hdFNjYWxhcikuam9pbihTRVApO1xuICB5aWVsZCBcIilcIjtcbn1cbmZ1bmN0aW9uKiB0cmltU3RhcnQoZykge1xuICBsZXQgbjtcbiAgZG8ge1xuICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGcubmV4dCgpO1xuICAgIGlmIChkb25lKVxuICAgICAgcmV0dXJuO1xuICAgIG4gPSB2YWx1ZS50cmltU3RhcnQoKTtcbiAgfSB3aGlsZSAoIW4ubGVuZ3RoKTtcbiAgeWllbGQgbjtcbiAgeWllbGQqIGc7XG59XG5mdW5jdGlvbiogZXNjYXBlTWFya2Rvd25DaGFyYWN0ZXJzKHMyLCBjaGFyYWN0ZXJzKSB7XG4gIHlpZWxkIHMyLnJlcGxhY2UoY2hhcmFjdGVycywgXCJcXFxcJCZcIikucmVwbGFjZShuZXcgUmVnRXhwKFwiXFx4QTBcIiwgXCJnXCIpLCBcIiZuYnNwO1wiKTtcbn1cbmZ1bmN0aW9uKiBmb3JtYXROb2RlKG4sIG8gPSB7fSkge1xuICBjb25zdCBubyA9IHsgLi4ubywgcGFyZW50OiBuIH07XG4gIGNvbnN0IGluZGVudCA9IFNQQUNFLnJlcGVhdChuby5pbmRlbnQgfHwgMCk7XG4gIHN3aXRjaCAobi50eXBlKSB7XG4gICAgY2FzZSBcImRvY3VtZW50XCI6IHtcbiAgICAgIGlmIChuLmF0dHJpYnV0ZXMuZnJvbnRtYXR0ZXIgJiYgbi5hdHRyaWJ1dGVzLmZyb250bWF0dGVyLmxlbmd0aCkge1xuICAgICAgICB5aWVsZCBcIi0tLVwiICsgTkwgKyBuLmF0dHJpYnV0ZXMuZnJvbnRtYXR0ZXIgKyBOTCArIFwiLS0tXCIgKyBOTCArIE5MO1xuICAgICAgfVxuICAgICAgeWllbGQqIHRyaW1TdGFydChmb3JtYXRDaGlsZHJlbihuLCBubykpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJoZWFkaW5nXCI6IHtcbiAgICAgIHlpZWxkIE5MO1xuICAgICAgeWllbGQgaW5kZW50O1xuICAgICAgeWllbGQgXCIjXCIucmVwZWF0KG4uYXR0cmlidXRlcy5sZXZlbCB8fCAxKTtcbiAgICAgIHlpZWxkIFNQQUNFO1xuICAgICAgeWllbGQqIHRyaW1TdGFydChmb3JtYXRDaGlsZHJlbihuLCBubykpO1xuICAgICAgeWllbGQqIGZvcm1hdEFubm90YXRpb25zKG4pO1xuICAgICAgeWllbGQgTkw7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInBhcmFncmFwaFwiOiB7XG4gICAgICB5aWVsZCBOTDtcbiAgICAgIHlpZWxkKiBmb3JtYXRDaGlsZHJlbihuLCBubyk7XG4gICAgICB5aWVsZCogZm9ybWF0QW5ub3RhdGlvbnMobik7XG4gICAgICB5aWVsZCBOTDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5saW5lXCI6IHtcbiAgICAgIHlpZWxkIGluZGVudDtcbiAgICAgIHlpZWxkKiBmb3JtYXRDaGlsZHJlbihuLCBubyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImltYWdlXCI6IHtcbiAgICAgIHlpZWxkIFwiIVwiO1xuICAgICAgeWllbGQgXCJbXCI7XG4gICAgICB5aWVsZCogZm9ybWF0VmFsdWUobi5hdHRyaWJ1dGVzLmFsdCwgbm8pO1xuICAgICAgeWllbGQgXCJdXCI7XG4gICAgICB5aWVsZCBcIihcIjtcbiAgICAgIHlpZWxkKiB0eXBlb2Ygbi5hdHRyaWJ1dGVzLnNyYyA9PT0gXCJzdHJpbmdcIiA/IGVzY2FwZU1hcmtkb3duQ2hhcmFjdGVycyhuLmF0dHJpYnV0ZXMuc3JjLCAvWygpXS9nKSA6IGZvcm1hdFZhbHVlKG4uYXR0cmlidXRlcy5zcmMsIG5vKTtcbiAgICAgIGlmIChuLmF0dHJpYnV0ZXMudGl0bGUpIHtcbiAgICAgICAgeWllbGQgU1BBQ0UgKyBgXCIke24uYXR0cmlidXRlcy50aXRsZX1cImA7XG4gICAgICB9XG4gICAgICB5aWVsZCBcIilcIjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibGlua1wiOiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IFsuLi5mb3JtYXRDaGlsZHJlbihuLCBubyldLmpvaW4oXCJcIik7XG4gICAgICBpZiAoY2hpbGRyZW4gPT09IG4uYXR0cmlidXRlcy5ocmVmICYmICFuLmF0dHJpYnV0ZXMudGl0bGUpIHtcbiAgICAgICAgeWllbGQgYDwke24uYXR0cmlidXRlcy5ocmVmfT5gO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHlpZWxkIFwiW1wiO1xuICAgICAgeWllbGQgY2hpbGRyZW47XG4gICAgICB5aWVsZCBcIl1cIjtcbiAgICAgIHlpZWxkIFwiKFwiO1xuICAgICAgeWllbGQqIHR5cGVvZiBuLmF0dHJpYnV0ZXMuaHJlZiA9PT0gXCJzdHJpbmdcIiA/IGVzY2FwZU1hcmtkb3duQ2hhcmFjdGVycyhuLmF0dHJpYnV0ZXMuaHJlZiwgL1soKV0vZykgOiBmb3JtYXRWYWx1ZShuLmF0dHJpYnV0ZXMuaHJlZiwgbm8pO1xuICAgICAgaWYgKG4uYXR0cmlidXRlcy50aXRsZSkge1xuICAgICAgICB5aWVsZCBTUEFDRSArIGBcIiR7bi5hdHRyaWJ1dGVzLnRpdGxlfVwiYDtcbiAgICAgIH1cbiAgICAgIHlpZWxkIFwiKVwiO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgIGNvbnN0IHsgY29udGVudCB9ID0gbi5hdHRyaWJ1dGVzO1xuICAgICAgaWYgKGFzdF9kZWZhdWx0LmlzQXN0KGNvbnRlbnQpKSB7XG4gICAgICAgIHlpZWxkIE9QRU4gKyBTUEFDRTtcbiAgICAgICAgeWllbGQqIGZvcm1hdFZhbHVlKGNvbnRlbnQsIG5vKTtcbiAgICAgICAgeWllbGQgU1BBQ0UgKyBDTE9TRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvLnBhcmVudCAmJiBXUkFQUElOR19UWVBFUy5pbmNsdWRlcyhvLnBhcmVudC50eXBlKSkge1xuICAgICAgICAgIHlpZWxkKiBlc2NhcGVNYXJrZG93bkNoYXJhY3RlcnMoY29udGVudCwgL1sqX35dL2cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkKiBlc2NhcGVNYXJrZG93bkNoYXJhY3RlcnMoY29udGVudCwgL15cXCp8IytcXHN8Xj4vKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJibG9ja3F1b3RlXCI6IHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IFwiPlwiICsgU1BBQ0U7XG4gICAgICB5aWVsZCBuLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGZvcm1hdChjaGlsZCwgbm8pLnRyaW1TdGFydCgpKS5tYXAoKGQpID0+IE5MICsgaW5kZW50ICsgcHJlZml4ICsgZCkuam9pbihpbmRlbnQgKyBwcmVmaXgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJoclwiOiB7XG4gICAgICB5aWVsZCBOTDtcbiAgICAgIHlpZWxkIGluZGVudDtcbiAgICAgIHlpZWxkIFwiLS0tXCI7XG4gICAgICB5aWVsZCBOTDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZmVuY2VcIjoge1xuICAgICAgeWllbGQgTkw7XG4gICAgICB5aWVsZCBpbmRlbnQ7XG4gICAgICBjb25zdCBpbm5lckZlbmNlID0gbi5hdHRyaWJ1dGVzLmNvbnRlbnQubWF0Y2goL2B7Myx9L2cpIHx8IFtdO1xuICAgICAgY29uc3QgaW5uZXJGZW5jZUxlbmd0aCA9IGlubmVyRmVuY2UubWFwKChzMikgPT4gczIubGVuZ3RoKS5yZWR1Y2UobWF4LCAwKTtcbiAgICAgIGNvbnN0IGJvdW5kYXJ5ID0gXCJgXCIucmVwZWF0KGlubmVyRmVuY2VMZW5ndGggPyBpbm5lckZlbmNlTGVuZ3RoICsgMSA6IDMpO1xuICAgICAgY29uc3QgbmVlZHNObEJlZm9yZUVuZEJvdW5kYXJ5ID0gIW4uYXR0cmlidXRlcy5jb250ZW50LmVuZHNXaXRoKE5MKTtcbiAgICAgIHlpZWxkIGJvdW5kYXJ5O1xuICAgICAgaWYgKG4uYXR0cmlidXRlcy5sYW5ndWFnZSlcbiAgICAgICAgeWllbGQgbi5hdHRyaWJ1dGVzLmxhbmd1YWdlO1xuICAgICAgaWYgKG4uYW5ub3RhdGlvbnMubGVuZ3RoKVxuICAgICAgICB5aWVsZCBTUEFDRTtcbiAgICAgIHlpZWxkKiBmb3JtYXRBbm5vdGF0aW9ucyhuKTtcbiAgICAgIHlpZWxkIE5MO1xuICAgICAgeWllbGQgaW5kZW50O1xuICAgICAgeWllbGQgbi5hdHRyaWJ1dGVzLmNvbnRlbnQuc3BsaXQoTkwpLmpvaW4oTkwgKyBpbmRlbnQpO1xuICAgICAgaWYgKG5lZWRzTmxCZWZvcmVFbmRCb3VuZGFyeSkge1xuICAgICAgICB5aWVsZCBOTDtcbiAgICAgIH1cbiAgICAgIHlpZWxkIGJvdW5kYXJ5O1xuICAgICAgeWllbGQgTkw7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInRhZ1wiOiB7XG4gICAgICBpZiAoIW4uaW5saW5lKSB7XG4gICAgICAgIHlpZWxkIE5MO1xuICAgICAgICB5aWVsZCBpbmRlbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVuID0gT1BFTiArIFNQQUNFO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IFsuLi5mb3JtYXRBdHRyaWJ1dGVzKG4pXS5maWx0ZXIoKHYpID0+IHYgIT09IHZvaWQgMCk7XG4gICAgICBjb25zdCB0YWcgPSBbb3BlbiArIG4udGFnLCAuLi5hdHRyaWJ1dGVzXTtcbiAgICAgIGNvbnN0IGlubGluZVRhZyA9IHRhZy5qb2luKFNQQUNFKTtcbiAgICAgIGNvbnN0IGlzTG9uZ1RhZ09wZW5pbmcgPSBpbmxpbmVUYWcubGVuZ3RoICsgb3Blbi5sZW5ndGggKiAyID4gKG8ubWF4VGFnT3BlbmluZ1dpZHRoIHx8IE1BWF9UQUdfT1BFTklOR19XSURUSCk7XG4gICAgICB5aWVsZCAoIW4uaW5saW5lICYmIGlzTG9uZ1RhZ09wZW5pbmcgPyB0YWcuam9pbihOTCArIFNQQUNFLnJlcGVhdChvcGVuLmxlbmd0aCkgKyBpbmRlbnQpIDogaW5saW5lVGFnKSArIFNQQUNFICsgKG4uY2hpbGRyZW4ubGVuZ3RoID8gXCJcIiA6IFwiL1wiKSArIENMT1NFO1xuICAgICAgaWYgKG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHlpZWxkKiBmb3JtYXRDaGlsZHJlbihuLCBuby5hbGxvd0luZGVudGF0aW9uID8gaW5jcmVtZW50KG5vKSA6IG5vKTtcbiAgICAgICAgaWYgKCFuLmlubGluZSkge1xuICAgICAgICAgIHlpZWxkIGluZGVudDtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBPUEVOICsgU1BBQ0UgKyBcIi9cIiArIG4udGFnICsgU1BBQ0UgKyBDTE9TRTtcbiAgICAgIH1cbiAgICAgIGlmICghbi5pbmxpbmUpIHtcbiAgICAgICAgeWllbGQgTkw7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImxpc3RcIjoge1xuICAgICAgY29uc3QgaXNMb29zZSA9IG4uY2hpbGRyZW4uc29tZSgobjIpID0+IG4yLmNoaWxkcmVuLnNvbWUoKGMpID0+IGMudHlwZSA9PT0gXCJwYXJhZ3JhcGhcIikpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9ICgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFuLmF0dHJpYnV0ZXMub3JkZXJlZClcbiAgICAgICAgICAgIHJldHVybiBuLmF0dHJpYnV0ZXMubWFya2VyID8/IFVMO1xuICAgICAgICAgIGxldCBudW1iZXIgPSBcIjFcIjtcbiAgICAgICAgICBjb25zdCBzdGFydE51bWJlciA9IG4uYXR0cmlidXRlcy5zdGFydCA/PyAxO1xuICAgICAgICAgIGlmIChpID09PSAwKVxuICAgICAgICAgICAgbnVtYmVyID0gc3RhcnROdW1iZXIudG9TdHJpbmcoKTtcbiAgICAgICAgICBpZiAoby5vcmRlcmVkTGlzdE1vZGUgPT09IFwiaW5jcmVtZW50XCIpIHtcbiAgICAgICAgICAgIG51bWJlciA9IChwYXJzZUludChzdGFydE51bWJlcikgKyBpKS50b1N0cmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYCR7bnVtYmVyfSR7bi5hdHRyaWJ1dGVzLm1hcmtlciA/PyBPTH1gO1xuICAgICAgICB9KSgpO1xuICAgICAgICBsZXQgZCA9IGZvcm1hdChuLmNoaWxkcmVuW2ldLCBpbmNyZW1lbnQobm8sIHByZWZpeC5sZW5ndGggKyAxKSk7XG4gICAgICAgIGlmICghaXNMb29zZSB8fCBpID09PSBuLmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBkID0gZC50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgTkwgKyBpbmRlbnQgKyBwcmVmaXggKyBcIiBcIiArIGQ7XG4gICAgICB9XG4gICAgICB5aWVsZCBOTDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaXRlbVwiOiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG4uY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeWllbGQqIGZvcm1hdFZhbHVlKG4uY2hpbGRyZW5baV0sIG5vKTtcbiAgICAgICAgaWYgKGkgPT09IDApXG4gICAgICAgICAgeWllbGQqIGZvcm1hdEFubm90YXRpb25zKG4pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJzdHJvbmdcIjoge1xuICAgICAgeWllbGQgbi5hdHRyaWJ1dGVzLm1hcmtlciA/PyBcIioqXCI7XG4gICAgICB5aWVsZCogZm9ybWF0SW5saW5lKGZvcm1hdENoaWxkcmVuKG4sIG5vKSk7XG4gICAgICB5aWVsZCBuLmF0dHJpYnV0ZXMubWFya2VyID8/IFwiKipcIjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZW1cIjoge1xuICAgICAgeWllbGQgbi5hdHRyaWJ1dGVzLm1hcmtlciA/PyBcIipcIjtcbiAgICAgIHlpZWxkKiBmb3JtYXRJbmxpbmUoZm9ybWF0Q2hpbGRyZW4obiwgbm8pKTtcbiAgICAgIHlpZWxkIG4uYXR0cmlidXRlcy5tYXJrZXIgPz8gXCIqXCI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImNvZGVcIjoge1xuICAgICAgeWllbGQgXCJgXCI7XG4gICAgICB5aWVsZCogZm9ybWF0SW5saW5lKGZvcm1hdFZhbHVlKG4uYXR0cmlidXRlcy5jb250ZW50LCBubykpO1xuICAgICAgeWllbGQgXCJgXCI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInNcIjoge1xuICAgICAgeWllbGQgXCJ+flwiO1xuICAgICAgeWllbGQqIGZvcm1hdElubGluZShmb3JtYXRDaGlsZHJlbihuLCBubykpO1xuICAgICAgeWllbGQgXCJ+flwiO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJoYXJkYnJlYWtcIjoge1xuICAgICAgeWllbGQgXCJcXFxcXCIgKyBOTDtcbiAgICAgIHlpZWxkIGluZGVudDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic29mdGJyZWFrXCI6IHtcbiAgICAgIHlpZWxkIE5MO1xuICAgICAgeWllbGQgaW5kZW50O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ0YWJsZVwiOiB7XG4gICAgICBjb25zdCB0YWJsZTMgPSBbLi4uZm9ybWF0Q2hpbGRyZW4obiwgaW5jcmVtZW50KG5vKSldO1xuICAgICAgaWYgKG8ucGFyZW50ICYmIG8ucGFyZW50LnR5cGUgPT09IFwidGFnXCIgJiYgby5wYXJlbnQudGFnID09PSBcInRhYmxlXCIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJsZTMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByb3cgPSB0YWJsZTNbaV07XG4gICAgICAgICAgaWYgKHR5cGVvZiByb3cgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChyb3cudHJpbSgpLmxlbmd0aCkge1xuICAgICAgICAgICAgICB5aWVsZCBOTDtcbiAgICAgICAgICAgICAgeWllbGQgcm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICB5aWVsZCBOTDtcbiAgICAgICAgICAgICAgeWllbGQgaW5kZW50ICsgXCItLS1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZCBvZiByb3cpIHtcbiAgICAgICAgICAgICAgeWllbGQgTkwgKyBpbmRlbnQgKyBVTCArIFwiIFwiICsgZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgTkw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGUzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHdpZHRoc1tpXSA9IHdpZHRoc1tpXSA/IE1hdGgubWF4KHdpZHRoc1tpXSwgcm93W2ldLmxlbmd0aCkgOiByb3dbaV0ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaGVhZCwgLi4ucm93c10gPSB0YWJsZTM7XG4gICAgICAgIHlpZWxkIE5MO1xuICAgICAgICB5aWVsZCogZm9ybWF0VGFibGVSb3coaGVhZC5tYXAoKGNlbGwsIGkpID0+IGNlbGwgKyBTUEFDRS5yZXBlYXQod2lkdGhzW2ldIC0gY2VsbC5sZW5ndGgpKSk7XG4gICAgICAgIHlpZWxkIE5MO1xuICAgICAgICB5aWVsZCogZm9ybWF0VGFibGVSb3coaGVhZC5tYXAoKGNlbGwsIGkpID0+IFwiLVwiLnJlcGVhdCh3aWR0aHNbaV0pKSk7XG4gICAgICAgIHlpZWxkIE5MO1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgeWllbGQqIGZvcm1hdFRhYmxlUm93KHJvdy5tYXAoKGNlbGwsIGkpID0+IGNlbGwgKyBTUEFDRS5yZXBlYXQod2lkdGhzW2ldIC0gY2VsbC5sZW5ndGgpKSk7XG4gICAgICAgICAgeWllbGQgTkw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwidGhlYWRcIjoge1xuICAgICAgY29uc3QgW2hlYWRdID0gWy4uLmZvcm1hdENoaWxkcmVuKG4sIG5vKV07XG4gICAgICB5aWVsZCBoZWFkIHx8IFtdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ0clwiOiB7XG4gICAgICB5aWVsZCBbLi4uZm9ybWF0Q2hpbGRyZW4obiwgbm8pXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwidGRcIjpcbiAgICBjYXNlIFwidGhcIjoge1xuICAgICAgeWllbGQgWy4uLmZvcm1hdENoaWxkcmVuKG4sIG5vKSwgLi4uZm9ybWF0QW5ub3RhdGlvbnMobildLmpvaW4oXCJcIikudHJpbSgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ0Ym9keVwiOiB7XG4gICAgICB5aWVsZCogZm9ybWF0Q2hpbGRyZW4obiwgbm8pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJjb21tZW50XCI6IHtcbiAgICAgIHlpZWxkIFwiPCEtLSBcIiArIG4uYXR0cmlidXRlcy5jb250ZW50ICsgXCIgLS0+XFxuXCI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImVycm9yXCI6XG4gICAgY2FzZSBcIm5vZGVcIjpcbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiogZm9ybWF0VmFsdWUodiwgbyA9IHt9KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6IHtcbiAgICAgIHlpZWxkIHYudG9TdHJpbmcoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgIGlmICh2ID09PSBudWxsKVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiB2KVxuICAgICAgICAgIHlpZWxkKiBmb3JtYXRWYWx1ZShuLCBvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHYuJCRtZHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkZ1bmN0aW9uXCI6IHtcbiAgICAgICAgICB5aWVsZCogZm9ybWF0RnVuY3Rpb24odik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk5vZGVcIjpcbiAgICAgICAgICB5aWVsZCogZm9ybWF0Tm9kZSh2LCBvKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlZhcmlhYmxlXCI6IHtcbiAgICAgICAgICB5aWVsZCogZm9ybWF0VmFyaWFibGUodik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaW1wbGVtZW50ZWQ6IFwiJHt2LiQkbWR0eXBlfVwiYCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdCh2LCBvcHRpb25zKSB7XG4gIGxldCBkb2MgPSBcIlwiO1xuICBmb3IgKGNvbnN0IHMyIG9mIGZvcm1hdFZhbHVlKHYsIG9wdGlvbnMpKVxuICAgIGRvYyArPSBzMjtcbiAgcmV0dXJuIGRvYy50cmltU3RhcnQoKTtcbn1cblxuLy8gc3JjL3NjaGVtYS10eXBlcy9jb25kaXRpb25hbC50c1xudmFyIENvbmRpdGlvbmFsQXR0cmlidXRlVHlwZSA9IGNsYXNzIHtcbiAgdmFsaWRhdGUodmFsdWUsIF9jb25maWcsIGtleSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgfHwgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImF0dHJpYnV0ZS10eXBlLWludmFsaWRcIixcbiAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogYEF0dHJpYnV0ZSAnJHtrZXl9JyBtdXN0IGJlIHR5cGUgJ2Jvb2xlYW4gfCBvYmplY3QnIChudWxsIG9yIHVuZGVmaW5lZCBhcmUgYWxzbyBhbGxvd2VkKWBcbiAgICAgIH1cbiAgICBdO1xuICB9XG59O1xuXG4vLyBzcmMvdGFncy9jb25kaXRpb25hbC50c1xuZnVuY3Rpb24gdHJ1dGh5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gZmFsc2UgJiYgdmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlbmRlckNvbmRpdGlvbnMobm9kZTIpIHtcbiAgY29uc3QgY29uZGl0aW9ucyA9IFtcbiAgICB7IGNvbmRpdGlvbjogbm9kZTIuYXR0cmlidXRlcy5wcmltYXJ5LCBjaGlsZHJlbjogW10gfVxuICBdO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUyLmNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IFwidGFnXCIgJiYgY2hpbGQudGFnID09PSBcImVsc2VcIilcbiAgICAgIGNvbmRpdGlvbnMucHVzaCh7XG4gICAgICAgIGNvbmRpdGlvbjogXCJwcmltYXJ5XCIgaW4gY2hpbGQuYXR0cmlidXRlcyA/IGNoaWxkLmF0dHJpYnV0ZXMucHJpbWFyeSA6IHRydWUsXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgY29uZGl0aW9uc1tjb25kaXRpb25zLmxlbmd0aCAtIDFdLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9XG4gIHJldHVybiBjb25kaXRpb25zO1xufVxudmFyIHRhZ0lmID0ge1xuICBhdHRyaWJ1dGVzOiB7XG4gICAgcHJpbWFyeTogeyB0eXBlOiBDb25kaXRpb25hbEF0dHJpYnV0ZVR5cGUsIHJlbmRlcjogZmFsc2UgfVxuICB9LFxuICB0cmFuc2Zvcm0obm9kZTIsIGNvbmZpZykge1xuICAgIGNvbnN0IGNvbmRpdGlvbnMgPSByZW5kZXJDb25kaXRpb25zKG5vZGUyKTtcbiAgICBmb3IgKGNvbnN0IHsgY29uZGl0aW9uLCBjaGlsZHJlbiB9IG9mIGNvbmRpdGlvbnMpXG4gICAgICBpZiAodHJ1dGh5KGNvbmRpdGlvbikpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbi5mbGF0TWFwKChjaGlsZCkgPT4gY2hpbGQudHJhbnNmb3JtKGNvbmZpZykpO1xuICAgICAgICBpZiAobm9kZXMuc29tZShpc1Byb21pc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG5vZGVzKS50aGVuKChub2RlczIpID0+IG5vZGVzMi5mbGF0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbn07XG52YXIgdGFnRWxzZSA9IHtcbiAgc2VsZkNsb3Npbmc6IHRydWUsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBwcmltYXJ5OiB7IHR5cGU6IENvbmRpdGlvbmFsQXR0cmlidXRlVHlwZSwgcmVuZGVyOiBmYWxzZSB9XG4gIH1cbn07XG5cbi8vIHNyYy9mdW5jdGlvbnMvaW5kZXgudHNcbnZhciBhbmQgPSB7XG4gIHRyYW5zZm9ybShwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocGFyYW1ldGVycykuZXZlcnkoKHgpID0+IHRydXRoeSh4KSk7XG4gIH1cbn07XG52YXIgb3IgPSB7XG4gIHRyYW5zZm9ybShwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocGFyYW1ldGVycykuZmluZCgoeCkgPT4gdHJ1dGh5KHgpKSAhPT0gdm9pZCAwO1xuICB9XG59O1xudmFyIG5vdCA9IHtcbiAgcGFyYW1ldGVyczoge1xuICAgIDA6IHsgcmVxdWlyZWQ6IHRydWUgfVxuICB9LFxuICB0cmFuc2Zvcm0ocGFyYW1ldGVycykge1xuICAgIHJldHVybiAhdHJ1dGh5KHBhcmFtZXRlcnNbMF0pO1xuICB9XG59O1xudmFyIGVxdWFscyA9IHtcbiAgdHJhbnNmb3JtKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKHBhcmFtZXRlcnMpO1xuICAgIHJldHVybiB2YWx1ZXMuZXZlcnkoKHYpID0+IHYgPT09IHZhbHVlc1swXSk7XG4gIH1cbn07XG52YXIgZGVidWcgPSB7XG4gIHRyYW5zZm9ybShwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcmFtZXRlcnNbMF0sIG51bGwsIDIpO1xuICB9XG59O1xudmFyIGRlZmF1bHRGbiA9IHtcbiAgdHJhbnNmb3JtKHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gcGFyYW1ldGVyc1swXSA9PT0gdm9pZCAwID8gcGFyYW1ldGVyc1sxXSA6IHBhcmFtZXRlcnNbMF07XG4gIH1cbn07XG52YXIgZnVuY3Rpb25zX2RlZmF1bHQgPSB7IGFuZCwgb3IsIG5vdCwgZXF1YWxzLCBkZWZhdWx0OiBkZWZhdWx0Rm4sIGRlYnVnIH07XG5cbi8vIHNyYy90cmFuc2Zvcm1zL3RhYmxlLnRzXG5mdW5jdGlvbiBjb252ZXJ0VG9Sb3cobm9kZTIsIGNlbGxUeXBlID0gXCJ0ZFwiKSB7XG4gIG5vZGUyLnR5cGUgPSBcInRyXCI7XG4gIG5vZGUyLmF0dHJpYnV0ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBjZWxsIG9mIG5vZGUyLmNoaWxkcmVuKVxuICAgIGNlbGwudHlwZSA9IGNlbGxUeXBlO1xuICByZXR1cm4gbm9kZTI7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZG9jdW1lbnQyKSB7XG4gIGZvciAoY29uc3Qgbm9kZTIgb2YgZG9jdW1lbnQyLndhbGsoKSkge1xuICAgIGlmIChub2RlMi50eXBlICE9PSBcInRhZ1wiIHx8IG5vZGUyLnRhZyAhPT0gXCJ0YWJsZVwiKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgW2ZpcnN0LCAuLi5yZXN0XSA9IG5vZGUyLmNoaWxkcmVuO1xuICAgIGlmICghZmlyc3QgfHwgZmlyc3QudHlwZSA9PT0gXCJ0YWJsZVwiKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgdGFibGUzID0gbmV3IGFzdF9kZWZhdWx0Lk5vZGUoXCJ0YWJsZVwiLCBub2RlMi5hdHRyaWJ1dGVzLCBbXG4gICAgICBuZXcgYXN0X2RlZmF1bHQuTm9kZShcInRoZWFkXCIpLFxuICAgICAgbmV3IGFzdF9kZWZhdWx0Lk5vZGUoXCJ0Ym9keVwiKVxuICAgIF0pO1xuICAgIGNvbnN0IFt0aGVhZDIsIHRib2R5Ml0gPSB0YWJsZTMuY2hpbGRyZW47XG4gICAgaWYgKGZpcnN0LnR5cGUgPT09IFwibGlzdFwiKVxuICAgICAgdGhlYWQyLnB1c2goY29udmVydFRvUm93KGZpcnN0LCBcInRoXCIpKTtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiByZXN0KSB7XG4gICAgICBpZiAocm93LnR5cGUgPT09IFwibGlzdFwiKVxuICAgICAgICBjb252ZXJ0VG9Sb3cocm93KTtcbiAgICAgIGVsc2UgaWYgKHJvdy50eXBlID09PSBcInRhZ1wiICYmIHJvdy50YWcgPT09IFwiaWZcIikge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHJvdy5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImhyXCIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJsaXN0XCIpXG4gICAgICAgICAgICBjb252ZXJ0VG9Sb3coY2hpbGQpO1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJvdy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdGJvZHkyLnB1c2gocm93KTtcbiAgICB9XG4gICAgbm9kZTIuY2hpbGRyZW4gPSBbdGFibGUzXTtcbiAgfVxufVxuXG4vLyBzcmMvdHJhbnNmb3Jtcy9pbmRleC50c1xudmFyIHRyYW5zZm9ybXNfZGVmYXVsdCA9IFt0cmFuc2Zvcm1dO1xuXG4vLyBzcmMvcGFyc2VyLnRzXG52YXIgbWFwcGluZ3MgPSB7XG4gIG9yZGVyZWRfbGlzdDogXCJsaXN0XCIsXG4gIGJ1bGxldF9saXN0OiBcImxpc3RcIixcbiAgY29kZV9pbmxpbmU6IFwiY29kZVwiLFxuICBsaXN0X2l0ZW06IFwiaXRlbVwiLFxuICB2YXJpYWJsZTogXCJ0ZXh0XCJcbn07XG5mdW5jdGlvbiBhbm5vdGF0ZShub2RlMiwgYXR0cmlidXRlcykge1xuICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgbm9kZTIuYW5ub3RhdGlvbnMucHVzaChhdHRyaWJ1dGUpO1xuICAgIGNvbnN0IHsgbmFtZSwgdmFsdWUsIHR5cGUgfSA9IGF0dHJpYnV0ZTtcbiAgICBpZiAodHlwZSA9PT0gXCJhdHRyaWJ1dGVcIikge1xuICAgICAgaWYgKG5vZGUyLmF0dHJpYnV0ZXNbbmFtZV0gIT09IHZvaWQgMClcbiAgICAgICAgbm9kZTIuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGlkOiBcImR1cGxpY2F0ZS1hdHRyaWJ1dGVcIixcbiAgICAgICAgICBsZXZlbDogXCJ3YXJuaW5nXCIsXG4gICAgICAgICAgbWVzc2FnZTogYEF0dHJpYnV0ZSAnJHtuYW1lfScgYWxyZWFkeSBzZXRgXG4gICAgICAgIH0pO1xuICAgICAgbm9kZTIuYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjbGFzc1wiKVxuICAgICAgaWYgKG5vZGUyLmF0dHJpYnV0ZXMuY2xhc3MpXG4gICAgICAgIG5vZGUyLmF0dHJpYnV0ZXMuY2xhc3NbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIGVsc2VcbiAgICAgICAgbm9kZTIuYXR0cmlidXRlcy5jbGFzcyA9IHsgW25hbWVdOiB2YWx1ZSB9O1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVBdHRycyh0b2tlbiwgdHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiaGVhZGluZ1wiOlxuICAgICAgcmV0dXJuIHsgbGV2ZWw6IE51bWJlcih0b2tlbi50YWcucmVwbGFjZShcImhcIiwgXCJcIikpIH07XG4gICAgY2FzZSBcImxpc3RcIjoge1xuICAgICAgY29uc3QgYXR0cnMgPSB0b2tlbi5hdHRycyA/IE9iamVjdC5mcm9tRW50cmllcyh0b2tlbi5hdHRycykgOiB2b2lkIDA7XG4gICAgICBjb25zdCBvcmRlcmVkID0gdG9rZW4udHlwZS5zdGFydHNXaXRoKFwib3JkZXJlZFwiKTtcbiAgICAgIHJldHVybiBvcmRlcmVkICYmIGF0dHJzPy5zdGFydCA/IHsgb3JkZXJlZDogdHJ1ZSwgc3RhcnQ6IGF0dHJzLnN0YXJ0LCBtYXJrZXI6IHRva2VuLm1hcmt1cCB9IDogeyBvcmRlcmVkLCBtYXJrZXI6IHRva2VuLm1hcmt1cCB9O1xuICAgIH1cbiAgICBjYXNlIFwibGlua1wiOiB7XG4gICAgICBjb25zdCBhdHRycyA9IE9iamVjdC5mcm9tRW50cmllcyh0b2tlbi5hdHRycyk7XG4gICAgICByZXR1cm4gYXR0cnMudGl0bGUgPyB7IGhyZWY6IGF0dHJzLmhyZWYsIHRpdGxlOiBhdHRycy50aXRsZSB9IDogeyBocmVmOiBhdHRycy5ocmVmIH07XG4gICAgfVxuICAgIGNhc2UgXCJpbWFnZVwiOiB7XG4gICAgICBjb25zdCBhdHRycyA9IE9iamVjdC5mcm9tRW50cmllcyh0b2tlbi5hdHRycyk7XG4gICAgICByZXR1cm4gYXR0cnMudGl0bGUgPyB7IGFsdDogdG9rZW4uY29udGVudCwgc3JjOiBhdHRycy5zcmMsIHRpdGxlOiBhdHRycy50aXRsZSB9IDogeyBhbHQ6IHRva2VuLmNvbnRlbnQsIHNyYzogYXR0cnMuc3JjIH07XG4gICAgfVxuICAgIGNhc2UgXCJlbVwiOlxuICAgIGNhc2UgXCJzdHJvbmdcIjpcbiAgICAgIHJldHVybiB7IG1hcmtlcjogdG9rZW4ubWFya3VwIH07XG4gICAgY2FzZSBcInRleHRcIjpcbiAgICBjYXNlIFwiY29kZVwiOlxuICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICByZXR1cm4geyBjb250ZW50OiAodG9rZW4ubWV0YSB8fCB7fSkudmFyaWFibGUgfHwgdG9rZW4uY29udGVudCB9O1xuICAgIGNhc2UgXCJmZW5jZVwiOiB7XG4gICAgICBjb25zdCBbbGFuZ3VhZ2VdID0gdG9rZW4uaW5mby5zcGxpdChcIiBcIiwgMSk7XG4gICAgICByZXR1cm4gbGFuZ3VhZ2UgPT09IFwiXCIgfHwgbGFuZ3VhZ2UgPT09IE9QRU4gPyB7IGNvbnRlbnQ6IHRva2VuLmNvbnRlbnQgfSA6IHsgY29udGVudDogdG9rZW4uY29udGVudCwgbGFuZ3VhZ2UgfTtcbiAgICB9XG4gICAgY2FzZSBcInRkXCI6XG4gICAgY2FzZSBcInRoXCI6IHtcbiAgICAgIGlmICh0b2tlbi5hdHRycykge1xuICAgICAgICBjb25zdCBhdHRycyA9IE9iamVjdC5mcm9tRW50cmllcyh0b2tlbi5hdHRycyk7XG4gICAgICAgIGxldCBhbGlnbjtcbiAgICAgICAgaWYgKGF0dHJzLnN0eWxlKSB7XG4gICAgICAgICAgaWYgKGF0dHJzLnN0eWxlLmluY2x1ZGVzKFwibGVmdFwiKSkge1xuICAgICAgICAgICAgYWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJzLnN0eWxlLmluY2x1ZGVzKFwiY2VudGVyXCIpKSB7XG4gICAgICAgICAgICBhbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChhdHRycy5zdHlsZS5pbmNsdWRlcyhcInJpZ2h0XCIpKSB7XG4gICAgICAgICAgICBhbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsaWduKSB7XG4gICAgICAgICAgcmV0dXJuIHsgYWxpZ24gfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHt9O1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVUb2tlbih0b2tlbiwgbm9kZXMsIGZpbGUsIGhhbmRsZVNsb3RzLCBhZGRMb2NhdGlvbiwgaW5saW5lUGFyZW50KSB7XG4gIGlmICh0b2tlbi50eXBlID09PSBcImZyb250bWF0dGVyXCIpIHtcbiAgICBub2Rlc1swXS5hdHRyaWJ1dGVzLmZyb250bWF0dGVyID0gdG9rZW4uY29udGVudDtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRva2VuLmhpZGRlbiB8fCB0b2tlbi50eXBlID09PSBcInRleHRcIiAmJiB0b2tlbi5jb250ZW50ID09PSBcIlwiKVxuICAgIHJldHVybjtcbiAgY29uc3QgZXJyb3JzID0gdG9rZW4uZXJyb3JzIHx8IFtdO1xuICBjb25zdCBwYXJlbnQgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgY29uc3QgeyB0YWcsIGF0dHJpYnV0ZXMsIGVycm9yOiBlcnJvcjIgfSA9IHRva2VuLm1ldGEgfHwge307XG4gIGlmICh0b2tlbi50eXBlID09PSBcImFubm90YXRpb25cIikge1xuICAgIGlmIChpbmxpbmVQYXJlbnQpXG4gICAgICByZXR1cm4gYW5ub3RhdGUoaW5saW5lUGFyZW50LCBhdHRyaWJ1dGVzKTtcbiAgICByZXR1cm4gcGFyZW50LmVycm9ycy5wdXNoKHtcbiAgICAgIGlkOiBcIm5vLWlubGluZS1hbm5vdGF0aW9uc1wiLFxuICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgIG1lc3NhZ2U6IGBDYW4ndCBhcHBseSBpbmxpbmUgYW5ub3RhdGlvbnMgdG8gJyR7cGFyZW50LnR5cGV9J2BcbiAgICB9KTtcbiAgfVxuICBsZXQgdHlwZU5hbWUgPSB0b2tlbi50eXBlLnJlcGxhY2UoL18ob3BlbnxjbG9zZSkkLywgXCJcIik7XG4gIGlmIChtYXBwaW5nc1t0eXBlTmFtZV0pXG4gICAgdHlwZU5hbWUgPSBtYXBwaW5nc1t0eXBlTmFtZV07XG4gIGlmICh0eXBlTmFtZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgY29uc3QgeyBtZXNzYWdlLCBsb2NhdGlvbiB9ID0gZXJyb3IyO1xuICAgIGVycm9ycy5wdXNoKHsgaWQ6IFwicGFyc2UtZXJyb3JcIiwgbGV2ZWw6IFwiY3JpdGljYWxcIiwgbWVzc2FnZSwgbG9jYXRpb24gfSk7XG4gIH1cbiAgaWYgKHRva2VuLm5lc3RpbmcgPCAwKSB7XG4gICAgaWYgKHBhcmVudC50eXBlID09PSB0eXBlTmFtZSAmJiBwYXJlbnQudGFnID09PSB0YWcpIHtcbiAgICAgIGlmIChwYXJlbnQubGluZXMgJiYgdG9rZW4ubWFwKVxuICAgICAgICBwYXJlbnQubGluZXMucHVzaCguLi50b2tlbi5tYXApO1xuICAgICAgcmV0dXJuIG5vZGVzLnBvcCgpO1xuICAgIH1cbiAgICBlcnJvcnMucHVzaCh7XG4gICAgICBpZDogXCJtaXNzaW5nLW9wZW5pbmdcIixcbiAgICAgIGxldmVsOiBcImNyaXRpY2FsXCIsXG4gICAgICBtZXNzYWdlOiBgTm9kZSAnJHt0eXBlTmFtZX0nIGlzIG1pc3Npbmcgb3BlbmluZ2BcbiAgICB9KTtcbiAgfVxuICBjb25zdCBhdHRycyA9IGhhbmRsZUF0dHJzKHRva2VuLCB0eXBlTmFtZSk7XG4gIGNvbnN0IG5vZGUyID0gbmV3IE5vZGUodHlwZU5hbWUsIGF0dHJzLCB2b2lkIDAsIHRhZyB8fCB2b2lkIDApO1xuICBjb25zdCB7IHBvc2l0aW9uID0ge30gfSA9IHRva2VuO1xuICBub2RlMi5lcnJvcnMgPSBlcnJvcnM7XG4gIGlmIChhZGRMb2NhdGlvbiAhPT0gZmFsc2UpIHtcbiAgICBub2RlMi5saW5lcyA9IHRva2VuLm1hcCB8fCBwYXJlbnQubGluZXMgfHwgW107XG4gICAgbm9kZTIubG9jYXRpb24gPSB7XG4gICAgICBmaWxlLFxuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgbGluZTogbm9kZTIubGluZXNbMF0sXG4gICAgICAgIGNoYXJhY3RlcjogcG9zaXRpb24uc3RhcnRcbiAgICAgIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgbGluZTogbm9kZTIubGluZXNbMV0sXG4gICAgICAgIGNoYXJhY3RlcjogcG9zaXRpb24uZW5kXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBpZiAoaW5saW5lUGFyZW50KVxuICAgIG5vZGUyLmlubGluZSA9IHRydWU7XG4gIGlmIChhdHRyaWJ1dGVzICYmIFtcInRhZ1wiLCBcImZlbmNlXCIsIFwiaW1hZ2VcIl0uaW5jbHVkZXModHlwZU5hbWUpKVxuICAgIGFubm90YXRlKG5vZGUyLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGhhbmRsZVNsb3RzICYmIHRhZyA9PT0gXCJzbG90XCIgJiYgdHlwZW9mIG5vZGUyLmF0dHJpYnV0ZXMucHJpbWFyeSA9PT0gXCJzdHJpbmdcIilcbiAgICBwYXJlbnQuc2xvdHNbbm9kZTIuYXR0cmlidXRlcy5wcmltYXJ5XSA9IG5vZGUyO1xuICBlbHNlXG4gICAgcGFyZW50LnB1c2gobm9kZTIpO1xuICBpZiAodG9rZW4ubmVzdGluZyA+IDApXG4gICAgbm9kZXMucHVzaChub2RlMik7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0b2tlbi5jaGlsZHJlbikpXG4gICAgcmV0dXJuO1xuICBpZiAobm9kZTIudHlwZSA9PT0gXCJpbmxpbmVcIilcbiAgICBpbmxpbmVQYXJlbnQgPSBwYXJlbnQ7XG4gIG5vZGVzLnB1c2gobm9kZTIpO1xuICBjb25zdCBpc0xlYWZOb2RlID0gdHlwZU5hbWUgPT09IFwiaW1hZ2VcIjtcbiAgaWYgKCFpc0xlYWZOb2RlKSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0b2tlbi5jaGlsZHJlbilcbiAgICAgIGhhbmRsZVRva2VuKGNoaWxkLCBub2RlcywgZmlsZSwgaGFuZGxlU2xvdHMsIGFkZExvY2F0aW9uLCBpbmxpbmVQYXJlbnQpO1xuICB9XG4gIG5vZGVzLnBvcCgpO1xufVxuZnVuY3Rpb24gcGFyc2VyKHRva2VucywgYXJncykge1xuICBjb25zdCBkb2MgPSBuZXcgTm9kZShcImRvY3VtZW50XCIpO1xuICBjb25zdCBub2RlcyA9IFtkb2NdO1xuICBpZiAodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpXG4gICAgYXJncyA9IHsgZmlsZTogYXJncyB9O1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2VucylcbiAgICBoYW5kbGVUb2tlbih0b2tlbiwgbm9kZXMsIGFyZ3M/LmZpbGUsIGFyZ3M/LnNsb3RzLCBhcmdzPy5sb2NhdGlvbik7XG4gIGlmIChub2Rlcy5sZW5ndGggPiAxKVxuICAgIGZvciAoY29uc3Qgbm9kZTIgb2Ygbm9kZXMuc2xpY2UoMSkpXG4gICAgICBub2RlMi5lcnJvcnMucHVzaCh7XG4gICAgICAgIGlkOiBcIm1pc3NpbmctY2xvc2luZ1wiLFxuICAgICAgICBsZXZlbDogXCJjcml0aWNhbFwiLFxuICAgICAgICBtZXNzYWdlOiBgTm9kZSAnJHtub2RlMi50YWcgfHwgbm9kZTIudHlwZX0nIGlzIG1pc3NpbmcgY2xvc2luZ2BcbiAgICAgIH0pO1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybTMgb2YgdHJhbnNmb3Jtc19kZWZhdWx0KVxuICAgIHRyYW5zZm9ybTMoZG9jKTtcbiAgcmV0dXJuIGRvYztcbn1cblxuLy8gc3JjL3NjaGVtYS50c1xudmFyIHNjaGVtYV9leHBvcnRzID0ge307XG5fX2V4cG9ydChzY2hlbWFfZXhwb3J0cywge1xuICBibG9ja3F1b3RlOiAoKSA9PiBibG9ja3F1b3RlLFxuICBjb2RlOiAoKSA9PiBjb2RlLFxuICBjb21tZW50OiAoKSA9PiBjb21tZW50LFxuICBkb2N1bWVudDogKCkgPT4gZG9jdW1lbnQsXG4gIGVtOiAoKSA9PiBlbSxcbiAgZXJyb3I6ICgpID0+IGVycm9yLFxuICBmZW5jZTogKCkgPT4gZmVuY2UsXG4gIGhhcmRicmVhazogKCkgPT4gaGFyZGJyZWFrLFxuICBoZWFkaW5nOiAoKSA9PiBoZWFkaW5nLFxuICBocjogKCkgPT4gaHIsXG4gIGltYWdlOiAoKSA9PiBpbWFnZSxcbiAgaW5saW5lOiAoKSA9PiBpbmxpbmUsXG4gIGl0ZW06ICgpID0+IGl0ZW0sXG4gIGxpbms6ICgpID0+IGxpbmssXG4gIGxpc3Q6ICgpID0+IGxpc3QsXG4gIG5vZGU6ICgpID0+IG5vZGUsXG4gIHBhcmFncmFwaDogKCkgPT4gcGFyYWdyYXBoLFxuICBzOiAoKSA9PiBzLFxuICBzb2Z0YnJlYWs6ICgpID0+IHNvZnRicmVhayxcbiAgc3Ryb25nOiAoKSA9PiBzdHJvbmcsXG4gIHRhYmxlOiAoKSA9PiB0YWJsZSxcbiAgdGJvZHk6ICgpID0+IHRib2R5LFxuICB0ZDogKCkgPT4gdGQsXG4gIHRleHQ6ICgpID0+IHRleHQsXG4gIHRoOiAoKSA9PiB0aCxcbiAgdGhlYWQ6ICgpID0+IHRoZWFkLFxuICB0cjogKCkgPT4gdHJcbn0pO1xudmFyIGRvY3VtZW50ID0ge1xuICByZW5kZXI6IFwiYXJ0aWNsZVwiLFxuICBjaGlsZHJlbjogW1xuICAgIFwiaGVhZGluZ1wiLFxuICAgIFwicGFyYWdyYXBoXCIsXG4gICAgXCJpbWFnZVwiLFxuICAgIFwidGFibGVcIixcbiAgICBcInRhZ1wiLFxuICAgIFwiZmVuY2VcIixcbiAgICBcImJsb2NrcXVvdGVcIixcbiAgICBcImNvbW1lbnRcIixcbiAgICBcImxpc3RcIixcbiAgICBcImhyXCJcbiAgXSxcbiAgYXR0cmlidXRlczoge1xuICAgIGZyb250bWF0dGVyOiB7IHJlbmRlcjogZmFsc2UgfVxuICB9XG59O1xudmFyIGhlYWRpbmcgPSB7XG4gIGNoaWxkcmVuOiBbXCJpbmxpbmVcIl0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBsZXZlbDogeyB0eXBlOiBOdW1iZXIsIHJlbmRlcjogZmFsc2UsIHJlcXVpcmVkOiB0cnVlIH1cbiAgfSxcbiAgdHJhbnNmb3JtKG5vZGUyLCBjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IFRhZyhgaCR7bm9kZTIuYXR0cmlidXRlc1tcImxldmVsXCJdfWAsIG5vZGUyLnRyYW5zZm9ybUF0dHJpYnV0ZXMoY29uZmlnKSwgbm9kZTIudHJhbnNmb3JtQ2hpbGRyZW4oY29uZmlnKSk7XG4gIH1cbn07XG52YXIgcGFyYWdyYXBoID0ge1xuICByZW5kZXI6IFwicFwiLFxuICBjaGlsZHJlbjogW1wiaW5saW5lXCJdXG59O1xudmFyIGltYWdlID0ge1xuICByZW5kZXI6IFwiaW1nXCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBzcmM6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgIGFsdDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICB0aXRsZTogeyB0eXBlOiBTdHJpbmcgfVxuICB9XG59O1xudmFyIGZlbmNlID0ge1xuICByZW5kZXI6IFwicHJlXCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBjb250ZW50OiB7IHR5cGU6IFN0cmluZywgcmVuZGVyOiBmYWxzZSwgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICBsYW5ndWFnZTogeyB0eXBlOiBTdHJpbmcsIHJlbmRlcjogXCJkYXRhLWxhbmd1YWdlXCIgfSxcbiAgICBwcm9jZXNzOiB7IHR5cGU6IEJvb2xlYW4sIHJlbmRlcjogZmFsc2UsIGRlZmF1bHQ6IHRydWUgfVxuICB9LFxuICB0cmFuc2Zvcm0obm9kZTIsIGNvbmZpZykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlMi50cmFuc2Zvcm1BdHRyaWJ1dGVzKGNvbmZpZyk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlMi5jaGlsZHJlbi5sZW5ndGggPyBub2RlMi50cmFuc2Zvcm1DaGlsZHJlbihjb25maWcpIDogW25vZGUyLmF0dHJpYnV0ZXMuY29udGVudF07XG4gICAgcmV0dXJuIG5ldyBUYWcoXCJwcmVcIiwgYXR0cmlidXRlcywgY2hpbGRyZW4pO1xuICB9XG59O1xudmFyIGJsb2NrcXVvdGUgPSB7XG4gIHJlbmRlcjogXCJibG9ja3F1b3RlXCIsXG4gIGNoaWxkcmVuOiBbXG4gICAgXCJoZWFkaW5nXCIsXG4gICAgXCJwYXJhZ3JhcGhcIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJ0YWJsZVwiLFxuICAgIFwidGFnXCIsXG4gICAgXCJmZW5jZVwiLFxuICAgIFwiYmxvY2txdW90ZVwiLFxuICAgIFwibGlzdFwiLFxuICAgIFwiaHJcIlxuICBdXG59O1xudmFyIGl0ZW0gPSB7XG4gIHJlbmRlcjogXCJsaVwiLFxuICBjaGlsZHJlbjogW1xuICAgIFwiaW5saW5lXCIsXG4gICAgXCJoZWFkaW5nXCIsXG4gICAgXCJwYXJhZ3JhcGhcIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJ0YWJsZVwiLFxuICAgIFwidGFnXCIsXG4gICAgXCJmZW5jZVwiLFxuICAgIFwiYmxvY2txdW90ZVwiLFxuICAgIFwibGlzdFwiLFxuICAgIFwiaHJcIlxuICBdXG59O1xudmFyIGxpc3QgPSB7XG4gIGNoaWxkcmVuOiBbXCJpdGVtXCJdLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgb3JkZXJlZDogeyB0eXBlOiBCb29sZWFuLCByZW5kZXI6IGZhbHNlLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgIHN0YXJ0OiB7IHR5cGU6IE51bWJlciB9LFxuICAgIG1hcmtlcjogeyB0eXBlOiBTdHJpbmcsIHJlbmRlcjogZmFsc2UgfVxuICB9LFxuICB0cmFuc2Zvcm0obm9kZTIsIGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgVGFnKG5vZGUyLmF0dHJpYnV0ZXMub3JkZXJlZCA/IFwib2xcIiA6IFwidWxcIiwgbm9kZTIudHJhbnNmb3JtQXR0cmlidXRlcyhjb25maWcpLCBub2RlMi50cmFuc2Zvcm1DaGlsZHJlbihjb25maWcpKTtcbiAgfVxufTtcbnZhciBociA9IHtcbiAgcmVuZGVyOiBcImhyXCJcbn07XG52YXIgdGFibGUgPSB7XG4gIHJlbmRlcjogXCJ0YWJsZVwiXG59O1xudmFyIHRkID0ge1xuICByZW5kZXI6IFwidGRcIixcbiAgY2hpbGRyZW46IFtcbiAgICBcImlubGluZVwiLFxuICAgIFwiaGVhZGluZ1wiLFxuICAgIFwicGFyYWdyYXBoXCIsXG4gICAgXCJpbWFnZVwiLFxuICAgIFwidGFibGVcIixcbiAgICBcInRhZ1wiLFxuICAgIFwiZmVuY2VcIixcbiAgICBcImJsb2NrcXVvdGVcIixcbiAgICBcImxpc3RcIixcbiAgICBcImhyXCJcbiAgXSxcbiAgYXR0cmlidXRlczoge1xuICAgIGFsaWduOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGNvbHNwYW46IHsgdHlwZTogTnVtYmVyLCByZW5kZXI6IFwiY29sU3BhblwiIH0sXG4gICAgcm93c3BhbjogeyB0eXBlOiBOdW1iZXIsIHJlbmRlcjogXCJyb3dTcGFuXCIgfVxuICB9XG59O1xudmFyIHRoID0ge1xuICByZW5kZXI6IFwidGhcIixcbiAgYXR0cmlidXRlczoge1xuICAgIHdpZHRoOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGFsaWduOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGNvbHNwYW46IHsgdHlwZTogTnVtYmVyLCByZW5kZXI6IFwiY29sU3BhblwiIH0sXG4gICAgcm93c3BhbjogeyB0eXBlOiBOdW1iZXIsIHJlbmRlcjogXCJyb3dTcGFuXCIgfVxuICB9XG59O1xudmFyIHRyID0ge1xuICByZW5kZXI6IFwidHJcIixcbiAgY2hpbGRyZW46IFtcInRoXCIsIFwidGRcIl1cbn07XG52YXIgdGJvZHkgPSB7XG4gIHJlbmRlcjogXCJ0Ym9keVwiLFxuICBjaGlsZHJlbjogW1widHJcIiwgXCJ0YWdcIl1cbn07XG52YXIgdGhlYWQgPSB7XG4gIHJlbmRlcjogXCJ0aGVhZFwiLFxuICBjaGlsZHJlbjogW1widHJcIl1cbn07XG52YXIgc3Ryb25nID0ge1xuICByZW5kZXI6IFwic3Ryb25nXCIsXG4gIGNoaWxkcmVuOiBbXCJlbVwiLCBcInNcIiwgXCJsaW5rXCIsIFwiY29kZVwiLCBcInRleHRcIiwgXCJ0YWdcIl0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBtYXJrZXI6IHsgdHlwZTogU3RyaW5nLCByZW5kZXI6IGZhbHNlIH1cbiAgfVxufTtcbnZhciBlbSA9IHtcbiAgcmVuZGVyOiBcImVtXCIsXG4gIGNoaWxkcmVuOiBbXCJzdHJvbmdcIiwgXCJzXCIsIFwibGlua1wiLCBcImNvZGVcIiwgXCJ0ZXh0XCIsIFwidGFnXCJdLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgbWFya2VyOiB7IHR5cGU6IFN0cmluZywgcmVuZGVyOiBmYWxzZSB9XG4gIH1cbn07XG52YXIgcyA9IHtcbiAgcmVuZGVyOiBcInNcIixcbiAgY2hpbGRyZW46IFtcInN0cm9uZ1wiLCBcImVtXCIsIFwibGlua1wiLCBcImNvZGVcIiwgXCJ0ZXh0XCIsIFwidGFnXCJdXG59O1xudmFyIGlubGluZSA9IHtcbiAgY2hpbGRyZW46IFtcbiAgICBcInN0cm9uZ1wiLFxuICAgIFwiZW1cIixcbiAgICBcInNcIixcbiAgICBcImNvZGVcIixcbiAgICBcInRleHRcIixcbiAgICBcInRhZ1wiLFxuICAgIFwibGlua1wiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcImhhcmRicmVha1wiLFxuICAgIFwic29mdGJyZWFrXCIsXG4gICAgXCJjb21tZW50XCJcbiAgXVxufTtcbnZhciBsaW5rID0ge1xuICByZW5kZXI6IFwiYVwiLFxuICBjaGlsZHJlbjogW1wic3Ryb25nXCIsIFwiZW1cIiwgXCJzXCIsIFwiY29kZVwiLCBcInRleHRcIiwgXCJ0YWdcIl0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBocmVmOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICB0aXRsZTogeyB0eXBlOiBTdHJpbmcgfVxuICB9XG59O1xudmFyIGNvZGUgPSB7XG4gIHJlbmRlcjogXCJjb2RlXCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBjb250ZW50OiB7IHR5cGU6IFN0cmluZywgcmVuZGVyOiBmYWxzZSwgcmVxdWlyZWQ6IHRydWUgfVxuICB9LFxuICB0cmFuc2Zvcm0obm9kZTIsIGNvbmZpZykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlMi50cmFuc2Zvcm1BdHRyaWJ1dGVzKGNvbmZpZyk7XG4gICAgcmV0dXJuIG5ldyBUYWcoXCJjb2RlXCIsIGF0dHJpYnV0ZXMsIFtub2RlMi5hdHRyaWJ1dGVzLmNvbnRlbnRdKTtcbiAgfVxufTtcbnZhciB0ZXh0ID0ge1xuICBhdHRyaWJ1dGVzOiB7XG4gICAgY29udGVudDogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH1cbiAgfSxcbiAgdHJhbnNmb3JtKG5vZGUyKSB7XG4gICAgcmV0dXJuIG5vZGUyLmF0dHJpYnV0ZXMuY29udGVudDtcbiAgfVxufTtcbnZhciBoYXJkYnJlYWsgPSB7XG4gIHJlbmRlcjogXCJiclwiXG59O1xudmFyIHNvZnRicmVhayA9IHtcbiAgdHJhbnNmb3JtKCkge1xuICAgIHJldHVybiBcIiBcIjtcbiAgfVxufTtcbnZhciBjb21tZW50ID0ge1xuICBhdHRyaWJ1dGVzOiB7XG4gICAgY29udGVudDogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH1cbiAgfVxufTtcbnZhciBlcnJvciA9IHt9O1xudmFyIG5vZGUgPSB7fTtcblxuLy8gc3JjL3JlbmRlcmVycy9odG1sLnRzXG52YXIgaW1wb3J0X21hcmtkb3duX2l0ID0gX190b01vZHVsZShyZXF1aXJlX21hcmtkb3duX2l0KCkpO1xudmFyIHsgZXNjYXBlSHRtbCB9ID0gKDAsIGltcG9ydF9tYXJrZG93bl9pdC5kZWZhdWx0KSgpLnV0aWxzO1xudmFyIHZvaWRFbGVtZW50cyA9IG5ldyBTZXQoW1xuICBcImFyZWFcIixcbiAgXCJiYXNlXCIsXG4gIFwiYnJcIixcbiAgXCJjb2xcIixcbiAgXCJlbWJlZFwiLFxuICBcImhyXCIsXG4gIFwiaW1nXCIsXG4gIFwiaW5wdXRcIixcbiAgXCJsaW5rXCIsXG4gIFwibWV0YVwiLFxuICBcInBhcmFtXCIsXG4gIFwic291cmNlXCIsXG4gIFwidHJhY2tcIixcbiAgXCJ3YnJcIlxuXSk7XG5mdW5jdGlvbiByZW5kZXIobm9kZTIpIHtcbiAgaWYgKHR5cGVvZiBub2RlMiA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygbm9kZTIgPT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGVzY2FwZUh0bWwoU3RyaW5nKG5vZGUyKSk7XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUyKSlcbiAgICByZXR1cm4gbm9kZTIubWFwKHJlbmRlcikuam9pbihcIlwiKTtcbiAgaWYgKG5vZGUyID09PSBudWxsIHx8IHR5cGVvZiBub2RlMiAhPT0gXCJvYmplY3RcIiB8fCAhVGFnLmlzVGFnKG5vZGUyKSlcbiAgICByZXR1cm4gXCJcIjtcbiAgY29uc3QgeyBuYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiA9IFtdIH0gPSBub2RlMjtcbiAgaWYgKCFuYW1lKVxuICAgIHJldHVybiByZW5kZXIoY2hpbGRyZW4pO1xuICBsZXQgb3V0cHV0ID0gYDwke25hbWV9YDtcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcyA/PyB7fSkpXG4gICAgb3V0cHV0ICs9IGAgJHtrLnRvTG93ZXJDYXNlKCl9PVwiJHtlc2NhcGVIdG1sKFN0cmluZyh2KSl9XCJgO1xuICBvdXRwdXQgKz0gXCI+XCI7XG4gIGlmICh2b2lkRWxlbWVudHMuaGFzKG5hbWUpKVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpXG4gICAgb3V0cHV0ICs9IHJlbmRlcihjaGlsZHJlbik7XG4gIG91dHB1dCArPSBgPC8ke25hbWV9PmA7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIHNyYy9yZW5kZXJlcnMvcmVhY3QvcmVhY3QudHNcbmZ1bmN0aW9uIHRhZ05hbWUobmFtZSwgY29tcG9uZW50cykge1xuICByZXR1cm4gdHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgPyBuYW1lIDogbmFtZVswXSAhPT0gbmFtZVswXS50b1VwcGVyQ2FzZSgpID8gbmFtZSA6IGNvbXBvbmVudHMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGNvbXBvbmVudHMobmFtZSkgOiBjb21wb25lbnRzW25hbWVdO1xufVxuZnVuY3Rpb24gZHluYW1pYyhub2RlMiwgUmVhY3QsIHsgY29tcG9uZW50cyA9IHt9LCByZXNvbHZlVGFnTmFtZSA9IHRhZ05hbWUgfSA9IHt9KSB7XG4gIGZ1bmN0aW9uIGRlZXBSZW5kZXIyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAoKGl0ZW0yKSA9PiBkZWVwUmVuZGVyMihpdGVtMikpO1xuICAgIGlmICh2YWx1ZS4kJG1kdHlwZSA9PT0gXCJUYWdcIilcbiAgICAgIHJldHVybiByZW5kZXIzKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSlcbiAgICAgIG91dHB1dFtrXSA9IGRlZXBSZW5kZXIyKHYpO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyMyhub2RlMykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUzKSlcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAuLi5ub2RlMy5tYXAocmVuZGVyMykpO1xuICAgIGlmIChub2RlMyA9PT0gbnVsbCB8fCB0eXBlb2Ygbm9kZTMgIT09IFwib2JqZWN0XCIgfHwgIVRhZy5pc1RhZyhub2RlMykpXG4gICAgICByZXR1cm4gbm9kZTM7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHsgY2xhc3M6IGNsYXNzTmFtZSwgLi4uYXR0cnMgfSA9IHt9LFxuICAgICAgY2hpbGRyZW4gPSBbXVxuICAgIH0gPSBub2RlMztcbiAgICBpZiAoY2xhc3NOYW1lKVxuICAgICAgYXR0cnMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHJlc29sdmVUYWdOYW1lKG5hbWUsIGNvbXBvbmVudHMpLCBPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoID09IDAgPyBudWxsIDogZGVlcFJlbmRlcjIoYXR0cnMpLCAuLi5jaGlsZHJlbi5tYXAocmVuZGVyMykpO1xuICB9XG4gIHJldHVybiByZW5kZXIzKG5vZGUyKTtcbn1cblxuLy8gc3JjL3JlbmRlcmVycy9yZWFjdC9zdGF0aWMudHNcbmZ1bmN0aW9uIHRhZ05hbWUyKG5hbWUsIGNvbXBvbmVudHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiID8gXCJGcmFnbWVudFwiIDogbmFtZVswXSAhPT0gbmFtZVswXS50b1VwcGVyQ2FzZSgpID8gbmFtZSA6IGNvbXBvbmVudHMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGNvbXBvbmVudHMobmFtZSkgOiBjb21wb25lbnRzW25hbWVdO1xufVxuZnVuY3Rpb24gcmVuZGVyQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGNoaWxkcmVuLm1hcChyZW5kZXIyKS5qb2luKFwiLCBcIik7XG59XG5mdW5jdGlvbiBkZWVwUmVuZGVyKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgcmV0dXJuIGBbJHt2YWx1ZS5tYXAoKGl0ZW0yKSA9PiBkZWVwUmVuZGVyKGl0ZW0yKSkuam9pbihcIiwgXCIpfV1gO1xuICBpZiAodmFsdWUuJCRtZHR5cGUgPT09IFwiVGFnXCIpXG4gICAgcmV0dXJuIHJlbmRlcjIodmFsdWUpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIGNvbnN0IG9iamVjdCA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoKFtrLCB2XSkgPT4gW0pTT04uc3RyaW5naWZ5KGspLCBkZWVwUmVuZGVyKHYpXS5qb2luKFwiOiBcIikpLmpvaW4oXCIsIFwiKTtcbiAgcmV0dXJuIGB7JHtvYmplY3R9fWA7XG59XG5mdW5jdGlvbiByZW5kZXIyKG5vZGUyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUyKSlcbiAgICByZXR1cm4gYFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsICR7cmVuZGVyQXJyYXkobm9kZTIpfSlgO1xuICBpZiAobm9kZTIgPT09IG51bGwgfHwgdHlwZW9mIG5vZGUyICE9PSBcIm9iamVjdFwiIHx8ICFUYWcuaXNUYWcobm9kZTIpKVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShub2RlMik7XG4gIGNvbnN0IHtcbiAgICBuYW1lLFxuICAgIGF0dHJpYnV0ZXM6IHsgY2xhc3M6IGNsYXNzTmFtZSwgLi4uYXR0cnMgfSA9IHt9LFxuICAgIGNoaWxkcmVuID0gW11cbiAgfSA9IG5vZGUyO1xuICBpZiAoY2xhc3NOYW1lKVxuICAgIGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgcmV0dXJuIGBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIHRhZ05hbWUoJHtKU09OLnN0cmluZ2lmeShuYW1lKX0sIGNvbXBvbmVudHMpLFxuICAgICR7T2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCA9PSAwID8gXCJudWxsXCIgOiBkZWVwUmVuZGVyKGF0dHJzKX0sXG4gICAgJHtyZW5kZXJBcnJheShjaGlsZHJlbil9KWA7XG59XG5mdW5jdGlvbiByZWFjdFN0YXRpYyhub2RlMiwgeyByZXNvbHZlVGFnTmFtZSA9IHRhZ05hbWUyIH0gPSB7fSkge1xuICBpZiAocmVzb2x2ZVRhZ05hbWUubmFtZSAhPT0gXCJ0YWdOYW1lXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXNvbHZlVGFnTmFtZSBtdXN0IGJlIG5hbWVkIHRhZ05hbWVcIik7XG4gIH1cbiAgcmV0dXJuIGBcbiAgKCh7Y29tcG9uZW50cyA9IHt9fSA9IHt9KSA9PiB7XG4gICAgJHtyZXNvbHZlVGFnTmFtZX1cbiAgICByZXR1cm4gJHtyZW5kZXIyKG5vZGUyKX07XG4gIH0pXG5gO1xufVxuXG4vLyBzcmMvcmVuZGVyZXJzL2luZGV4LnRzXG52YXIgcmVuZGVyZXJzX2RlZmF1bHQgPSB7IGh0bWw6IHJlbmRlciwgcmVhY3Q6IGR5bmFtaWMsIHJlYWN0U3RhdGljIH07XG5cbi8vIHNyYy90YWdzL3BhcnRpYWwudHNcbnZhciBQYXJ0aWFsRmlsZSA9IGNsYXNzIHtcbiAgdmFsaWRhdGUoZmlsZSwgY29uZmlnKSB7XG4gICAgY29uc3QgeyBwYXJ0aWFscyA9IHt9IH0gPSBjb25maWc7XG4gICAgY29uc3QgcGFydGlhbDIgPSBwYXJ0aWFsc1tmaWxlXTtcbiAgICBpZiAoIXBhcnRpYWwyKVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImF0dHJpYnV0ZS12YWx1ZS1pbnZhbGlkXCIsXG4gICAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiBgUGFydGlhbCBcXGAke2ZpbGV9XFxgIG5vdCBmb3VuZC4gVGhlICdmaWxlJyBhdHRyaWJ1dGUgbXVzdCBiZSBzZXQgaW4gXFxgY29uZmlnLnBhcnRpYWxzXFxgYFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcbnZhciBwYXJ0aWFsID0ge1xuICBpbmxpbmU6IGZhbHNlLFxuICBzZWxmQ2xvc2luZzogdHJ1ZSxcbiAgYXR0cmlidXRlczoge1xuICAgIGZpbGU6IHsgdHlwZTogUGFydGlhbEZpbGUsIHJlbmRlcjogZmFsc2UsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAgdmFyaWFibGVzOiB7IHR5cGU6IE9iamVjdCwgcmVuZGVyOiBmYWxzZSB9XG4gIH0sXG4gIHRyYW5zZm9ybShub2RlMiwgY29uZmlnKSB7XG4gICAgY29uc3QgeyBwYXJ0aWFscyA9IHt9IH0gPSBjb25maWc7XG4gICAgY29uc3QgeyBmaWxlLCB2YXJpYWJsZXMgfSA9IG5vZGUyLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgcGFydGlhbDIgPSBwYXJ0aWFsc1tmaWxlXTtcbiAgICBpZiAoIXBhcnRpYWwyKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qgc2NvcGVkQ29uZmlnID0ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgdmFyaWFibGVzOiB7XG4gICAgICAgIC4uLmNvbmZpZy52YXJpYWJsZXMsXG4gICAgICAgIC4uLnZhcmlhYmxlcyxcbiAgICAgICAgW1wiJCRwYXJ0aWFsOmZpbGVuYW1lXCJdOiBmaWxlXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0cmFuc2Zvcm1DaGlsZHJlbiA9IChwYXJ0KSA9PiBwYXJ0LnJlc29sdmUoc2NvcGVkQ29uZmlnKS50cmFuc2Zvcm1DaGlsZHJlbihzY29wZWRDb25maWcpO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBhcnRpYWwyKSA/IHBhcnRpYWwyLmZsYXRNYXAodHJhbnNmb3JtQ2hpbGRyZW4pIDogdHJhbnNmb3JtQ2hpbGRyZW4ocGFydGlhbDIpO1xuICB9XG59O1xuXG4vLyBzcmMvdGFncy90YWJsZS50c1xudmFyIHRhYmxlMiA9IHtcbiAgY2hpbGRyZW46IFtcInRhYmxlXCJdLFxuICBpbmxpbmU6IGZhbHNlXG59O1xuXG4vLyBzcmMvdGFncy9zbG90LnRzXG52YXIgc2xvdCA9IHtcbiAgYXR0cmlidXRlczoge1xuICAgIHByaW1hcnk6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9XG4gIH1cbn07XG5cbi8vIHNyYy90YWdzL2luZGV4LnRzXG52YXIgdGFnc19kZWZhdWx0ID0ge1xuICBlbHNlOiB0YWdFbHNlLFxuICBpZjogdGFnSWYsXG4gIHBhcnRpYWwsXG4gIHNsb3QsXG4gIHRhYmxlOiB0YWJsZTJcbn07XG5cbi8vIHNyYy90b2tlbml6ZXIvaW5kZXgudHNcbnZhciBpbXBvcnRfbGliID0gX190b01vZHVsZShyZXF1aXJlX2xpYigpKTtcblxuLy8gc3JjL3Rva2VuaXplci9wbHVnaW5zL2Fubm90YXRpb25zLnRzXG52YXIgaW1wb3J0X3RhZzcgPSBfX3RvTW9kdWxlKHJlcXVpcmVfdGFnKCkpO1xuZnVuY3Rpb24gY3JlYXRlVG9rZW4oc3RhdGUsIGNvbnRlbnQsIGNvbnRlbnRTdGFydCkge1xuICB0cnkge1xuICAgIGNvbnN0IHsgdHlwZSwgbWV0YSwgbmVzdGluZyA9IDAgfSA9ICgwLCBpbXBvcnRfdGFnNy5wYXJzZSkoY29udGVudCwgeyBWYXJpYWJsZSwgRnVuY3Rpb246IEZ1bmN0aW9uMiB9KTtcbiAgICBjb25zdCB0b2tlbiA9IHN0YXRlLnB1c2godHlwZSwgXCJcIiwgbmVzdGluZyk7XG4gICAgdG9rZW4uaW5mbyA9IGNvbnRlbnQ7XG4gICAgdG9rZW4ubWV0YSA9IG1ldGE7XG4gICAgaWYgKCFzdGF0ZS5kZWxpbWl0ZXJzKSB7XG4gICAgICBzdGF0ZS5kZWxpbWl0ZXJzID0gW107XG4gICAgfVxuICAgIHJldHVybiB0b2tlbjtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgaWYgKCEoZXJyb3IyIGluc3RhbmNlb2YgaW1wb3J0X3RhZzcuU3ludGF4RXJyb3IpKVxuICAgICAgdGhyb3cgZXJyb3IyO1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBsb2NhdGlvbjogeyBzdGFydCwgZW5kIH1cbiAgICB9ID0gZXJyb3IyO1xuICAgIGNvbnN0IGxvY2F0aW9uID0gY29udGVudFN0YXJ0ID8ge1xuICAgICAgc3RhcnQ6IHsgb2Zmc2V0OiBzdGFydC5vZmZzZXQgKyBjb250ZW50U3RhcnQgfSxcbiAgICAgIGVuZDogeyBvZmZzZXQ6IGVuZC5vZmZzZXQgKyBjb250ZW50U3RhcnQgfVxuICAgIH0gOiBudWxsO1xuICAgIGNvbnN0IHRva2VuID0gc3RhdGUucHVzaChcImVycm9yXCIsIFwiXCIsIDApO1xuICAgIHRva2VuLm1ldGEgPSB7IGVycm9yOiB7IG1lc3NhZ2UsIGxvY2F0aW9uIH0gfTtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cbn1cbmZ1bmN0aW9uIGJsb2NrKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICBjb25zdCBzdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gIGNvbnN0IGZpbmlzaCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuICBpZiAoIXN0YXRlLnNyYy5zdGFydHNXaXRoKE9QRU4sIHN0YXJ0KSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHRhZ0VuZCA9IGZpbmRUYWdFbmQoc3RhdGUuc3JjLCBzdGFydCk7XG4gIGNvbnN0IGxhc3RQb3NzaWJsZSA9IHN0YXRlLnNyYy5zbGljZSgwLCBmaW5pc2gpLnRyaW0oKS5sZW5ndGg7XG4gIGlmICghdGFnRW5kIHx8IHRhZ0VuZCA8IGxhc3RQb3NzaWJsZSAtIENMT1NFLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGNvbnRlbnRTdGFydCA9IHN0YXJ0ICsgT1BFTi5sZW5ndGg7XG4gIGNvbnN0IGNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UoY29udGVudFN0YXJ0LCB0YWdFbmQpLnRyaW0oKTtcbiAgY29uc3QgbGluZXMgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHRhZ0VuZCArIENMT1NFLmxlbmd0aCkuc3BsaXQoXCJcXG5cIikubGVuZ3RoO1xuICBpZiAoY29udGVudFswXSA9PT0gXCIkXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoc2lsZW50KVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCB0b2tlbiA9IGNyZWF0ZVRva2VuKHN0YXRlLCBjb250ZW50LCBjb250ZW50U3RhcnQpO1xuICB0b2tlbi5tYXAgPSBbc3RhcnRMaW5lLCBzdGFydExpbmUgKyBsaW5lc107XG4gIHN0YXRlLmxpbmUgKz0gbGluZXM7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaW5saW5lMihzdGF0ZSwgc2lsZW50KSB7XG4gIGlmICghc3RhdGUuc3JjLnN0YXJ0c1dpdGgoT1BFTiwgc3RhdGUucG9zKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHRhZ0VuZCA9IGZpbmRUYWdFbmQoc3RhdGUuc3JjLCBzdGF0ZS5wb3MpO1xuICBpZiAoIXRhZ0VuZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhdGUucG9zICsgT1BFTi5sZW5ndGgsIHRhZ0VuZCk7XG4gIGlmICghc2lsZW50KVxuICAgIGNyZWF0ZVRva2VuKHN0YXRlLCBjb250ZW50LnRyaW0oKSk7XG4gIHN0YXRlLnBvcyA9IHRhZ0VuZCArIENMT1NFLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb3JlKHN0YXRlKSB7XG4gIGxldCB0b2tlbjtcbiAgZm9yICh0b2tlbiBvZiBzdGF0ZS50b2tlbnMpIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gXCJmZW5jZVwiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHRva2VuLmluZm8uaW5jbHVkZXMoT1BFTikpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gdG9rZW4uaW5mby5pbmRleE9mKE9QRU4pO1xuICAgICAgY29uc3QgZW5kID0gZmluZFRhZ0VuZCh0b2tlbi5pbmZvLCBzdGFydCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gdG9rZW4uaW5mby5zbGljZShzdGFydCArIE9QRU4ubGVuZ3RoLCBlbmQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBtZXRhIH0gPSAoMCwgaW1wb3J0X3RhZzcucGFyc2UpKGNvbnRlbnQudHJpbSgpLCB7IFZhcmlhYmxlLCBGdW5jdGlvbjogRnVuY3Rpb24yIH0pO1xuICAgICAgICB0b2tlbi5tZXRhID0gbWV0YTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICBpZiAoIShlcnJvcjIgaW5zdGFuY2VvZiBpbXBvcnRfdGFnNy5TeW50YXhFcnJvcikpXG4gICAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgICBpZiAoIXRva2VuLmVycm9ycylcbiAgICAgICAgICB0b2tlbi5lcnJvcnMgPSBbXTtcbiAgICAgICAgdG9rZW4uZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGlkOiBcImZlbmNlLXRhZy1lcnJvclwiLFxuICAgICAgICAgIGxldmVsOiBcImVycm9yXCIsXG4gICAgICAgICAgbWVzc2FnZTogYFN5bnRheCBlcnJvciBpbiBmZW5jZSB0YWc6ICR7ZXJyb3IyLm1lc3NhZ2V9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRva2VuPy5tZXRhPy5hdHRyaWJ1dGVzPy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09IFwicHJvY2Vzc1wiICYmICFhdHRyLnZhbHVlKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIHRva2VuLmNoaWxkcmVuID0gcGFyc2VUYWdzKHRva2VuLmNvbnRlbnQsIHRva2VuLm1hcFswXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBsdWdpbihtZCkge1xuICBtZC5ibG9jay5ydWxlci5iZWZvcmUoXCJwYXJhZ3JhcGhcIiwgXCJhbm5vdGF0aW9uc1wiLCBibG9jaywge1xuICAgIGFsdDogW1wicGFyYWdyYXBoXCIsIFwiYmxvY2txdW90ZVwiXVxuICB9KTtcbiAgbWQuaW5saW5lLnJ1bGVyLnB1c2goXCJjb250YWluZXJzXCIsIGlubGluZTIpO1xuICBtZC5jb3JlLnJ1bGVyLnB1c2goXCJhbm5vdGF0aW9uc1wiLCBjb3JlKTtcbn1cblxuLy8gc3JjL3Rva2VuaXplci9wbHVnaW5zL2Zyb250bWF0dGVyLnRzXG52YXIgZmVuY2UyID0gXCItLS1cIjtcbmZ1bmN0aW9uIGdldExpbmUoc3RhdGUsIG4pIHtcbiAgcmV0dXJuIHN0YXRlLnNyYy5zbGljZShzdGF0ZS5iTWFya3Nbbl0sIHN0YXRlLmVNYXJrc1tuXSkudHJpbSgpO1xufVxuZnVuY3Rpb24gZmluZENsb3NlKHN0YXRlLCBlbmRMaW5lKSB7XG4gIGZvciAobGV0IGxpbmUgPSAxOyBsaW5lIDwgZW5kTGluZTsgbGluZSsrKVxuICAgIGlmIChnZXRMaW5lKHN0YXRlLCBsaW5lKSA9PT0gZmVuY2UyKVxuICAgICAgcmV0dXJuIGxpbmU7XG59XG5mdW5jdGlvbiBibG9jazIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIGlmIChzdGFydExpbmUgIT0gMCB8fCBnZXRMaW5lKHN0YXRlLCAwKSAhPSBmZW5jZTIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBjbG9zZSA9IGZpbmRDbG9zZShzdGF0ZSwgZW5kTGluZSk7XG4gIGlmICghY2xvc2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoc2lsZW50KVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCB0b2tlbiA9IHN0YXRlLnB1c2goXCJmcm9udG1hdHRlclwiLCBcIlwiLCAwKTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShzdGF0ZS5lTWFya3NbMF0sIHN0YXRlLmJNYXJrc1tjbG9zZV0pLnRyaW0oKTtcbiAgdG9rZW4ubWFwID0gWzAsIGNsb3NlXTtcbiAgdG9rZW4uaGlkZGVuID0gdHJ1ZTtcbiAgc3RhdGUubGluZSA9IGNsb3NlICsgMTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBwbHVnaW4yKG1kKSB7XG4gIG1kLmJsb2NrLnJ1bGVyLmJlZm9yZShcImhyXCIsIFwiZnJvbnRtYXR0ZXJcIiwgYmxvY2syKTtcbn1cblxuLy8gc3JjL3Rva2VuaXplci9wbHVnaW5zL2NvbW1lbnRzLnRzXG52YXIgT1BFTjIgPSBcIjwhLS1cIjtcbnZhciBDTE9TRTIgPSBcIi0tPlwiO1xuZnVuY3Rpb24gYmxvY2szKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICBjb25zdCBzdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gIGlmICghc3RhdGUuc3JjLnN0YXJ0c1dpdGgoT1BFTjIsIHN0YXJ0KSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGNsb3NlID0gc3RhdGUuc3JjLmluZGV4T2YoQ0xPU0UyLCBzdGFydCk7XG4gIGlmIChjbG9zZSA9PT0gLTEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoc2lsZW50KVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCBjb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0ICsgT1BFTjIubGVuZ3RoLCBjbG9zZSk7XG4gIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdChcIlxcblwiKS5sZW5ndGg7XG4gIGNvbnN0IHRva2VuID0gc3RhdGUucHVzaChcImNvbW1lbnRcIiwgXCJcIiwgMCk7XG4gIHRva2VuLmNvbnRlbnQgPSBjb250ZW50LnRyaW0oKTtcbiAgdG9rZW4ubWFwID0gW3N0YXJ0TGluZSwgc3RhcnRMaW5lICsgbGluZXNdO1xuICBzdGF0ZS5saW5lICs9IGxpbmVzO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlubGluZTMoc3RhdGUsIHNpbGVudCkge1xuICBpZiAoIXN0YXRlLnNyYy5zdGFydHNXaXRoKE9QRU4yLCBzdGF0ZS5wb3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgY2xvc2UgPSBzdGF0ZS5zcmMuaW5kZXhPZihDTE9TRTIsIHN0YXRlLnBvcyk7XG4gIGlmIChjbG9zZSA9PT0gLTEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoc2lsZW50KVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCBjb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHN0YXRlLnBvcyArIE9QRU4yLmxlbmd0aCwgY2xvc2UpO1xuICBjb25zdCB0b2tlbiA9IHN0YXRlLnB1c2goXCJjb21tZW50XCIsIFwiXCIsIDApO1xuICB0b2tlbi5jb250ZW50ID0gY29udGVudC50cmltKCk7XG4gIHN0YXRlLnBvcyA9IGNsb3NlICsgQ0xPU0UyLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBwbHVnaW4zKG1kKSB7XG4gIG1kLmJsb2NrLnJ1bGVyLmJlZm9yZShcInRhYmxlXCIsIFwiY29tbWVudFwiLCBibG9jazMsIHsgYWx0OiBbXCJwYXJhZ3JhcGhcIl0gfSk7XG4gIG1kLmlubGluZS5ydWxlci5wdXNoKFwiY29tbWVudFwiLCBpbmxpbmUzKTtcbn1cblxuLy8gc3JjL3Rva2VuaXplci9pbmRleC50c1xudmFyIFRva2VuaXplciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICB0aGlzLnBhcnNlciA9IG5ldyBpbXBvcnRfbGliLmRlZmF1bHQoY29uZmlnKTtcbiAgICB0aGlzLnBhcnNlci51c2UocGx1Z2luLCBcImFubm90YXRpb25zXCIsIHt9KTtcbiAgICB0aGlzLnBhcnNlci51c2UocGx1Z2luMiwgXCJmcm9udG1hdHRlclwiLCB7fSk7XG4gICAgdGhpcy5wYXJzZXIuZGlzYWJsZShbXG4gICAgICBcImxoZWFkaW5nXCIsXG4gICAgICBcImNvZGVcIlxuICAgIF0pO1xuICAgIGlmIChjb25maWcuYWxsb3dDb21tZW50cylcbiAgICAgIHRoaXMucGFyc2VyLnVzZShwbHVnaW4zLCBcImNvbW1lbnRzXCIsIHt9KTtcbiAgfVxuICB0b2tlbml6ZShjb250ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VyLnBhcnNlKGNvbnRlbnQudG9TdHJpbmcoKSwge30pO1xuICB9XG59O1xuXG4vLyBzcmMvdmFsaWRhdG9yLnRzXG52YXIgVHlwZU1hcHBpbmdzID0ge1xuICBTdHJpbmcsXG4gIE51bWJlcixcbiAgQXJyYXksXG4gIE9iamVjdCxcbiAgQm9vbGVhblxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZSh0eXBlLCB2YWx1ZSwgY29uZmlnLCBrZXkpIHtcbiAgaWYgKCF0eXBlKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoYXN0X2RlZmF1bHQuaXNGdW5jdGlvbih2YWx1ZSkgJiYgY29uZmlnLnZhbGlkYXRpb24/LnZhbGlkYXRlRnVuY3Rpb25zKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gY29uZmlnLmZ1bmN0aW9ucz8uW3ZhbHVlLm5hbWVdO1xuICAgIHJldHVybiAhc2NoZW1hPy5yZXR1cm5zID8gdHJ1ZSA6IEFycmF5LmlzQXJyYXkoc2NoZW1hLnJldHVybnMpID8gc2NoZW1hLnJldHVybnMuZmluZCgodCkgPT4gdCA9PT0gdHlwZSkgIT09IHZvaWQgMCA6IHNjaGVtYS5yZXR1cm5zID09PSB0eXBlO1xuICB9XG4gIGlmIChhc3RfZGVmYXVsdC5pc0FzdCh2YWx1ZSkpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKVxuICAgIHJldHVybiB0eXBlLnNvbWUoKHQpID0+IHZhbGlkYXRlVHlwZSh0LCB2YWx1ZSwgY29uZmlnLCBrZXkpKTtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiKVxuICAgIHR5cGUgPSBUeXBlTWFwcGluZ3NbdHlwZV07XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgdHlwZSgpO1xuICAgIGlmIChpbnN0YW5jZS52YWxpZGF0ZSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnZhbGlkYXRlKHZhbHVlLCBjb25maWcsIGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSB0eXBlO1xufVxuZnVuY3Rpb24gdHlwZVRvU3RyaW5nKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB0eXBlO1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSlcbiAgICByZXR1cm4gdHlwZS5tYXAodHlwZVRvU3RyaW5nKS5qb2luKFwiIHwgXCIpO1xuICByZXR1cm4gdHlwZS5uYW1lO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbihmbiwgY29uZmlnKSB7XG4gIGNvbnN0IHNjaGVtYSA9IGNvbmZpZy5mdW5jdGlvbnM/Lltmbi5uYW1lXTtcbiAgY29uc3QgZXJyb3JzID0gW107XG4gIGlmICghc2NoZW1hKVxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImZ1bmN0aW9uLXVuZGVmaW5lZFwiLFxuICAgICAgICBsZXZlbDogXCJjcml0aWNhbFwiLFxuICAgICAgICBtZXNzYWdlOiBgVW5kZWZpbmVkIGZ1bmN0aW9uOiAnJHtmbi5uYW1lfSdgXG4gICAgICB9XG4gICAgXTtcbiAgaWYgKHNjaGVtYS52YWxpZGF0ZSlcbiAgICBlcnJvcnMucHVzaCguLi5zY2hlbWEudmFsaWRhdGUoZm4sIGNvbmZpZykpO1xuICBpZiAoc2NoZW1hLnBhcmFtZXRlcnMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmbi5wYXJhbWV0ZXJzKSkge1xuICAgICAgY29uc3QgcGFyYW0gPSBzY2hlbWEucGFyYW1ldGVycz8uW2tleV07XG4gICAgICBpZiAoIXBhcmFtKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICBpZDogXCJwYXJhbWV0ZXItdW5kZWZpbmVkXCIsXG4gICAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBwYXJhbWV0ZXI6ICcke2tleX0nYFxuICAgICAgICB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYXN0X2RlZmF1bHQuaXNBc3QodmFsdWUpICYmICFhc3RfZGVmYXVsdC5pc0Z1bmN0aW9uKHZhbHVlKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAocGFyYW0udHlwZSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IHZhbGlkYXRlVHlwZShwYXJhbS50eXBlLCB2YWx1ZSwgY29uZmlnLCBrZXkpO1xuICAgICAgICBpZiAodmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IFwicGFyYW1ldGVyLXR5cGUtaW52YWxpZFwiLFxuICAgICAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBQYXJhbWV0ZXIgJyR7a2V5fScgb2YgJyR7Zm4ubmFtZX0nIG11c3QgYmUgdHlwZSBvZiAnJHt0eXBlVG9TdHJpbmcocGFyYW0udHlwZSl9J2BcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbGlkKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnZhbGlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHsgcmVxdWlyZWQgfV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnBhcmFtZXRlcnMgPz8ge30pKVxuICAgIGlmIChyZXF1aXJlZCAmJiBmbi5wYXJhbWV0ZXJzW2tleV0gPT09IHZvaWQgMClcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgaWQ6IFwicGFyYW1ldGVyLW1pc3NpbmctcmVxdWlyZWRcIixcbiAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogYE1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiAnJHtrZXl9J2BcbiAgICAgIH0pO1xuICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gZGlzcGxheU1hdGNoZXMobWF0Y2hlcywgbikge1xuICBpZiAobWF0Y2hlcy5sZW5ndGggPD0gbilcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobWF0Y2hlcyk7XG4gIGNvbnN0IGl0ZW1zID0gbWF0Y2hlcy5zbGljZSgwLCBuKS5tYXAoKGl0ZW0yKSA9PiBKU09OLnN0cmluZ2lmeShpdGVtMikpO1xuICByZXR1cm4gYFske2l0ZW1zLmpvaW4oXCIsXCIpfSwgLi4uICR7bWF0Y2hlcy5sZW5ndGggLSBufSBtb3JlXWA7XG59XG5mdW5jdGlvbiB2YWxpZGF0b3Iobm9kZTIsIGNvbmZpZykge1xuICBjb25zdCBzY2hlbWEgPSBub2RlMi5maW5kU2NoZW1hKGNvbmZpZyk7XG4gIGNvbnN0IGVycm9ycyA9IFsuLi5ub2RlMi5lcnJvcnMgfHwgW11dO1xuICBpZiAoIXNjaGVtYSkge1xuICAgIGVycm9ycy5wdXNoKHtcbiAgICAgIGlkOiBub2RlMi50YWcgPyBcInRhZy11bmRlZmluZWRcIiA6IFwibm9kZS11bmRlZmluZWRcIixcbiAgICAgIGxldmVsOiBcImNyaXRpY2FsXCIsXG4gICAgICBtZXNzYWdlOiBub2RlMi50YWcgPyBgVW5kZWZpbmVkIHRhZzogJyR7bm9kZTIudGFnfSdgIDogYFVuZGVmaW5lZCBub2RlOiAnJHtub2RlMi50eXBlfSdgXG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbiAgfVxuICBpZiAoc2NoZW1hLmlubGluZSAhPSB2b2lkIDAgJiYgbm9kZTIuaW5saW5lICE9PSBzY2hlbWEuaW5saW5lKVxuICAgIGVycm9ycy5wdXNoKHtcbiAgICAgIGlkOiBcInRhZy1wbGFjZW1lbnQtaW52YWxpZFwiLFxuICAgICAgbGV2ZWw6IFwiY3JpdGljYWxcIixcbiAgICAgIG1lc3NhZ2U6IGAnJHtub2RlMi50YWd9JyB0YWcgc2hvdWxkIGJlICR7c2NoZW1hLmlubGluZSA/IFwiaW5saW5lXCIgOiBcImJsb2NrXCJ9YFxuICAgIH0pO1xuICBpZiAoc2NoZW1hLnNlbGZDbG9zaW5nICYmIG5vZGUyLmNoaWxkcmVuLmxlbmd0aCA+IDApXG4gICAgZXJyb3JzLnB1c2goe1xuICAgICAgaWQ6IFwidGFnLXNlbGZjbG9zaW5nLWhhcy1jaGlsZHJlblwiLFxuICAgICAgbGV2ZWw6IFwiY3JpdGljYWxcIixcbiAgICAgIG1lc3NhZ2U6IGAnJHtub2RlMi50YWd9JyB0YWcgc2hvdWxkIGJlIHNlbGYtY2xvc2luZ2BcbiAgICB9KTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAuLi5nbG9iYWxBdHRyaWJ1dGVzLFxuICAgIC4uLnNjaGVtYS5hdHRyaWJ1dGVzXG4gIH07XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG5vZGUyLnNsb3RzKSkge1xuICAgIGNvbnN0IHNsb3QyID0gc2NoZW1hLnNsb3RzPy5ba2V5XTtcbiAgICBpZiAoIXNsb3QyKVxuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICBpZDogXCJzbG90LXVuZGVmaW5lZFwiLFxuICAgICAgICBsZXZlbDogXCJlcnJvclwiLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBzbG90OiAnJHtrZXl9J2BcbiAgICAgIH0pO1xuICB9XG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub2RlMi5hdHRyaWJ1dGVzKSkge1xuICAgIGNvbnN0IGF0dHJpYiA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICBpZiAoIWF0dHJpYikge1xuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICBpZDogXCJhdHRyaWJ1dGUtdW5kZWZpbmVkXCIsXG4gICAgICAgIGxldmVsOiBcImVycm9yXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGF0dHJpYnV0ZTogJyR7a2V5fSdgXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgeyB0eXBlLCBtYXRjaGVzLCBlcnJvckxldmVsIH0gPSBhdHRyaWI7XG4gICAgaWYgKGFzdF9kZWZhdWx0LmlzQXN0KHZhbHVlKSkge1xuICAgICAgaWYgKGFzdF9kZWZhdWx0LmlzRnVuY3Rpb24odmFsdWUpICYmIGNvbmZpZy52YWxpZGF0aW9uPy52YWxpZGF0ZUZ1bmN0aW9ucylcbiAgICAgICAgZXJyb3JzLnB1c2goLi4udmFsaWRhdGVGdW5jdGlvbih2YWx1ZSwgY29uZmlnKSk7XG4gICAgICBlbHNlIGlmIChhc3RfZGVmYXVsdC5pc1ZhcmlhYmxlKHZhbHVlKSAmJiBjb25maWcudmFyaWFibGVzKSB7XG4gICAgICAgIGxldCBtaXNzaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCB2YXJpYWJsZXMgPSBjb25maWcudmFyaWFibGVzO1xuICAgICAgICBmb3IgKGNvbnN0IGtleTIgb2YgdmFsdWUucGF0aCkge1xuICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhcmlhYmxlcywga2V5MikpIHtcbiAgICAgICAgICAgIG1pc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhcmlhYmxlcyA9IHZhcmlhYmxlc1trZXkyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlzc2luZykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBcInZhcmlhYmxlLXVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBVbmRlZmluZWQgdmFyaWFibGU6ICcke3ZhbHVlLnBhdGguam9pbihcIi5cIil9J2BcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHZhbGlkYXRlVHlwZSh0eXBlLCB2YWx1ZSwgY29uZmlnLCBrZXkpO1xuICAgICAgaWYgKHZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgaWQ6IFwiYXR0cmlidXRlLXR5cGUtaW52YWxpZFwiLFxuICAgICAgICAgIGxldmVsOiBlcnJvckxldmVsIHx8IFwiZXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiBgQXR0cmlidXRlICcke2tleX0nIG11c3QgYmUgdHlwZSBvZiAnJHt0eXBlVG9TdHJpbmcodHlwZSl9J2BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZCkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4udmFsaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG1hdGNoZXMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIG1hdGNoZXMgPSBtYXRjaGVzKGNvbmZpZyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0Y2hlcykgJiYgIW1hdGNoZXMuaW5jbHVkZXModmFsdWUpKVxuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICBpZDogXCJhdHRyaWJ1dGUtdmFsdWUtaW52YWxpZFwiLFxuICAgICAgICBsZXZlbDogZXJyb3JMZXZlbCB8fCBcImVycm9yXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBBdHRyaWJ1dGUgJyR7a2V5fScgbXVzdCBtYXRjaCBvbmUgb2YgJHtkaXNwbGF5TWF0Y2hlcyhtYXRjaGVzLCA4KX0uIEdvdCAnJHt2YWx1ZX0nIGluc3RlYWQuYFxuICAgICAgfSk7XG4gICAgaWYgKG1hdGNoZXMgaW5zdGFuY2VvZiBSZWdFeHAgJiYgIW1hdGNoZXMudGVzdCh2YWx1ZSkpXG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIGlkOiBcImF0dHJpYnV0ZS12YWx1ZS1pbnZhbGlkXCIsXG4gICAgICAgIGxldmVsOiBlcnJvckxldmVsIHx8IFwiZXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogYEF0dHJpYnV0ZSAnJHtrZXl9JyBtdXN0IG1hdGNoICR7bWF0Y2hlc30uIEdvdCAnJHt2YWx1ZX0nIGluc3RlYWQuYFxuICAgICAgfSk7XG4gICAgaWYgKHR5cGVvZiBhdHRyaWIudmFsaWRhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgYXR0cmliRXJyb3JzID0gYXR0cmliLnZhbGlkYXRlKHZhbHVlLCBjb25maWcsIGtleSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyaWJFcnJvcnMpKVxuICAgICAgICBlcnJvcnMucHVzaCguLi5hdHRyaWJFcnJvcnMpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHsgcmVxdWlyZWQgfV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpXG4gICAgaWYgKHJlcXVpcmVkICYmIG5vZGUyLmF0dHJpYnV0ZXNba2V5XSA9PT0gdm9pZCAwKVxuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICBpZDogXCJhdHRyaWJ1dGUtbWlzc2luZy1yZXF1aXJlZFwiLFxuICAgICAgICBsZXZlbDogXCJlcnJvclwiLFxuICAgICAgICBtZXNzYWdlOiBgTWlzc2luZyByZXF1aXJlZCBhdHRyaWJ1dGU6ICcke2tleX0nYFxuICAgICAgfSk7XG4gIGlmIChzY2hlbWEuc2xvdHMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHsgcmVxdWlyZWQgfV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnNsb3RzKSlcbiAgICAgIGlmIChyZXF1aXJlZCAmJiBub2RlMi5zbG90c1trZXldID09PSB2b2lkIDApXG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICBpZDogXCJzbG90LW1pc3NpbmctcmVxdWlyZWRcIixcbiAgICAgICAgICBsZXZlbDogXCJlcnJvclwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGBNaXNzaW5nIHJlcXVpcmVkIHNsb3Q6ICcke2tleX0nYFxuICAgICAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IHsgdHlwZSB9IG9mIG5vZGUyLmNoaWxkcmVuKSB7XG4gICAgaWYgKHNjaGVtYS5jaGlsZHJlbiAmJiB0eXBlICE9PSBcImVycm9yXCIgJiYgIXNjaGVtYS5jaGlsZHJlbi5pbmNsdWRlcyh0eXBlKSlcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgaWQ6IFwiY2hpbGQtaW52YWxpZFwiLFxuICAgICAgICBsZXZlbDogXCJ3YXJuaW5nXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBDYW4ndCBuZXN0ICcke3R5cGV9JyBpbiAnJHtub2RlMi50YWcgfHwgbm9kZTIudHlwZX0nYFxuICAgICAgfSk7XG4gIH1cbiAgaWYgKHNjaGVtYS52YWxpZGF0ZSkge1xuICAgIGNvbnN0IHNjaGVtYUVycm9ycyA9IHNjaGVtYS52YWxpZGF0ZShub2RlMiwgY29uZmlnKTtcbiAgICBpZiAoaXNQcm9taXNlKHNjaGVtYUVycm9ycykpIHtcbiAgICAgIHJldHVybiBzY2hlbWFFcnJvcnMudGhlbigoZSkgPT4gZXJyb3JzLmNvbmNhdChlKSk7XG4gICAgfVxuICAgIGVycm9ycy5wdXNoKC4uLnNjaGVtYUVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uKiB3YWxrV2l0aFBhcmVudHMobm9kZTIsIHBhcmVudHMgPSBbXSkge1xuICB5aWVsZCBbbm9kZTIsIHBhcmVudHNdO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIFsuLi5PYmplY3QudmFsdWVzKG5vZGUyLnNsb3RzKSwgLi4ubm9kZTIuY2hpbGRyZW5dKVxuICAgIHlpZWxkKiB3YWxrV2l0aFBhcmVudHMoY2hpbGQsIFsuLi5wYXJlbnRzLCBub2RlMl0pO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVUcmVlKGNvbnRlbnQsIGNvbmZpZykge1xuICBjb25zdCBvdXRwdXQgPSBbLi4ud2Fsa1dpdGhQYXJlbnRzKGNvbnRlbnQpXS5tYXAoKFtub2RlMiwgcGFyZW50c10pID0+IHtcbiAgICBjb25zdCB7IHR5cGUsIGxpbmVzLCBsb2NhdGlvbiB9ID0gbm9kZTI7XG4gICAgY29uc3QgdXBkYXRlZENvbmZpZyA9IHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIHZhbGlkYXRpb246IHsgLi4uY29uZmlnLnZhbGlkYXRpb24sIHBhcmVudHMgfVxuICAgIH07XG4gICAgY29uc3QgZXJyb3JzID0gdmFsaWRhdG9yKG5vZGUyLCB1cGRhdGVkQ29uZmlnKTtcbiAgICBpZiAoaXNQcm9taXNlKGVycm9ycykpIHtcbiAgICAgIHJldHVybiBlcnJvcnMudGhlbigoZSkgPT4gZS5tYXAoKGVycm9yMikgPT4gKHsgdHlwZSwgbGluZXMsIGxvY2F0aW9uLCBlcnJvcjogZXJyb3IyIH0pKSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnMubWFwKChlcnJvcjIpID0+ICh7IHR5cGUsIGxpbmVzLCBsb2NhdGlvbiwgZXJyb3I6IGVycm9yMiB9KSk7XG4gIH0pO1xuICBpZiAob3V0cHV0LnNvbWUoaXNQcm9taXNlKSkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChvdXRwdXQpLnRoZW4oKG8pID0+IG8uZmxhdCgpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmZsYXQoKTtcbn1cblxuLy8gaW5kZXgudHNcbnZhciB0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKCk7XG5mdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcgPSB7fSkge1xuICByZXR1cm4ge1xuICAgIC4uLmNvbmZpZyxcbiAgICB0YWdzOiB7XG4gICAgICAuLi50YWdzX2RlZmF1bHQsXG4gICAgICAuLi5jb25maWcudGFnc1xuICAgIH0sXG4gICAgbm9kZXM6IHtcbiAgICAgIC4uLnNjaGVtYV9leHBvcnRzLFxuICAgICAgLi4uY29uZmlnLm5vZGVzXG4gICAgfSxcbiAgICBmdW5jdGlvbnM6IHtcbiAgICAgIC4uLmZ1bmN0aW9uc19kZWZhdWx0LFxuICAgICAgLi4uY29uZmlnLmZ1bmN0aW9uc1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlMyhjb250ZW50LCBhcmdzKSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICBjb250ZW50ID0gdG9rZW5pemVyLnRva2VuaXplKGNvbnRlbnQpO1xuICByZXR1cm4gcGFyc2VyKGNvbnRlbnQsIGFyZ3MpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZTIoY29udGVudCwgY29uZmlnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpKVxuICAgIHJldHVybiBjb250ZW50LmZsYXRNYXAoKGNoaWxkKSA9PiBjaGlsZC5yZXNvbHZlKGNvbmZpZykpO1xuICByZXR1cm4gY29udGVudC5yZXNvbHZlKGNvbmZpZyk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0yKG5vZGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbmZpZyA9IG1lcmdlQ29uZmlnKG9wdGlvbnMpO1xuICBjb25zdCBjb250ZW50ID0gcmVzb2x2ZTIobm9kZXMsIGNvbmZpZyk7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpKVxuICAgIHJldHVybiBjb250ZW50LmZsYXRNYXAoKGNoaWxkKSA9PiBjaGlsZC50cmFuc2Zvcm0oY29uZmlnKSk7XG4gIHJldHVybiBjb250ZW50LnRyYW5zZm9ybShjb25maWcpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUoY29udGVudCwgb3B0aW9ucykge1xuICBjb25zdCBjb25maWcgPSBtZXJnZUNvbmZpZyhvcHRpb25zKTtcbiAgcmV0dXJuIHZhbGlkYXRlVHJlZShjb250ZW50LCBjb25maWcpO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzID0ge30sIC4uLmNoaWxkcmVuKSB7XG4gIHJldHVybiB7IG5hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuIH07XG59XG52YXIgTWFya2RvYyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5wYXJzZSA9IHBhcnNlMztcbiAgICB0aGlzLnJlc29sdmUgPSAoY29udGVudCkgPT4gcmVzb2x2ZTIoY29udGVudCwgdGhpcy5jb25maWcpO1xuICAgIHRoaXMudHJhbnNmb3JtID0gKGNvbnRlbnQpID0+IHRyYW5zZm9ybTIoY29udGVudCwgdGhpcy5jb25maWcpO1xuICAgIHRoaXMudmFsaWRhdGUgPSAoY29udGVudCkgPT4gdmFsaWRhdGUoY29udGVudCwgdGhpcy5jb25maWcpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG59O1xuTWFya2RvYy5ub2RlcyA9IHNjaGVtYV9leHBvcnRzO1xuTWFya2RvYy50YWdzID0gdGFnc19kZWZhdWx0O1xuTWFya2RvYy5mdW5jdGlvbnMgPSBmdW5jdGlvbnNfZGVmYXVsdDtcbk1hcmtkb2MuZ2xvYmFsQXR0cmlidXRlcyA9IGdsb2JhbEF0dHJpYnV0ZXM7XG5NYXJrZG9jLnJlbmRlcmVycyA9IHJlbmRlcmVyc19kZWZhdWx0O1xuTWFya2RvYy50cmFuc2Zvcm1zID0gdHJhbnNmb3Jtc19kZWZhdWx0O1xuTWFya2RvYy5Bc3QgPSBhc3RfZGVmYXVsdDtcbk1hcmtkb2MuVGFnID0gVGFnO1xuTWFya2RvYy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5NYXJrZG9jLnBhcnNlVGFncyA9IHBhcnNlVGFncztcbk1hcmtkb2MudHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcl9kZWZhdWx0O1xuTWFya2RvYy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG5NYXJrZG9jLnBhcnNlID0gcGFyc2UzO1xuTWFya2RvYy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm0yO1xuTWFya2RvYy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuTWFya2RvYy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbk1hcmtkb2MudHJ1dGh5ID0gdHJ1dGh5O1xuTWFya2RvYy5mb3JtYXQgPSBmb3JtYXQ7XG5leHBvcnQge1xuICBhc3RfZGVmYXVsdCBhcyBBc3QsXG4gIE5vZGUsXG4gIFRhZyxcbiAgVG9rZW5pemVyLFxuICBjcmVhdGVFbGVtZW50LFxuICBNYXJrZG9jIGFzIGRlZmF1bHQsXG4gIGZvcm1hdCxcbiAgZnVuY3Rpb25zX2RlZmF1bHQgYXMgZnVuY3Rpb25zLFxuICBnbG9iYWxBdHRyaWJ1dGVzLFxuICBzY2hlbWFfZXhwb3J0cyBhcyBub2RlcyxcbiAgcGFyc2UzIGFzIHBhcnNlLFxuICBwYXJzZVRhZ3MsXG4gIHJlbmRlcmVyc19kZWZhdWx0IGFzIHJlbmRlcmVycyxcbiAgcmVzb2x2ZTIgYXMgcmVzb2x2ZSxcbiAgdGFnc19kZWZhdWx0IGFzIHRhZ3MsXG4gIHRyYW5zZm9ybTIgYXMgdHJhbnNmb3JtLFxuICB0cmFuc2Zvcm1lcl9kZWZhdWx0IGFzIHRyYW5zZm9ybWVyLFxuICB0cmFuc2Zvcm1zX2RlZmF1bHQgYXMgdHJhbnNmb3JtcyxcbiAgdHJ1dGh5LFxuICB2YWxpZGF0ZSxcbiAgdmFsaWRhdG9yXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@markdoc/markdoc/dist/index.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@markdoc/next.js/src/runtime.js":
/*!******************************************************!*\
  !*** ./node_modules/@markdoc/next.js/src/runtime.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// IDEA: explore better displayName functions\nfunction displayName(name) {\n  // Pascal case\n  return name\n    .match(/[a-z]+/gi)\n    .map((word) => word.charAt(0).toUpperCase() + word.substr(1).toLowerCase())\n    .join('');\n}\n\nfunction transformRecord(config) {\n  const output = {};\n  const components = {};\n\n  if (config) {\n    Object.entries(config).forEach(([name, registration]) => {\n      if (output[name]) {\n        throw new Error(`\"${name}\" has already been declared`);\n      }\n\n      const componentName = registration.render ? displayName(name) : undefined;\n\n      output[name] = {\n        ...registration,\n        render: componentName,\n      };\n\n      if (componentName) {\n        components[componentName] = registration.render;\n      }\n    });\n  }\n\n  return {output, components};\n}\n\nexports.getSchema = function getSchema(schema) {\n  const {output: tags, components: tagComponents} = transformRecord(\n    schema.tags\n  );\n\n  const {output: nodes, components: nodeComponents} = transformRecord(\n    schema.nodes\n  );\n\n  return {\n    ...schema,\n    tags,\n    nodes,\n    components: {\n      ...tagComponents,\n      ...nodeComponents,\n    },\n  };\n};\n\nexports.defaultObject = function defaultObject(o) {\n  if (Object.prototype.hasOwnProperty.call(o, 'default')) return o.default;\n  return o || {};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWFya2RvYy9uZXh0LmpzL3NyYy9ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUEsaUJBQWlCO0FBQ2pCLFNBQVMseUNBQXlDO0FBQ2xEO0FBQ0E7O0FBRUEsU0FBUywyQ0FBMkM7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXhsdW5kL3Byb2plY3RzL2Zsb3plL2RvY3Mvbm9kZV9tb2R1bGVzL0BtYXJrZG9jL25leHQuanMvc3JjL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSURFQTogZXhwbG9yZSBiZXR0ZXIgZGlzcGxheU5hbWUgZnVuY3Rpb25zXG5mdW5jdGlvbiBkaXNwbGF5TmFtZShuYW1lKSB7XG4gIC8vIFBhc2NhbCBjYXNlXG4gIHJldHVybiBuYW1lXG4gICAgLm1hdGNoKC9bYS16XSsvZ2kpXG4gICAgLm1hcCgod29yZCkgPT4gd29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCkpXG4gICAgLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZWNvcmQoY29uZmlnKSB7XG4gIGNvbnN0IG91dHB1dCA9IHt9O1xuICBjb25zdCBjb21wb25lbnRzID0ge307XG5cbiAgaWYgKGNvbmZpZykge1xuICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykuZm9yRWFjaCgoW25hbWUsIHJlZ2lzdHJhdGlvbl0pID0+IHtcbiAgICAgIGlmIChvdXRwdXRbbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSByZWdpc3RyYXRpb24ucmVuZGVyID8gZGlzcGxheU5hbWUobmFtZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIG91dHB1dFtuYW1lXSA9IHtcbiAgICAgICAgLi4ucmVnaXN0cmF0aW9uLFxuICAgICAgICByZW5kZXI6IGNvbXBvbmVudE5hbWUsXG4gICAgICB9O1xuXG4gICAgICBpZiAoY29tcG9uZW50TmFtZSkge1xuICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudE5hbWVdID0gcmVnaXN0cmF0aW9uLnJlbmRlcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7b3V0cHV0LCBjb21wb25lbnRzfTtcbn1cblxuZXhwb3J0cy5nZXRTY2hlbWEgPSBmdW5jdGlvbiBnZXRTY2hlbWEoc2NoZW1hKSB7XG4gIGNvbnN0IHtvdXRwdXQ6IHRhZ3MsIGNvbXBvbmVudHM6IHRhZ0NvbXBvbmVudHN9ID0gdHJhbnNmb3JtUmVjb3JkKFxuICAgIHNjaGVtYS50YWdzXG4gICk7XG5cbiAgY29uc3Qge291dHB1dDogbm9kZXMsIGNvbXBvbmVudHM6IG5vZGVDb21wb25lbnRzfSA9IHRyYW5zZm9ybVJlY29yZChcbiAgICBzY2hlbWEubm9kZXNcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICB0YWdzLFxuICAgIG5vZGVzLFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIC4uLnRhZ0NvbXBvbmVudHMsXG4gICAgICAuLi5ub2RlQ29tcG9uZW50cyxcbiAgICB9LFxuICB9O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0T2JqZWN0ID0gZnVuY3Rpb24gZGVmYXVsdE9iamVjdChvKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgJ2RlZmF1bHQnKSkgcmV0dXJuIG8uZGVmYXVsdDtcbiAgcmV0dXJuIG8gfHwge307XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@markdoc/next.js/src/runtime.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/js-yaml/dist/js-yaml.mjs":
/*!***********************************************!*\
  !*** ./node_modules/js-yaml/dist/js-yaml.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CORE_SCHEMA: () => (/* binding */ CORE_SCHEMA),\n/* harmony export */   DEFAULT_SCHEMA: () => (/* binding */ DEFAULT_SCHEMA),\n/* harmony export */   FAILSAFE_SCHEMA: () => (/* binding */ FAILSAFE_SCHEMA),\n/* harmony export */   JSON_SCHEMA: () => (/* binding */ JSON_SCHEMA),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   YAMLException: () => (/* binding */ YAMLException),\n/* harmony export */   \"default\": () => (/* binding */ jsYaml),\n/* harmony export */   dump: () => (/* binding */ dump),\n/* harmony export */   load: () => (/* binding */ load),\n/* harmony export */   loadAll: () => (/* binding */ loadAll),\n/* harmony export */   safeDump: () => (/* binding */ safeDump),\n/* harmony export */   safeLoad: () => (/* binding */ safeLoad),\n/* harmony export */   safeLoadAll: () => (/* binding */ safeLoadAll),\n/* harmony export */   types: () => (/* binding */ types)\n/* harmony export */ });\n\n/*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT */\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nvar isNothing_1      = isNothing;\nvar isObject_1       = isObject;\nvar toArray_1        = toArray;\nvar repeat_1         = repeat;\nvar isNegativeZero_1 = isNegativeZero;\nvar extend_1         = extend;\n\nvar common = {\n\tisNothing: isNothing_1,\n\tisObject: isObject_1,\n\ttoArray: toArray_1,\n\trepeat: repeat_1,\n\tisNegativeZero: isNegativeZero_1,\n\textend: extend_1\n};\n\n// YAML error class. http://stackoverflow.com/questions/8458984\n\n\nfunction formatError(exception, compact) {\n  var where = '', message = exception.reason || '(unknown reason)';\n\n  if (!exception.mark) return message;\n\n  if (exception.mark.name) {\n    where += 'in \"' + exception.mark.name + '\" ';\n  }\n\n  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n  if (!compact && exception.mark.snippet) {\n    where += '\\n\\n' + exception.mark.snippet;\n  }\n\n  return message + ' ' + where;\n}\n\n\nfunction YAMLException$1(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false);\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException$1.prototype = Object.create(Error.prototype);\nYAMLException$1.prototype.constructor = YAMLException$1;\n\n\nYAMLException$1.prototype.toString = function toString(compact) {\n  return this.name + ': ' + formatError(this, compact);\n};\n\n\nvar exception = YAMLException$1;\n\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n  var head = '';\n  var tail = '';\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n  if (position - lineStart > maxHalfLength) {\n    head = ' ... ';\n    lineStart = position - maxHalfLength + head.length;\n  }\n\n  if (lineEnd - position > maxHalfLength) {\n    tail = ' ...';\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n\n  return {\n    str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, '') + tail,\n    pos: position - lineStart + head.length // relative position\n  };\n}\n\n\nfunction padStart(string, max) {\n  return common.repeat(' ', max - string.length) + string;\n}\n\n\nfunction makeSnippet(mark, options) {\n  options = Object.create(options || null);\n\n  if (!mark.buffer) return null;\n\n  if (!options.maxLength) options.maxLength = 79;\n  if (typeof options.indent      !== 'number') options.indent      = 1;\n  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [ 0 ];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n\n  while ((match = re.exec(mark.buffer))) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n\n  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n  var result = '', i, line;\n  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n  for (i = 1; i <= options.linesBefore; i++) {\n    if (foundLineNo - i < 0) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo - i],\n      lineEnds[foundLineNo - i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n      maxLineLength\n    );\n    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n' + result;\n  }\n\n  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n    ' | ' + line.str + '\\n';\n  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n  for (i = 1; i <= options.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo + i],\n      lineEnds[foundLineNo + i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n      maxLineLength\n    );\n    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n  }\n\n  return result.replace(/\\n$/, '');\n}\n\n\nvar snippet = makeSnippet;\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'multi',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'representName',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type$1(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.options       = options; // keep original options in case user wants to extend this type later\n  this.tag           = tag;\n  this.kind          = options['kind']          || null;\n  this.resolve       = options['resolve']       || function () { return true; };\n  this.construct     = options['construct']     || function (data) { return data; };\n  this.instanceOf    = options['instanceOf']    || null;\n  this.predicate     = options['predicate']     || null;\n  this.represent     = options['represent']     || null;\n  this.representName = options['representName'] || null;\n  this.defaultStyle  = options['defaultStyle']  || null;\n  this.multi         = options['multi']         || false;\n  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nvar type = Type$1;\n\n/*eslint-disable max-len*/\n\n\n\n\n\nfunction compileList(schema, name) {\n  var result = [];\n\n  schema[name].forEach(function (currentType) {\n    var newIndex = result.length;\n\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        newIndex = previousIndex;\n      }\n    });\n\n    result[newIndex] = currentType;\n  });\n\n  return result;\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema$1(definition) {\n  return this.extend(definition);\n}\n\n\nSchema$1.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new exception('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type$1.loadKind && type$1.loadKind !== 'scalar') {\n      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type$1.multi) {\n      throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema$1.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit');\n  result.compiledExplicit = compileList(result, 'explicit');\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nvar schema = Schema$1;\n\nvar str = new type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n\nvar seq = new type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n\nvar map = new type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n\nvar failsafe = new schema({\n  explicit: [\n    str,\n    seq,\n    map\n  ]\n});\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nvar _null = new type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; },\n    empty:     function () { return '';     }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nvar bool = new type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'o') {\n      // base 8\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isOctCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n  }\n\n  // base 10 (except 0)\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  return true;\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch;\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nvar int = new type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nvar float = new type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n\nvar json = failsafe.extend({\n  implicit: [\n    _null,\n    bool,\n    int,\n    float\n  ]\n});\n\nvar core = json;\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nvar timestamp = new type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nvar merge = new type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n\n/*eslint-disable no-bitwise*/\n\n\n\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n}\n\nvar binary = new type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n\nvar _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\nvar _toString$2       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString$2.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty$3.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nvar omap = new type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n\nvar _toString$1 = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString$1.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nvar pairs = new type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n\nvar _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty$2.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nvar set = new type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\nvar _default = core.extend({\n  implicit: [\n    timestamp,\n    merge\n  ],\n  explicit: [\n    binary,\n    omap,\n    pairs,\n    set\n  ]\n});\n\n/*eslint-disable max-len,no-use-before-define*/\n\n\n\n\n\n\n\nvar _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\n// set a property of a literal object, while protecting against prototype pollution,\n// see https://github.com/nodeca/js-yaml/issues/164 for more details\nfunction setProperty(object, key, value) {\n  // used for this specific key only because Object.defineProperty is slow\n  if (key === '__proto__') {\n    Object.defineProperty(object, key, {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: value\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State$1(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || _default;\n  this.onWarning = options['onWarning'] || null;\n  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n  // if such documents have no explicit %YAML directive\n  this.legacy    = options['legacy']    || false;\n\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  // position of first leading tab in the current line,\n  // used to make sure there are no tabs in the indentation\n  this.firstTabInLine = -1;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  var mark = {\n    name:     state.filename,\n    buffer:   state.input.slice(0, -1), // omit trailing \\0\n    position: state.position,\n    line:     state.line,\n    column:   state.position - state.lineStart\n  };\n\n  mark.snippet = snippet(mark);\n\n  return new exception(message, mark);\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty$1.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, 'tag prefix is malformed: ' + prefix);\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty$1.call(destination, key)) {\n      setProperty(destination, key, source[key]);\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n  startLine, startLineStart, startPos) {\n\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty$1.call(overridableKeys, keyNode) &&\n        _hasOwnProperty$1.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    setProperty(_result, keyNode, valueNode);\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    } else if (ch === 0x2C/* , */) {\n      // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n      throwError(state, \"expected the node content, but found ','\");\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line; // Save the current line.\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = Object.create(null),\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        // Neither implicit nor explicit notation.\n        // Reading is done. Go to the epilogue.\n        break;\n      }\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, 'tag name is malformed: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n\n  } else if (state.tag === '?') {\n    // Implicit resolving is not allowed for non-scalar types, and '?'\n    // non-specific tag is only automatically assigned to plain scalars.\n    //\n    // We only need to check kind conformity in case user explicitly assigns '?'\n    // tag, for example like this: \"!<?> [0]\"\n    //\n    if (state.result !== null && state.kind !== 'scalar') {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type = state.implicitTypes[typeIndex];\n\n      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        state.result = type.construct(state.result);\n        state.tag = type.tag;\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n        break;\n      }\n    }\n  } else if (state.tag !== '!') {\n    if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n    } else {\n      // looking for multi type\n      type = null;\n      typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n\n    if (!type) {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n\n    if (state.result !== null && type.kind !== state.kind) {\n      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n    }\n\n    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n    } else {\n      state.result = type.construct(state.result, state.tag);\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = Object.create(null);\n  state.anchorMap = Object.create(null);\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State$1(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll$1(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load$1(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new exception('expected a single document in the stream, but found more');\n}\n\n\nvar loadAll_1 = loadAll$1;\nvar load_1    = load$1;\n\nvar loader = {\n\tloadAll: loadAll_1,\n\tload: load_1\n};\n\n/*eslint-disable no-use-before-define*/\n\n\n\n\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema        = options['schema'] || _default;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isnt mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out   ns-plain-safe-out\n//                             c = flow-in    ns-plain-safe-in\n//                             c = block-key  ns-plain-safe-out\n//                             c = flow-key   ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - : - # )\n//                            | ( /* An ns-char preceding */ # )\n//                            | ( : /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( ? | : | - ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // - | ? | : | , | [ | ] | { | }\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | # | & | * | ! | | | = | > | ' | \"\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | % | @ | `)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//     No ending newline => unaffected; already using strip \"-\" chomping.\n//     Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string) + '\"';\n      default:\n        throw new exception('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new exception('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new exception('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | -\n      // [39] ns-uri-char     ::=  % ns-hex-digit ns-hex-digit | ns-word-char | #\n      //                         | ; | / | ? | : | @ | & | = | + | $ | ,\n      //                         | _ | . | ! | ~ | * | ' | ( | ) | [ | ]\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump$1(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nvar dump_1 = dump$1;\n\nvar dumper = {\n\tdump: dump_1\n};\n\nfunction renamed(from, to) {\n  return function () {\n    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n      'Use yaml.' + to + ' instead, which is now safe by default.');\n  };\n}\n\n\nvar Type                = type;\nvar Schema              = schema;\nvar FAILSAFE_SCHEMA     = failsafe;\nvar JSON_SCHEMA         = json;\nvar CORE_SCHEMA         = core;\nvar DEFAULT_SCHEMA      = _default;\nvar load                = loader.load;\nvar loadAll             = loader.loadAll;\nvar dump                = dumper.dump;\nvar YAMLException       = exception;\n\n// Re-export all types in case user wants to create custom schema\nvar types = {\n  binary:    binary,\n  float:     float,\n  map:       map,\n  null:      _null,\n  pairs:     pairs,\n  set:       set,\n  timestamp: timestamp,\n  bool:      bool,\n  int:       int,\n  merge:     merge,\n  omap:      omap,\n  seq:       seq,\n  str:       str\n};\n\n// Removed functions from JS-YAML 3.0.x\nvar safeLoad            = renamed('safeLoad', 'load');\nvar safeLoadAll         = renamed('safeLoadAll', 'loadAll');\nvar safeDump            = renamed('safeDump', 'dump');\n\nvar jsYaml = {\n\tType: Type,\n\tSchema: Schema,\n\tFAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n\tJSON_SCHEMA: JSON_SCHEMA,\n\tCORE_SCHEMA: CORE_SCHEMA,\n\tDEFAULT_SCHEMA: DEFAULT_SCHEMA,\n\tload: load,\n\tloadAll: loadAll,\n\tdump: dump,\n\tYAMLException: YAMLException,\n\ttypes: types,\n\tsafeLoad: safeLoad,\n\tsafeLoadAll: safeLoadAll,\n\tsafeDump: safeDump\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2Rpc3QvanMteWFtbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7O0FBTUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxJQUFJO0FBQ0osdUJBQXVCLGtFQUFrRTtBQUN6RjtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBLGlDQUFpQyxrQ0FBa0M7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLENBQUM7O0FBRUQ7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDLDZCQUE2QixnQkFBZ0I7QUFDN0MsNkJBQTZCLGdCQUFnQjtBQUM3Qyw2QkFBNkIsZ0JBQWdCO0FBQzdDLDZCQUE2QjtBQUM3QixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEUsbUNBQW1DLG1DQUFtQztBQUN0RSxtQ0FBbUM7QUFDbkMsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLGFBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4RUFBOEU7QUFDaEgsa0NBQWtDLGdGQUFnRjtBQUNsSCxrQ0FBa0MsMEJBQTBCO0FBQzVEO0FBQ0Esa0NBQWtDO0FBQ2xDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7Ozs7O0FBTUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDLGdCQUFnQjtBQUMxRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsZ0JBQWdCO0FBQzFEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDLGdCQUFnQjtBQUMxRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7Ozs7Ozs7O0FBUUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRTtBQUMvQztBQUNBLG9EQUFvRCxFQUFFLGVBQWUsRUFBRSxZQUFZOzs7QUFHbkYsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QscUJBQXFCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBOztBQUVBLGdEQUFnRCxrQkFBa0I7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0Msa0JBQWtCO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxlQUFlLGVBQWU7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsSUFBSSx5QkFBeUI7QUFDN0Isc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0EsNkVBQTZFO0FBQzdFLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEsUUFBUTtBQUNSLDZEQUE2RCxzQkFBc0I7QUFDbkY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Ysb0VBQW9FOztBQUVwRSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQSxRQUFRO0FBQ1IsK0RBQStEOztBQUUvRCxRQUFRO0FBQ1I7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUEsbUVBQW1FLDBCQUEwQjtBQUM3Rjs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsMEJBQTBCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7O0FBRUEsa0RBQWtEO0FBQ2xEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QyxzQ0FBc0MsS0FBSztBQUMzQyxzQ0FBc0M7QUFDdEMsc0NBQXNDLEtBQUs7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLGdCQUFnQjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsZ0JBQWdCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGdCQUFnQjs7QUFFakU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxnQkFBZ0I7QUFDakU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixHQUFHO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNENBQTRDLGdCQUFnQjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLFdBQVc7QUFDN0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0wiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXhsdW5kL3Byb2plY3RzL2Zsb3plL2RvY3Mvbm9kZV9tb2R1bGVzL2pzLXlhbWwvZGlzdC9qcy15YW1sLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qISBqcy15YW1sIDQuMS4xIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvanMteWFtbCBAbGljZW5zZSBNSVQgKi9cbmZ1bmN0aW9uIGlzTm90aGluZyhzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICd1bmRlZmluZWQnKSB8fCAoc3ViamVjdCA9PT0gbnVsbCk7XG59XG5cblxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JykgJiYgKHN1YmplY3QgIT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoc2VxdWVuY2UpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSByZXR1cm4gc2VxdWVuY2U7XG4gIGVsc2UgaWYgKGlzTm90aGluZyhzZXF1ZW5jZSkpIHJldHVybiBbXTtcblxuICByZXR1cm4gWyBzZXF1ZW5jZSBdO1xufVxuXG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwga2V5LCBzb3VyY2VLZXlzO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIGNvdW50KSB7XG4gIHZhciByZXN1bHQgPSAnJywgY3ljbGU7XG5cbiAgZm9yIChjeWNsZSA9IDA7IGN5Y2xlIDwgY291bnQ7IGN5Y2xlICs9IDEpIHtcbiAgICByZXN1bHQgKz0gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyhudW1iZXIpIHtcbiAgcmV0dXJuIChudW1iZXIgPT09IDApICYmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IDEgLyBudW1iZXIpO1xufVxuXG5cbnZhciBpc05vdGhpbmdfMSAgICAgID0gaXNOb3RoaW5nO1xudmFyIGlzT2JqZWN0XzEgICAgICAgPSBpc09iamVjdDtcbnZhciB0b0FycmF5XzEgICAgICAgID0gdG9BcnJheTtcbnZhciByZXBlYXRfMSAgICAgICAgID0gcmVwZWF0O1xudmFyIGlzTmVnYXRpdmVaZXJvXzEgPSBpc05lZ2F0aXZlWmVybztcbnZhciBleHRlbmRfMSAgICAgICAgID0gZXh0ZW5kO1xuXG52YXIgY29tbW9uID0ge1xuXHRpc05vdGhpbmc6IGlzTm90aGluZ18xLFxuXHRpc09iamVjdDogaXNPYmplY3RfMSxcblx0dG9BcnJheTogdG9BcnJheV8xLFxuXHRyZXBlYXQ6IHJlcGVhdF8xLFxuXHRpc05lZ2F0aXZlWmVybzogaXNOZWdhdGl2ZVplcm9fMSxcblx0ZXh0ZW5kOiBleHRlbmRfMVxufTtcblxuLy8gWUFNTCBlcnJvciBjbGFzcy4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDU4OTg0XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXhjZXB0aW9uLCBjb21wYWN0KSB7XG4gIHZhciB3aGVyZSA9ICcnLCBtZXNzYWdlID0gZXhjZXB0aW9uLnJlYXNvbiB8fCAnKHVua25vd24gcmVhc29uKSc7XG5cbiAgaWYgKCFleGNlcHRpb24ubWFyaykgcmV0dXJuIG1lc3NhZ2U7XG5cbiAgaWYgKGV4Y2VwdGlvbi5tYXJrLm5hbWUpIHtcbiAgICB3aGVyZSArPSAnaW4gXCInICsgZXhjZXB0aW9uLm1hcmsubmFtZSArICdcIiAnO1xuICB9XG5cbiAgd2hlcmUgKz0gJygnICsgKGV4Y2VwdGlvbi5tYXJrLmxpbmUgKyAxKSArICc6JyArIChleGNlcHRpb24ubWFyay5jb2x1bW4gKyAxKSArICcpJztcblxuICBpZiAoIWNvbXBhY3QgJiYgZXhjZXB0aW9uLm1hcmsuc25pcHBldCkge1xuICAgIHdoZXJlICs9ICdcXG5cXG4nICsgZXhjZXB0aW9uLm1hcmsuc25pcHBldDtcbiAgfVxuXG4gIHJldHVybiBtZXNzYWdlICsgJyAnICsgd2hlcmU7XG59XG5cblxuZnVuY3Rpb24gWUFNTEV4Y2VwdGlvbiQxKHJlYXNvbiwgbWFyaykge1xuICAvLyBTdXBlciBjb25zdHJ1Y3RvclxuICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMubmFtZSA9ICdZQU1MRXhjZXB0aW9uJztcbiAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIHRoaXMubWFyayA9IG1hcms7XG4gIHRoaXMubWVzc2FnZSA9IGZvcm1hdEVycm9yKHRoaXMsIGZhbHNlKTtcblxuICAvLyBJbmNsdWRlIHN0YWNrIHRyYWNlIGluIGVycm9yIG9iamVjdFxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAvLyBDaHJvbWUgYW5kIE5vZGVKU1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZGLCBJRSAxMCsgYW5kIFNhZmFyaSA2Ky4gRmFsbGJhY2sgZm9yIG90aGVyc1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrIHx8ICcnO1xuICB9XG59XG5cblxuLy8gSW5oZXJpdCBmcm9tIEVycm9yXG5ZQU1MRXhjZXB0aW9uJDEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuWUFNTEV4Y2VwdGlvbiQxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFlBTUxFeGNlcHRpb24kMTtcblxuXG5ZQU1MRXhjZXB0aW9uJDEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoY29tcGFjdCkge1xuICByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIGZvcm1hdEVycm9yKHRoaXMsIGNvbXBhY3QpO1xufTtcblxuXG52YXIgZXhjZXB0aW9uID0gWUFNTEV4Y2VwdGlvbiQxO1xuXG4vLyBnZXQgc25pcHBldCBmb3IgYSBzaW5nbGUgbGluZSwgcmVzcGVjdGluZyBtYXhMZW5ndGhcbmZ1bmN0aW9uIGdldExpbmUoYnVmZmVyLCBsaW5lU3RhcnQsIGxpbmVFbmQsIHBvc2l0aW9uLCBtYXhMaW5lTGVuZ3RoKSB7XG4gIHZhciBoZWFkID0gJyc7XG4gIHZhciB0YWlsID0gJyc7XG4gIHZhciBtYXhIYWxmTGVuZ3RoID0gTWF0aC5mbG9vcihtYXhMaW5lTGVuZ3RoIC8gMikgLSAxO1xuXG4gIGlmIChwb3NpdGlvbiAtIGxpbmVTdGFydCA+IG1heEhhbGZMZW5ndGgpIHtcbiAgICBoZWFkID0gJyAuLi4gJztcbiAgICBsaW5lU3RhcnQgPSBwb3NpdGlvbiAtIG1heEhhbGZMZW5ndGggKyBoZWFkLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChsaW5lRW5kIC0gcG9zaXRpb24gPiBtYXhIYWxmTGVuZ3RoKSB7XG4gICAgdGFpbCA9ICcgLi4uJztcbiAgICBsaW5lRW5kID0gcG9zaXRpb24gKyBtYXhIYWxmTGVuZ3RoIC0gdGFpbC5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0cjogaGVhZCArIGJ1ZmZlci5zbGljZShsaW5lU3RhcnQsIGxpbmVFbmQpLnJlcGxhY2UoL1xcdC9nLCAn4oaSJykgKyB0YWlsLFxuICAgIHBvczogcG9zaXRpb24gLSBsaW5lU3RhcnQgKyBoZWFkLmxlbmd0aCAvLyByZWxhdGl2ZSBwb3NpdGlvblxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbWF4KSB7XG4gIHJldHVybiBjb21tb24ucmVwZWF0KCcgJywgbWF4IC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cblxuZnVuY3Rpb24gbWFrZVNuaXBwZXQobWFyaywgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IG51bGwpO1xuXG4gIGlmICghbWFyay5idWZmZXIpIHJldHVybiBudWxsO1xuXG4gIGlmICghb3B0aW9ucy5tYXhMZW5ndGgpIG9wdGlvbnMubWF4TGVuZ3RoID0gNzk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbmRlbnQgICAgICAhPT0gJ251bWJlcicpIG9wdGlvbnMuaW5kZW50ICAgICAgPSAxO1xuICBpZiAodHlwZW9mIG9wdGlvbnMubGluZXNCZWZvcmUgIT09ICdudW1iZXInKSBvcHRpb25zLmxpbmVzQmVmb3JlID0gMztcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVzQWZ0ZXIgICE9PSAnbnVtYmVyJykgb3B0aW9ucy5saW5lc0FmdGVyICA9IDI7XG5cbiAgdmFyIHJlID0gL1xccj9cXG58XFxyfFxcMC9nO1xuICB2YXIgbGluZVN0YXJ0cyA9IFsgMCBdO1xuICB2YXIgbGluZUVuZHMgPSBbXTtcbiAgdmFyIG1hdGNoO1xuICB2YXIgZm91bmRMaW5lTm8gPSAtMTtcblxuICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhtYXJrLmJ1ZmZlcikpKSB7XG4gICAgbGluZUVuZHMucHVzaChtYXRjaC5pbmRleCk7XG4gICAgbGluZVN0YXJ0cy5wdXNoKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgIGlmIChtYXJrLnBvc2l0aW9uIDw9IG1hdGNoLmluZGV4ICYmIGZvdW5kTGluZU5vIDwgMCkge1xuICAgICAgZm91bmRMaW5lTm8gPSBsaW5lU3RhcnRzLmxlbmd0aCAtIDI7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvdW5kTGluZU5vIDwgMCkgZm91bmRMaW5lTm8gPSBsaW5lU3RhcnRzLmxlbmd0aCAtIDE7XG5cbiAgdmFyIHJlc3VsdCA9ICcnLCBpLCBsaW5lO1xuICB2YXIgbGluZU5vTGVuZ3RoID0gTWF0aC5taW4obWFyay5saW5lICsgb3B0aW9ucy5saW5lc0FmdGVyLCBsaW5lRW5kcy5sZW5ndGgpLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgbWF4TGluZUxlbmd0aCA9IG9wdGlvbnMubWF4TGVuZ3RoIC0gKG9wdGlvbnMuaW5kZW50ICsgbGluZU5vTGVuZ3RoICsgMyk7XG5cbiAgZm9yIChpID0gMTsgaSA8PSBvcHRpb25zLmxpbmVzQmVmb3JlOyBpKyspIHtcbiAgICBpZiAoZm91bmRMaW5lTm8gLSBpIDwgMCkgYnJlYWs7XG4gICAgbGluZSA9IGdldExpbmUoXG4gICAgICBtYXJrLmJ1ZmZlcixcbiAgICAgIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gLSBpXSxcbiAgICAgIGxpbmVFbmRzW2ZvdW5kTGluZU5vIC0gaV0sXG4gICAgICBtYXJrLnBvc2l0aW9uIC0gKGxpbmVTdGFydHNbZm91bmRMaW5lTm9dIC0gbGluZVN0YXJ0c1tmb3VuZExpbmVObyAtIGldKSxcbiAgICAgIG1heExpbmVMZW5ndGhcbiAgICApO1xuICAgIHJlc3VsdCA9IGNvbW1vbi5yZXBlYXQoJyAnLCBvcHRpb25zLmluZGVudCkgKyBwYWRTdGFydCgobWFyay5saW5lIC0gaSArIDEpLnRvU3RyaW5nKCksIGxpbmVOb0xlbmd0aCkgK1xuICAgICAgJyB8ICcgKyBsaW5lLnN0ciArICdcXG4nICsgcmVzdWx0O1xuICB9XG5cbiAgbGluZSA9IGdldExpbmUobWFyay5idWZmZXIsIGxpbmVTdGFydHNbZm91bmRMaW5lTm9dLCBsaW5lRW5kc1tmb3VuZExpbmVOb10sIG1hcmsucG9zaXRpb24sIG1heExpbmVMZW5ndGgpO1xuICByZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnICcsIG9wdGlvbnMuaW5kZW50KSArIHBhZFN0YXJ0KChtYXJrLmxpbmUgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAnIHwgJyArIGxpbmUuc3RyICsgJ1xcbic7XG4gIHJlc3VsdCArPSBjb21tb24ucmVwZWF0KCctJywgb3B0aW9ucy5pbmRlbnQgKyBsaW5lTm9MZW5ndGggKyAzICsgbGluZS5wb3MpICsgJ14nICsgJ1xcbic7XG5cbiAgZm9yIChpID0gMTsgaSA8PSBvcHRpb25zLmxpbmVzQWZ0ZXI7IGkrKykge1xuICAgIGlmIChmb3VuZExpbmVObyArIGkgPj0gbGluZUVuZHMubGVuZ3RoKSBicmVhaztcbiAgICBsaW5lID0gZ2V0TGluZShcbiAgICAgIG1hcmsuYnVmZmVyLFxuICAgICAgbGluZVN0YXJ0c1tmb3VuZExpbmVObyArIGldLFxuICAgICAgbGluZUVuZHNbZm91bmRMaW5lTm8gKyBpXSxcbiAgICAgIG1hcmsucG9zaXRpb24gLSAobGluZVN0YXJ0c1tmb3VuZExpbmVOb10gLSBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vICsgaV0pLFxuICAgICAgbWF4TGluZUxlbmd0aFxuICAgICk7XG4gICAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJyAnLCBvcHRpb25zLmluZGVudCkgKyBwYWRTdGFydCgobWFyay5saW5lICsgaSArIDEpLnRvU3RyaW5nKCksIGxpbmVOb0xlbmd0aCkgK1xuICAgICAgJyB8ICcgKyBsaW5lLnN0ciArICdcXG4nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC9cXG4kLywgJycpO1xufVxuXG5cbnZhciBzbmlwcGV0ID0gbWFrZVNuaXBwZXQ7XG5cbnZhciBUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMgPSBbXG4gICdraW5kJyxcbiAgJ211bHRpJyxcbiAgJ3Jlc29sdmUnLFxuICAnY29uc3RydWN0JyxcbiAgJ2luc3RhbmNlT2YnLFxuICAncHJlZGljYXRlJyxcbiAgJ3JlcHJlc2VudCcsXG4gICdyZXByZXNlbnROYW1lJyxcbiAgJ2RlZmF1bHRTdHlsZScsXG4gICdzdHlsZUFsaWFzZXMnXG5dO1xuXG52YXIgWUFNTF9OT0RFX0tJTkRTID0gW1xuICAnc2NhbGFyJyxcbiAgJ3NlcXVlbmNlJyxcbiAgJ21hcHBpbmcnXG5dO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVBbGlhc2VzKG1hcCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIG1hcFtzdHlsZV0uZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0W1N0cmluZyhhbGlhcyldID0gc3R5bGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFR5cGUkMSh0YWcsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1Vua25vd24gb3B0aW9uIFwiJyArIG5hbWUgKyAnXCIgaXMgbWV0IGluIGRlZmluaXRpb24gb2YgXCInICsgdGFnICsgJ1wiIFlBTUwgdHlwZS4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRPRE86IEFkZCB0YWcgZm9ybWF0IGNoZWNrLlxuICB0aGlzLm9wdGlvbnMgICAgICAgPSBvcHRpb25zOyAvLyBrZWVwIG9yaWdpbmFsIG9wdGlvbnMgaW4gY2FzZSB1c2VyIHdhbnRzIHRvIGV4dGVuZCB0aGlzIHR5cGUgbGF0ZXJcbiAgdGhpcy50YWcgICAgICAgICAgID0gdGFnO1xuICB0aGlzLmtpbmQgICAgICAgICAgPSBvcHRpb25zWydraW5kJ10gICAgICAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXNvbHZlICAgICAgID0gb3B0aW9uc1sncmVzb2x2ZSddICAgICAgIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gIHRoaXMuY29uc3RydWN0ICAgICA9IG9wdGlvbnNbJ2NvbnN0cnVjdCddICAgICB8fCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YTsgfTtcbiAgdGhpcy5pbnN0YW5jZU9mICAgID0gb3B0aW9uc1snaW5zdGFuY2VPZiddICAgIHx8IG51bGw7XG4gIHRoaXMucHJlZGljYXRlICAgICA9IG9wdGlvbnNbJ3ByZWRpY2F0ZSddICAgICB8fCBudWxsO1xuICB0aGlzLnJlcHJlc2VudCAgICAgPSBvcHRpb25zWydyZXByZXNlbnQnXSAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnROYW1lID0gb3B0aW9uc1sncmVwcmVzZW50TmFtZSddIHx8IG51bGw7XG4gIHRoaXMuZGVmYXVsdFN0eWxlICA9IG9wdGlvbnNbJ2RlZmF1bHRTdHlsZSddICB8fCBudWxsO1xuICB0aGlzLm11bHRpICAgICAgICAgPSBvcHRpb25zWydtdWx0aSddICAgICAgICAgfHwgZmFsc2U7XG4gIHRoaXMuc3R5bGVBbGlhc2VzICA9IGNvbXBpbGVTdHlsZUFsaWFzZXMob3B0aW9uc1snc3R5bGVBbGlhc2VzJ10gfHwgbnVsbCk7XG5cbiAgaWYgKFlBTUxfTk9ERV9LSU5EUy5pbmRleE9mKHRoaXMua2luZCkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignVW5rbm93biBraW5kIFwiJyArIHRoaXMua2luZCArICdcIiBpcyBzcGVjaWZpZWQgZm9yIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gIH1cbn1cblxudmFyIHR5cGUgPSBUeXBlJDE7XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG5cblxuXG5cblxuZnVuY3Rpb24gY29tcGlsZUxpc3Qoc2NoZW1hLCBuYW1lKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBzY2hlbWFbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudFR5cGUpIHtcbiAgICB2YXIgbmV3SW5kZXggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZyAmJlxuICAgICAgICAgIHByZXZpb3VzVHlwZS5raW5kID09PSBjdXJyZW50VHlwZS5raW5kICYmXG4gICAgICAgICAgcHJldmlvdXNUeXBlLm11bHRpID09PSBjdXJyZW50VHlwZS5tdWx0aSkge1xuXG4gICAgICAgIG5ld0luZGV4ID0gcHJldmlvdXNJbmRleDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3VsdFtuZXdJbmRleF0gPSBjdXJyZW50VHlwZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBjb21waWxlTWFwKC8qIGxpc3RzLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHNjYWxhcjoge30sXG4gICAgICAgIHNlcXVlbmNlOiB7fSxcbiAgICAgICAgbWFwcGluZzoge30sXG4gICAgICAgIGZhbGxiYWNrOiB7fSxcbiAgICAgICAgbXVsdGk6IHtcbiAgICAgICAgICBzY2FsYXI6IFtdLFxuICAgICAgICAgIHNlcXVlbmNlOiBbXSxcbiAgICAgICAgICBtYXBwaW5nOiBbXSxcbiAgICAgICAgICBmYWxsYmFjazogW11cbiAgICAgICAgfVxuICAgICAgfSwgaW5kZXgsIGxlbmd0aDtcblxuICBmdW5jdGlvbiBjb2xsZWN0VHlwZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUubXVsdGkpIHtcbiAgICAgIHJlc3VsdC5tdWx0aVt0eXBlLmtpbmRdLnB1c2godHlwZSk7XG4gICAgICByZXN1bHQubXVsdGlbJ2ZhbGxiYWNrJ10ucHVzaCh0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W3R5cGUua2luZF1bdHlwZS50YWddID0gcmVzdWx0WydmYWxsYmFjayddW3R5cGUudGFnXSA9IHR5cGU7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIFNjaGVtYSQxKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW5kKGRlZmluaXRpb24pO1xufVxuXG5cblNjaGVtYSQxLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQoZGVmaW5pdGlvbikge1xuICB2YXIgaW1wbGljaXQgPSBbXTtcbiAgdmFyIGV4cGxpY2l0ID0gW107XG5cbiAgaWYgKGRlZmluaXRpb24gaW5zdGFuY2VvZiB0eXBlKSB7XG4gICAgLy8gU2NoZW1hLmV4dGVuZCh0eXBlKVxuICAgIGV4cGxpY2l0LnB1c2goZGVmaW5pdGlvbik7XG5cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgLy8gU2NoZW1hLmV4dGVuZChbIHR5cGUxLCB0eXBlMiwgLi4uIF0pXG4gICAgZXhwbGljaXQgPSBleHBsaWNpdC5jb25jYXQoZGVmaW5pdGlvbik7XG5cbiAgfSBlbHNlIGlmIChkZWZpbml0aW9uICYmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24uaW1wbGljaXQpIHx8IEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbi5leHBsaWNpdCkpKSB7XG4gICAgLy8gU2NoZW1hLmV4dGVuZCh7IGV4cGxpY2l0OiBbIHR5cGUxLCB0eXBlMiwgLi4uIF0sIGltcGxpY2l0OiBbIHR5cGUxLCB0eXBlMiwgLi4uIF0gfSlcbiAgICBpZiAoZGVmaW5pdGlvbi5pbXBsaWNpdCkgaW1wbGljaXQgPSBpbXBsaWNpdC5jb25jYXQoZGVmaW5pdGlvbi5pbXBsaWNpdCk7XG4gICAgaWYgKGRlZmluaXRpb24uZXhwbGljaXQpIGV4cGxpY2l0ID0gZXhwbGljaXQuY29uY2F0KGRlZmluaXRpb24uZXhwbGljaXQpO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignU2NoZW1hLmV4dGVuZCBhcmd1bWVudCBzaG91bGQgYmUgYSBUeXBlLCBbIFR5cGUgXSwgJyArXG4gICAgICAnb3IgYSBzY2hlbWEgZGVmaW5pdGlvbiAoeyBpbXBsaWNpdDogWy4uLl0sIGV4cGxpY2l0OiBbLi4uXSB9KScpO1xuICB9XG5cbiAgaW1wbGljaXQuZm9yRWFjaChmdW5jdGlvbiAodHlwZSQxKSB7XG4gICAgaWYgKCEodHlwZSQxIGluc3RhbmNlb2YgdHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSQxLmxvYWRLaW5kICYmIHR5cGUkMS5sb2FkS2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1RoZXJlIGlzIGEgbm9uLXNjYWxhciB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBJbXBsaWNpdCByZXNvbHZpbmcgb2Ygc3VjaCB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlJDEubXVsdGkpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1RoZXJlIGlzIGEgbXVsdGkgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gTXVsdGkgdGFncyBjYW4gb25seSBiZSBsaXN0ZWQgYXMgZXhwbGljaXQuJyk7XG4gICAgfVxuICB9KTtcblxuICBleHBsaWNpdC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlJDEpIHtcbiAgICBpZiAoISh0eXBlJDEgaW5zdGFuY2VvZiB0eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LicpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUoU2NoZW1hJDEucHJvdG90eXBlKTtcblxuICByZXN1bHQuaW1wbGljaXQgPSAodGhpcy5pbXBsaWNpdCB8fCBbXSkuY29uY2F0KGltcGxpY2l0KTtcbiAgcmVzdWx0LmV4cGxpY2l0ID0gKHRoaXMuZXhwbGljaXQgfHwgW10pLmNvbmNhdChleHBsaWNpdCk7XG5cbiAgcmVzdWx0LmNvbXBpbGVkSW1wbGljaXQgPSBjb21waWxlTGlzdChyZXN1bHQsICdpbXBsaWNpdCcpO1xuICByZXN1bHQuY29tcGlsZWRFeHBsaWNpdCA9IGNvbXBpbGVMaXN0KHJlc3VsdCwgJ2V4cGxpY2l0Jyk7XG4gIHJlc3VsdC5jb21waWxlZFR5cGVNYXAgID0gY29tcGlsZU1hcChyZXN1bHQuY29tcGlsZWRJbXBsaWNpdCwgcmVzdWx0LmNvbXBpbGVkRXhwbGljaXQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbnZhciBzY2hlbWEgPSBTY2hlbWEkMTtcblxudmFyIHN0ciA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6ICcnOyB9XG59KTtcblxudmFyIHNlcSA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107IH1cbn0pO1xuXG52YXIgbWFwID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9OyB9XG59KTtcblxudmFyIGZhaWxzYWZlID0gbmV3IHNjaGVtYSh7XG4gIGV4cGxpY2l0OiBbXG4gICAgc3RyLFxuICAgIHNlcSxcbiAgICBtYXBcbiAgXVxufSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTnVsbChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDEgJiYgZGF0YSA9PT0gJ34nKSB8fFxuICAgICAgICAgKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ251bGwnIHx8IGRhdGEgPT09ICdOdWxsJyB8fCBkYXRhID09PSAnTlVMTCcpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT09IG51bGw7XG59XG5cbnZhciBfbnVsbCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxOdWxsLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxOdWxsLFxuICBwcmVkaWNhdGU6IGlzTnVsbCxcbiAgcmVwcmVzZW50OiB7XG4gICAgY2Fub25pY2FsOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnfic7ICAgIH0sXG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnbnVsbCc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTlVMTCc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTnVsbCc7IH0sXG4gICAgZW1wdHk6ICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAnJzsgICAgIH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQm9vbGVhbihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSA0ICYmIChkYXRhID09PSAndHJ1ZScgfHwgZGF0YSA9PT0gJ1RydWUnIHx8IGRhdGEgPT09ICdUUlVFJykpIHx8XG4gICAgICAgICAobWF4ID09PSA1ICYmIChkYXRhID09PSAnZmFsc2UnIHx8IGRhdGEgPT09ICdGYWxzZScgfHwgZGF0YSA9PT0gJ0ZBTFNFJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQm9vbGVhbihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAndHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUcnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RSVUUnO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufVxuXG52YXIgYm9vbCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCb29sZWFuLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCb29sZWFuLFxuICBwcmVkaWNhdGU6IGlzQm9vbGVhbixcbiAgcmVwcmVzZW50OiB7XG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAndHJ1ZScgOiAnZmFsc2UnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RSVUUnIDogJ0ZBTFNFJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUcnVlJyA6ICdGYWxzZSc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkgfHxcbiAgICAgICAgICgoMHg0MS8qIEEgKi8gPD0gYykgJiYgKGMgPD0gMHg0Ni8qIEYgKi8pKSB8fFxuICAgICAgICAgKCgweDYxLyogYSAqLyA8PSBjKSAmJiAoYyA8PSAweDY2LyogZiAqLykpO1xufVxuXG5mdW5jdGlvbiBpc09jdENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM3LyogNyAqLykpO1xufVxuXG5mdW5jdGlvbiBpc0RlY0NvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEludGVnZXIoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGhhc0RpZ2l0cyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKCFtYXgpIHJldHVybiBmYWxzZTtcblxuICBjaCA9IGRhdGFbaW5kZXhdO1xuXG4gIC8vIHNpZ25cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgLy8gMFxuICAgIGlmIChpbmRleCArIDEgPT09IG1heCkgcmV0dXJuIHRydWU7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuXG4gICAgLy8gYmFzZSAyLCBiYXNlIDgsIGJhc2UgMTZcblxuICAgIGlmIChjaCA9PT0gJ2InKSB7XG4gICAgICAvLyBiYXNlIDJcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ3gnKSB7XG4gICAgICAvLyBiYXNlIDE2XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzSGV4Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cblxuXG4gICAgaWYgKGNoID09PSAnbycpIHtcbiAgICAgIC8vIGJhc2UgOFxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFpc09jdENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG4gIH1cblxuICAvLyBiYXNlIDEwIChleGNlcHQgMClcblxuICAvLyB2YWx1ZSBzaG91bGQgbm90IHN0YXJ0IHdpdGggYF9gO1xuICBpZiAoY2ggPT09ICdfJykgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgIGlmICghaXNEZWNDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gIH1cblxuICAvLyBTaG91bGQgaGF2ZSBkaWdpdHMgYW5kIHNob3VsZCBub3QgZW5kIHdpdGggYF9gXG4gIGlmICghaGFzRGlnaXRzIHx8IGNoID09PSAnXycpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEludGVnZXIoZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLCBzaWduID0gMSwgY2g7XG5cbiAgaWYgKHZhbHVlLmluZGV4T2YoJ18nKSAhPT0gLTEpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL18vZywgJycpO1xuICB9XG5cbiAgY2ggPSB2YWx1ZVswXTtcblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgaWYgKGNoID09PSAnLScpIHNpZ24gPSAtMTtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgIGNoID0gdmFsdWVbMF07XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcwJykgcmV0dXJuIDA7XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdiJykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgaWYgKHZhbHVlWzFdID09PSAneCcpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDE2KTtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdvJykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgOCk7XG4gIH1cblxuICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZWdlcihvYmplY3QpIHtcbiAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmXG4gICAgICAgICAob2JqZWN0ICUgMSA9PT0gMCAmJiAhY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpO1xufVxuXG52YXIgaW50ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogICAgICBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcwYicgKyBvYmoudG9TdHJpbmcoMikgOiAnLTBiJyArIG9iai50b1N0cmluZygyKS5zbGljZSgxKTsgfSxcbiAgICBvY3RhbDogICAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqID49IDAgPyAnMG8nICArIG9iai50b1N0cmluZyg4KSA6ICctMG8nICArIG9iai50b1N0cmluZyg4KS5zbGljZSgxKTsgfSxcbiAgICBkZWNpbWFsOiAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqLnRvU3RyaW5nKDEwKTsgfSxcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgaGV4YWRlY2ltYWw6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSA6ICAnLTB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5zbGljZSgxKTsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXG4gICAgb2N0YWw6ICAgICAgIFsgOCwgICdvY3QnIF0sXG4gICAgZGVjaW1hbDogICAgIFsgMTAsICdkZWMnIF0sXG4gICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cbiAgfVxufSk7XG5cbnZhciBZQU1MX0ZMT0FUX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFxuICAvLyAyLjVlNCwgMi41IGFuZCBpbnRlZ2Vyc1xuICAnXig/OlstK10/KD86WzAtOV1bMC05X10qKSg/OlxcXFwuWzAtOV9dKik/KD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gLjJlNCwgLjJcbiAgLy8gc3BlY2lhbCBjYXNlLCBzZWVtcyBub3QgZnJvbSBzcGVjXG4gICd8XFxcXC5bMC05X10rKD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gLmluZlxuICAnfFstK10/XFxcXC4oPzppbmZ8SW5mfElORiknICtcbiAgLy8gLm5hblxuICAnfFxcXFwuKD86bmFufE5hTnxOQU4pKSQnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxGbG9hdChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKCFZQU1MX0ZMT0FUX1BBVFRFUk4udGVzdChkYXRhKSB8fFxuICAgICAgLy8gUXVpY2sgaGFjayB0byBub3QgYWxsb3cgaW50ZWdlcnMgZW5kIHdpdGggYF9gXG4gICAgICAvLyBQcm9iYWJseSBzaG91bGQgdXBkYXRlIHJlZ2V4cCAmIGNoZWNrIHNwZWVkXG4gICAgICBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09ICdfJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sRmxvYXQoZGF0YSkge1xuICB2YXIgdmFsdWUsIHNpZ247XG5cbiAgdmFsdWUgID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduICAgPSB2YWx1ZVswXSA9PT0gJy0nID8gLTEgOiAxO1xuXG4gIGlmICgnKy0nLmluZGV4T2YodmFsdWVbMF0pID49IDApIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnLmluZicpIHtcbiAgICByZXR1cm4gKHNpZ24gPT09IDEpID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICcubmFuJykge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHZhbHVlLCAxMCk7XG59XG5cblxudmFyIFNDSUVOVElGSUNfV0lUSE9VVF9ET1QgPSAvXlstK10/WzAtOV0rZS87XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxGbG9hdChvYmplY3QsIHN0eWxlKSB7XG4gIHZhciByZXM7XG5cbiAgaWYgKGlzTmFOKG9iamVjdCkpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy5uYW4nO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICcuTkFOJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLk5hTic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICcuaW5mJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLklORic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLS5pbmYnO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICctLklORic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy0uSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpIHtcbiAgICByZXR1cm4gJy0wLjAnO1xuICB9XG5cbiAgcmVzID0gb2JqZWN0LnRvU3RyaW5nKDEwKTtcblxuICAvLyBKUyBzdHJpbmdpZmllciBjYW4gYnVpbGQgc2NpZW50aWZpYyBmb3JtYXQgd2l0aG91dCBkb3RzOiA1ZS0xMDAsXG4gIC8vIHdoaWxlIFlBTUwgcmVxdXJlcyBkb3Q6IDUuZS0xMDAuIEZpeCBpdCB3aXRoIHNpbXBsZSBoYWNrXG5cbiAgcmV0dXJuIFNDSUVOVElGSUNfV0lUSE9VVF9ET1QudGVzdChyZXMpID8gcmVzLnJlcGxhY2UoJ2UnLCAnLmUnKSA6IHJlcztcbn1cblxuZnVuY3Rpb24gaXNGbG9hdChvYmplY3QpIHtcbiAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpICYmXG4gICAgICAgICAob2JqZWN0ICUgMSAhPT0gMCB8fCBjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbnZhciBmbG9hdCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sRmxvYXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEZsb2F0LFxuICBwcmVkaWNhdGU6IGlzRmxvYXQsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEZsb2F0LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcblxudmFyIGpzb24gPSBmYWlsc2FmZS5leHRlbmQoe1xuICBpbXBsaWNpdDogW1xuICAgIF9udWxsLFxuICAgIGJvb2wsXG4gICAgaW50LFxuICAgIGZsb2F0XG4gIF1cbn0pO1xuXG52YXIgY29yZSA9IGpzb247XG5cbnZhciBZQU1MX0RBVEVfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XSkkJyk7ICAgICAgICAgICAgICAgICAgIC8vIFszXSBkYXlcblxudmFyIFlBTUxfVElNRVNUQU1QX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gICdeKFswLTldWzAtOV1bMC05XVswLTldKScgICAgICAgICAgKyAvLyBbMV0geWVhclxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzJdIG1vbnRoXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbM10gZGF5XG4gICcoPzpbVHRdfFsgXFxcXHRdKyknICAgICAgICAgICAgICAgICArIC8vIC4uLlxuICAnKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgICsgLy8gWzRdIGhvdXJcbiAgJzooWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFs1XSBtaW51dGVcbiAgJzooWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFs2XSBzZWNvbmRcbiAgJyg/OlxcXFwuKFswLTldKikpPycgICAgICAgICAgICAgICAgICsgLy8gWzddIGZyYWN0aW9uXG4gICcoPzpbIFxcXFx0XSooWnwoWy0rXSkoWzAtOV1bMC05XT8pJyArIC8vIFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXJcbiAgJyg/OjooWzAtOV1bMC05XSkpPykpPyQnKTsgICAgICAgICAgIC8vIFsxMV0gdHpfbWludXRlXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIGlmIChZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIHZhciBtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCwgdHpfaG91ciwgdHpfbWludXRlLCBkYXRlO1xuXG4gIG1hdGNoID0gWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpO1xuICBpZiAobWF0Y2ggPT09IG51bGwpIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSk7XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGUgcmVzb2x2ZSBlcnJvcicpO1xuXG4gIC8vIG1hdGNoOiBbMV0geWVhciBbMl0gbW9udGggWzNdIGRheVxuXG4gIHllYXIgPSArKG1hdGNoWzFdKTtcbiAgbW9udGggPSArKG1hdGNoWzJdKSAtIDE7IC8vIEpTIG1vbnRoIHN0YXJ0cyB3aXRoIDBcbiAgZGF5ID0gKyhtYXRjaFszXSk7XG5cbiAgaWYgKCFtYXRjaFs0XSkgeyAvLyBubyBob3VyXG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbNF0gaG91ciBbNV0gbWludXRlIFs2XSBzZWNvbmQgWzddIGZyYWN0aW9uXG5cbiAgaG91ciA9ICsobWF0Y2hbNF0pO1xuICBtaW51dGUgPSArKG1hdGNoWzVdKTtcbiAgc2Vjb25kID0gKyhtYXRjaFs2XSk7XG5cbiAgaWYgKG1hdGNoWzddKSB7XG4gICAgZnJhY3Rpb24gPSBtYXRjaFs3XS5zbGljZSgwLCAzKTtcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgMykgeyAvLyBtaWxsaS1zZWNvbmRzXG4gICAgICBmcmFjdGlvbiArPSAnMCc7XG4gICAgfVxuICAgIGZyYWN0aW9uID0gK2ZyYWN0aW9uO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXIgWzExXSB0el9taW51dGVcblxuICBpZiAobWF0Y2hbOV0pIHtcbiAgICB0el9ob3VyID0gKyhtYXRjaFsxMF0pO1xuICAgIHR6X21pbnV0ZSA9ICsobWF0Y2hbMTFdIHx8IDApO1xuICAgIGRlbHRhID0gKHR6X2hvdXIgKiA2MCArIHR6X21pbnV0ZSkgKiA2MDAwMDsgLy8gZGVsdGEgaW4gbWlsaS1zZWNvbmRzXG4gICAgaWYgKG1hdGNoWzldID09PSAnLScpIGRlbHRhID0gLWRlbHRhO1xuICB9XG5cbiAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbikpO1xuXG4gIGlmIChkZWx0YSkgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpIC0gZGVsdGEpO1xuXG4gIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sVGltZXN0YW1wKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG59XG5cbnZhciB0aW1lc3RhbXAgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxUaW1lc3RhbXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFRpbWVzdGFtcCxcbiAgaW5zdGFuY2VPZjogRGF0ZSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sVGltZXN0YW1wXG59KTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxNZXJnZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAnPDwnIHx8IGRhdGEgPT09IG51bGw7XG59XG5cbnZhciBtZXJnZSA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTWVyZ2Vcbn0pO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuXG5cblxuXG5cbi8vIFsgNjQsIDY1LCA2NiBdIC0+IFsgcGFkZGluZywgQ1IsIExGIF1cbnZhciBCQVNFNjRfTUFQID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyJztcblxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJpbmFyeShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGNvZGUsIGlkeCwgYml0bGVuID0gMCwgbWF4ID0gZGF0YS5sZW5ndGgsIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBvbmUgYnkgb25lLlxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBjb2RlID0gbWFwLmluZGV4T2YoZGF0YS5jaGFyQXQoaWR4KSk7XG5cbiAgICAvLyBTa2lwIENSL0xGXG4gICAgaWYgKGNvZGUgPiA2NCkgY29udGludWU7XG5cbiAgICAvLyBGYWlsIG9uIGlsbGVnYWwgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgYml0bGVuICs9IDY7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgYW55IGJpdHMgbGVmdCwgc291cmNlIHdhcyBjb3JydXB0ZWRcbiAgcmV0dXJuIChiaXRsZW4gJSA4KSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJpbmFyeShkYXRhKSB7XG4gIHZhciBpZHgsIHRhaWxiaXRzLFxuICAgICAgaW5wdXQgPSBkYXRhLnJlcGxhY2UoL1tcXHJcXG49XS9nLCAnJyksIC8vIHJlbW92ZSBDUi9MRiAmIHBhZGRpbmcgdG8gc2ltcGxpZnkgc2NhblxuICAgICAgbWF4ID0gaW5wdXQubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUCxcbiAgICAgIGJpdHMgPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgLy8gQ29sbGVjdCBieSA2KjQgYml0cyAoMyBieXRlcylcblxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBpZiAoKGlkeCAlIDQgPT09IDApICYmIGlkeCkge1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTYpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiA4KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA2KSB8IG1hcC5pbmRleE9mKGlucHV0LmNoYXJBdChpZHgpKTtcbiAgfVxuXG4gIC8vIER1bXAgdGFpbFxuXG4gIHRhaWxiaXRzID0gKG1heCAlIDQpICogNjtcblxuICBpZiAodGFpbGJpdHMgPT09IDApIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiA4KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTgpIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxMCkgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAyKSAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxMikge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDQpICYgMHhGRik7XG4gIH1cblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEJpbmFyeShvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBiaXRzID0gMCwgaWR4LCB0YWlsLFxuICAgICAgbWF4ID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBldmVyeSB0aHJlZSBieXRlcyB0byA0IEFTQ0lJIGNoYXJhY3RlcnMuXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSAzID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDgpICsgb2JqZWN0W2lkeF07XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsID0gbWF4ICUgMztcblxuICBpZiAodGFpbCA9PT0gMCkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMikge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTApICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAxKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICAnW29iamVjdCBVaW50OEFycmF5XSc7XG59XG5cbnZhciBiaW5hcnkgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCaW5hcnksXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJpbmFyeSxcbiAgcHJlZGljYXRlOiBpc0JpbmFyeSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sQmluYXJ5XG59KTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSQzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfdG9TdHJpbmckMiAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sT21hcChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgb2JqZWN0S2V5cyA9IFtdLCBpbmRleCwgbGVuZ3RoLCBwYWlyLCBwYWlyS2V5LCBwYWlySGFzS2V5LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcbiAgICBwYWlySGFzS2V5ID0gZmFsc2U7XG5cbiAgICBpZiAoX3RvU3RyaW5nJDIuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAocGFpcktleSBpbiBwYWlyKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5JDMuY2FsbChwYWlyLCBwYWlyS2V5KSkge1xuICAgICAgICBpZiAoIXBhaXJIYXNLZXkpIHBhaXJIYXNLZXkgPSB0cnVlO1xuICAgICAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhaXJIYXNLZXkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChvYmplY3RLZXlzLmluZGV4T2YocGFpcktleSkgPT09IC0xKSBvYmplY3RLZXlzLnB1c2gocGFpcktleSk7XG4gICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE9tYXAoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiBbXTtcbn1cblxudmFyIG9tYXAgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxPbWFwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxPbWFwXG59KTtcblxudmFyIF90b1N0cmluZyQxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoX3RvU3RyaW5nJDEuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gW107XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIHBhaXJzID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFBhaXJzLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxQYWlyc1xufSk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkkMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sU2V0KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBrZXksIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQyLmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICBpZiAob2JqZWN0W2tleV0gIT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFNldChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9O1xufVxuXG52YXIgc2V0ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFNldCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sU2V0XG59KTtcblxudmFyIF9kZWZhdWx0ID0gY29yZS5leHRlbmQoe1xuICBpbXBsaWNpdDogW1xuICAgIHRpbWVzdGFtcCxcbiAgICBtZXJnZVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIGJpbmFyeSxcbiAgICBvbWFwLFxuICAgIHBhaXJzLFxuICAgIHNldFxuICBdXG59KTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuLG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxuXG5cblxuXG5cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXG52YXIgQ09OVEVYVF9GTE9XX0lOICAgPSAxO1xudmFyIENPTlRFWFRfRkxPV19PVVQgID0gMjtcbnZhciBDT05URVhUX0JMT0NLX0lOICA9IDM7XG52YXIgQ09OVEVYVF9CTE9DS19PVVQgPSA0O1xuXG5cbnZhciBDSE9NUElOR19DTElQICA9IDE7XG52YXIgQ0hPTVBJTkdfU1RSSVAgPSAyO1xudmFyIENIT01QSU5HX0tFRVAgID0gMztcblxuXG52YXIgUEFUVEVSTl9OT05fUFJJTlRBQkxFICAgICAgICAgPSAvW1xceDAwLVxceDA4XFx4MEJcXHgwQ1xceDBFLVxceDFGXFx4N0YtXFx4ODRcXHg4Ni1cXHg5RlxcdUZGRkVcXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS87XG52YXIgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MgPSAvW1xceDg1XFx1MjAyOFxcdTIwMjldLztcbnZhciBQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUyAgICAgICA9IC9bLFxcW1xcXVxce1xcfV0vO1xudmFyIFBBVFRFUk5fVEFHX0hBTkRMRSAgICAgICAgICAgID0gL14oPzohfCEhfCFbYS16XFwtXSshKSQvaTtcbnZhciBQQVRURVJOX1RBR19VUkkgICAgICAgICAgICAgICA9IC9eKD86IXxbXixcXFtcXF1cXHtcXH1dKSg/OiVbMC05YS1mXXsyfXxbMC05YS16XFwtIztcXC9cXD86QCY9XFwrXFwkLF9cXC4hflxcKidcXChcXClcXFtcXF1dKSokL2k7XG5cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cblxuZnVuY3Rpb24gaXNfRU9MKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDBBLyogTEYgKi8pIHx8IChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XSElURV9TUEFDRShjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwOS8qIFRhYiAqLykgfHwgKGMgPT09IDB4MjAvKiBTcGFjZSAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX1dTX09SX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwOS8qIFRhYiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDIwLyogU3BhY2UgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgwQS8qIExGICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEQvKiBDUiAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX0ZMT1dfSU5ESUNBVE9SKGMpIHtcbiAgcmV0dXJuIGMgPT09IDB4MkMvKiAsICovIHx8XG4gICAgICAgICBjID09PSAweDVCLyogWyAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg1RC8qIF0gKi8gfHxcbiAgICAgICAgIGMgPT09IDB4N0IvKiB7ICovIHx8XG4gICAgICAgICBjID09PSAweDdELyogfSAqLztcbn1cblxuZnVuY3Rpb24gZnJvbUhleENvZGUoYykge1xuICB2YXIgbGM7XG5cbiAgaWYgKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHtcbiAgICByZXR1cm4gYyAtIDB4MzA7XG4gIH1cblxuICAvKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuICBsYyA9IGMgfCAweDIwO1xuXG4gIGlmICgoMHg2MS8qIGEgKi8gPD0gbGMpICYmIChsYyA8PSAweDY2LyogZiAqLykpIHtcbiAgICByZXR1cm4gbGMgLSAweDYxICsgMTA7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZWRIZXhMZW4oYykge1xuICBpZiAoYyA9PT0gMHg3OC8qIHggKi8pIHsgcmV0dXJuIDI7IH1cbiAgaWYgKGMgPT09IDB4NzUvKiB1ICovKSB7IHJldHVybiA0OyB9XG4gIGlmIChjID09PSAweDU1LyogVSAqLykgeyByZXR1cm4gODsgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gZnJvbURlY2ltYWxDb2RlKGMpIHtcbiAgaWYgKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHtcbiAgICByZXR1cm4gYyAtIDB4MzA7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVzY2FwZVNlcXVlbmNlKGMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG4gIHJldHVybiAoYyA9PT0gMHgzMC8qIDAgKi8pID8gJ1xceDAwJyA6XG4gICAgICAgIChjID09PSAweDYxLyogYSAqLykgPyAnXFx4MDcnIDpcbiAgICAgICAgKGMgPT09IDB4NjIvKiBiICovKSA/ICdcXHgwOCcgOlxuICAgICAgICAoYyA9PT0gMHg3NC8qIHQgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDA5LyogVGFiICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHg2RS8qIG4gKi8pID8gJ1xceDBBJyA6XG4gICAgICAgIChjID09PSAweDc2LyogdiAqLykgPyAnXFx4MEInIDpcbiAgICAgICAgKGMgPT09IDB4NjYvKiBmICovKSA/ICdcXHgwQycgOlxuICAgICAgICAoYyA9PT0gMHg3Mi8qIHIgKi8pID8gJ1xceDBEJyA6XG4gICAgICAgIChjID09PSAweDY1LyogZSAqLykgPyAnXFx4MUInIDpcbiAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgPyAnICcgOlxuICAgICAgICAoYyA9PT0gMHgyMi8qIFwiICovKSA/ICdcXHgyMicgOlxuICAgICAgICAoYyA9PT0gMHgyRi8qIC8gKi8pID8gJy8nIDpcbiAgICAgICAgKGMgPT09IDB4NUMvKiBcXCAqLykgPyAnXFx4NUMnIDpcbiAgICAgICAgKGMgPT09IDB4NEUvKiBOICovKSA/ICdcXHg4NScgOlxuICAgICAgICAoYyA9PT0gMHg1Ri8qIF8gKi8pID8gJ1xceEEwJyA6XG4gICAgICAgIChjID09PSAweDRDLyogTCAqLykgPyAnXFx1MjAyOCcgOlxuICAgICAgICAoYyA9PT0gMHg1MC8qIFAgKi8pID8gJ1xcdTIwMjknIDogJyc7XG59XG5cbmZ1bmN0aW9uIGNoYXJGcm9tQ29kZXBvaW50KGMpIHtcbiAgaWYgKGMgPD0gMHhGRkZGKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gIH1cbiAgLy8gRW5jb2RlIFVURi0xNiBzdXJyb2dhdGUgcGFpclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtMTYjQ29kZV9wb2ludHNfVS4yQjAxMDAwMF90b19VLjJCMTBGRkZGXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICgoYyAtIDB4MDEwMDAwKSA+PiAxMCkgKyAweEQ4MDAsXG4gICAgKChjIC0gMHgwMTAwMDApICYgMHgwM0ZGKSArIDB4REMwMFxuICApO1xufVxuXG4vLyBzZXQgYSBwcm9wZXJ0eSBvZiBhIGxpdGVyYWwgb2JqZWN0LCB3aGlsZSBwcm90ZWN0aW5nIGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvbixcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL2pzLXlhbWwvaXNzdWVzLzE2NCBmb3IgbW9yZSBkZXRhaWxzXG5mdW5jdGlvbiBzZXRQcm9wZXJ0eShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgLy8gdXNlZCBmb3IgdGhpcyBzcGVjaWZpYyBrZXkgb25seSBiZWNhdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBpcyBzbG93XG4gIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbnZhciBzaW1wbGVFc2NhcGVDaGVjayA9IG5ldyBBcnJheSgyNTYpOyAvLyBpbnRlZ2VyLCBmb3IgZmFzdCBhY2Nlc3NcbnZhciBzaW1wbGVFc2NhcGVNYXAgPSBuZXcgQXJyYXkoMjU2KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgc2ltcGxlRXNjYXBlQ2hlY2tbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKSA/IDEgOiAwO1xuICBzaW1wbGVFc2NhcGVNYXBbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKTtcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZSQxKGlucHV0LCBvcHRpb25zKSB7XG4gIHRoaXMuaW5wdXQgPSBpbnB1dDtcblxuICB0aGlzLmZpbGVuYW1lICA9IG9wdGlvbnNbJ2ZpbGVuYW1lJ10gIHx8IG51bGw7XG4gIHRoaXMuc2NoZW1hICAgID0gb3B0aW9uc1snc2NoZW1hJ10gICAgfHwgX2RlZmF1bHQ7XG4gIHRoaXMub25XYXJuaW5nID0gb3B0aW9uc1snb25XYXJuaW5nJ10gfHwgbnVsbDtcbiAgLy8gKEhpZGRlbikgUmVtb3ZlPyBtYWtlcyB0aGUgbG9hZGVyIHRvIGV4cGVjdCBZQU1MIDEuMSBkb2N1bWVudHNcbiAgLy8gaWYgc3VjaCBkb2N1bWVudHMgaGF2ZSBubyBleHBsaWNpdCAlWUFNTCBkaXJlY3RpdmVcbiAgdGhpcy5sZWdhY3kgICAgPSBvcHRpb25zWydsZWdhY3knXSAgICB8fCBmYWxzZTtcblxuICB0aGlzLmpzb24gICAgICA9IG9wdGlvbnNbJ2pzb24nXSAgICAgIHx8IGZhbHNlO1xuICB0aGlzLmxpc3RlbmVyICA9IG9wdGlvbnNbJ2xpc3RlbmVyJ10gIHx8IG51bGw7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy50eXBlTWFwICAgICAgID0gdGhpcy5zY2hlbWEuY29tcGlsZWRUeXBlTWFwO1xuXG4gIHRoaXMubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgdGhpcy5wb3NpdGlvbiAgID0gMDtcbiAgdGhpcy5saW5lICAgICAgID0gMDtcbiAgdGhpcy5saW5lU3RhcnQgID0gMDtcbiAgdGhpcy5saW5lSW5kZW50ID0gMDtcblxuICAvLyBwb3NpdGlvbiBvZiBmaXJzdCBsZWFkaW5nIHRhYiBpbiB0aGUgY3VycmVudCBsaW5lLFxuICAvLyB1c2VkIHRvIG1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gdGFicyBpbiB0aGUgaW5kZW50YXRpb25cbiAgdGhpcy5maXJzdFRhYkluTGluZSA9IC0xO1xuXG4gIHRoaXMuZG9jdW1lbnRzID0gW107XG5cbiAgLypcbiAgdGhpcy52ZXJzaW9uO1xuICB0aGlzLmNoZWNrTGluZUJyZWFrcztcbiAgdGhpcy50YWdNYXA7XG4gIHRoaXMuYW5jaG9yTWFwO1xuICB0aGlzLnRhZztcbiAgdGhpcy5hbmNob3I7XG4gIHRoaXMua2luZDtcbiAgdGhpcy5yZXN1bHQ7Ki9cblxufVxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgdmFyIG1hcmsgPSB7XG4gICAgbmFtZTogICAgIHN0YXRlLmZpbGVuYW1lLFxuICAgIGJ1ZmZlcjogICBzdGF0ZS5pbnB1dC5zbGljZSgwLCAtMSksIC8vIG9taXQgdHJhaWxpbmcgXFwwXG4gICAgcG9zaXRpb246IHN0YXRlLnBvc2l0aW9uLFxuICAgIGxpbmU6ICAgICBzdGF0ZS5saW5lLFxuICAgIGNvbHVtbjogICBzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydFxuICB9O1xuXG4gIG1hcmsuc25pcHBldCA9IHNuaXBwZXQobWFyayk7XG5cbiAgcmV0dXJuIG5ldyBleGNlcHRpb24obWVzc2FnZSwgbWFyayk7XG59XG5cbmZ1bmN0aW9uIHRocm93RXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgdGhyb3cgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHRocm93V2FybmluZyhzdGF0ZSwgbWVzc2FnZSkge1xuICBpZiAoc3RhdGUub25XYXJuaW5nKSB7XG4gICAgc3RhdGUub25XYXJuaW5nLmNhbGwobnVsbCwgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkpO1xuICB9XG59XG5cblxudmFyIGRpcmVjdGl2ZUhhbmRsZXJzID0ge1xuXG4gIFlBTUw6IGZ1bmN0aW9uIGhhbmRsZVlhbWxEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgIHZhciBtYXRjaCwgbWFqb3IsIG1pbm9yO1xuXG4gICAgaWYgKHN0YXRlLnZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiAlWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdZQU1MIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgbWF0Y2ggPSAvXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKGFyZ3NbMF0pO1xuXG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCBhcmd1bWVudCBvZiB0aGUgWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBtYWpvciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgbWlub3IgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuXG4gICAgaWYgKG1ham9yICE9PSAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS52ZXJzaW9uID0gYXJnc1swXTtcbiAgICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSAobWlub3IgPCAyKTtcblxuICAgIGlmIChtaW5vciAhPT0gMSAmJiBtaW5vciAhPT0gMikge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cbiAgfSxcblxuICBUQUc6IGZ1bmN0aW9uIGhhbmRsZVRhZ0RpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnVEFHIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgdHdvIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIGhhbmRsZSA9IGFyZ3NbMF07XG4gICAgcHJlZml4ID0gYXJnc1sxXTtcblxuICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QoaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIGhhbmRsZSAoZmlyc3QgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQxLmNhbGwoc3RhdGUudGFnTWFwLCBoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlcmUgaXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHN1ZmZpeCBmb3IgXCInICsgaGFuZGxlICsgJ1wiIHRhZyBoYW5kbGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHByZWZpeCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBwcmVmaXggKHNlY29uZCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcHJlZml4ID0gZGVjb2RlVVJJQ29tcG9uZW50KHByZWZpeCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHByZWZpeCBpcyBtYWxmb3JtZWQ6ICcgKyBwcmVmaXgpO1xuICAgIH1cblxuICAgIHN0YXRlLnRhZ01hcFtoYW5kbGVdID0gcHJlZml4O1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBzdGFydCwgZW5kLCBjaGVja0pzb24pIHtcbiAgdmFyIF9wb3NpdGlvbiwgX2xlbmd0aCwgX2NoYXJhY3RlciwgX3Jlc3VsdDtcblxuICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICBfcmVzdWx0ID0gc3RhdGUuaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBpZiAoY2hlY2tKc29uKSB7XG4gICAgICBmb3IgKF9wb3NpdGlvbiA9IDAsIF9sZW5ndGggPSBfcmVzdWx0Lmxlbmd0aDsgX3Bvc2l0aW9uIDwgX2xlbmd0aDsgX3Bvc2l0aW9uICs9IDEpIHtcbiAgICAgICAgX2NoYXJhY3RlciA9IF9yZXN1bHQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuICAgICAgICBpZiAoIShfY2hhcmFjdGVyID09PSAweDA5IHx8XG4gICAgICAgICAgICAgICgweDIwIDw9IF9jaGFyYWN0ZXIgJiYgX2NoYXJhY3RlciA8PSAweDEwRkZGRikpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIHZhbGlkIEpTT04gY2hhcmFjdGVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFBBVFRFUk5fTk9OX1BSSU5UQUJMRS50ZXN0KF9yZXN1bHQpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlIHN0cmVhbSBjb250YWlucyBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnMnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5yZXN1bHQgKz0gX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZU1hcHBpbmdzKHN0YXRlLCBkZXN0aW5hdGlvbiwgc291cmNlLCBvdmVycmlkYWJsZUtleXMpIHtcbiAgdmFyIHNvdXJjZUtleXMsIGtleSwgaW5kZXgsIHF1YW50aXR5O1xuXG4gIGlmICghY29tbW9uLmlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IG1lcmdlIG1hcHBpbmdzOyB0aGUgcHJvdmlkZWQgc291cmNlIG9iamVjdCBpcyB1bmFjY2VwdGFibGUnKTtcbiAgfVxuXG4gIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG5cbiAgICBpZiAoIV9oYXNPd25Qcm9wZXJ0eSQxLmNhbGwoZGVzdGluYXRpb24sIGtleSkpIHtcbiAgICAgIHNldFByb3BlcnR5KGRlc3RpbmF0aW9uLCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIG92ZXJyaWRhYmxlS2V5c1trZXldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSxcbiAgc3RhcnRMaW5lLCBzdGFydExpbmVTdGFydCwgc3RhcnRQb3MpIHtcblxuICB2YXIgaW5kZXgsIHF1YW50aXR5O1xuXG4gIC8vIFRoZSBvdXRwdXQgaXMgYSBwbGFpbiBvYmplY3QgaGVyZSwgc28ga2V5cyBjYW4gb25seSBiZSBzdHJpbmdzLlxuICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQga2V5Tm9kZSB0byBhIHN0cmluZywgYnV0IGRvaW5nIHNvIGNhbiBoYW5nIHRoZSBwcm9jZXNzXG4gIC8vIChkZWVwbHkgbmVzdGVkIGFycmF5cyB0aGF0IGV4cGxvZGUgZXhwb25lbnRpYWxseSB1c2luZyBhbGlhc2VzKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Tm9kZSkpIHtcbiAgICBrZXlOb2RlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoa2V5Tm9kZSk7XG5cbiAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSBrZXlOb2RlLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Tm9kZVtpbmRleF0pKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduZXN0ZWQgYXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGluc2lkZSBrZXlzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Yga2V5Tm9kZSA9PT0gJ29iamVjdCcgJiYgX2NsYXNzKGtleU5vZGVbaW5kZXhdKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAga2V5Tm9kZVtpbmRleF0gPSAnW29iamVjdCBPYmplY3RdJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBdm9pZCBjb2RlIGV4ZWN1dGlvbiBpbiBsb2FkKCkgdmlhIHRvU3RyaW5nIHByb3BlcnR5XG4gIC8vIChzdGlsbCB1c2UgaXRzIG93biB0b1N0cmluZyBmb3IgYXJyYXlzLCB0aW1lc3RhbXBzLFxuICAvLyBhbmQgd2hhdGV2ZXIgdXNlciBzY2hlbWEgZXh0ZW5zaW9ucyBoYXBwZW4gdG8gaGF2ZSBAQHRvU3RyaW5nVGFnKVxuICBpZiAodHlwZW9mIGtleU5vZGUgPT09ICdvYmplY3QnICYmIF9jbGFzcyhrZXlOb2RlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICBrZXlOb2RlID0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuXG4gIGtleU5vZGUgPSBTdHJpbmcoa2V5Tm9kZSk7XG5cbiAgaWYgKF9yZXN1bHQgPT09IG51bGwpIHtcbiAgICBfcmVzdWx0ID0ge307XG4gIH1cblxuICBpZiAoa2V5VGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVOb2RlKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gdmFsdWVOb2RlLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGVbaW5kZXhdLCBvdmVycmlkYWJsZUtleXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGUsIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghc3RhdGUuanNvbiAmJlxuICAgICAgICAhX2hhc093blByb3BlcnR5JDEuY2FsbChvdmVycmlkYWJsZUtleXMsIGtleU5vZGUpICYmXG4gICAgICAgIF9oYXNPd25Qcm9wZXJ0eSQxLmNhbGwoX3Jlc3VsdCwga2V5Tm9kZSkpIHtcbiAgICAgIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgfHwgc3RhdGUubGluZTtcbiAgICAgIHN0YXRlLmxpbmVTdGFydCA9IHN0YXJ0TGluZVN0YXJ0IHx8IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIHN0YXRlLnBvc2l0aW9uID0gc3RhcnRQb3MgfHwgc3RhdGUucG9zaXRpb247XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRlZCBtYXBwaW5nIGtleScpO1xuICAgIH1cblxuICAgIHNldFByb3BlcnR5KF9yZXN1bHQsIGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgZGVsZXRlIG92ZXJyaWRhYmxlS2V5c1trZXlOb2RlXTtcbiAgfVxuXG4gIHJldHVybiBfcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkTGluZUJyZWFrKHN0YXRlKSB7XG4gIHZhciBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgwRC8qIENSICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MEEvKiBMRiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2EgbGluZSBicmVhayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgc3RhdGUubGluZSArPSAxO1xuICBzdGF0ZS5saW5lU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPSAtMTtcbn1cblxuZnVuY3Rpb24gc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgYWxsb3dDb21tZW50cywgY2hlY2tJbmRlbnQpIHtcbiAgdmFyIGxpbmVCcmVha3MgPSAwLFxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBpZiAoY2ggPT09IDB4MDkvKiBUYWIgKi8gJiYgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPT09IC0xKSB7XG4gICAgICAgIHN0YXRlLmZpcnN0VGFiSW5MaW5lID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93Q29tbWVudHMgJiYgY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH0gd2hpbGUgKGNoICE9PSAweDBBLyogTEYgKi8gJiYgY2ggIT09IDB4MEQvKiBDUiAqLyAmJiBjaCAhPT0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgbGluZUJyZWFrcysrO1xuICAgICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tJbmRlbnQgIT09IC0xICYmIGxpbmVCcmVha3MgIT09IDAgJiYgc3RhdGUubGluZUluZGVudCA8IGNoZWNrSW5kZW50KSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnZGVmaWNpZW50IGluZGVudGF0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gbGluZUJyZWFrcztcbn1cblxuZnVuY3Rpb24gdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gIC8vIENvbmRpdGlvbiBzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0IGlzIHRlc3RlZFxuICAvLyBpbiBwYXJlbnQgb24gZWFjaCBjYWxsLCBmb3IgZWZmaWNpZW5jeS4gTm8gbmVlZHMgdG8gdGVzdCBoZXJlIGFnYWluLlxuICBpZiAoKGNoID09PSAweDJELyogLSAqLyB8fCBjaCA9PT0gMHgyRS8qIC4gKi8pICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAxKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMikpIHtcblxuICAgIF9wb3NpdGlvbiArPSAzO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDAgfHwgaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBjb3VudCkge1xuICBpZiAoY291bnQgPT09IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICB9IGVsc2UgaWYgKGNvdW50ID4gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBjb3VudCAtIDEpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVhZFBsYWluU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50LCB3aXRoaW5GbG93Q29sbGVjdGlvbikge1xuICB2YXIgcHJlY2VkaW5nLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50LFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX2xpbmVJbmRlbnQsXG4gICAgICBfa2luZCA9IHN0YXRlLmtpbmQsXG4gICAgICBfcmVzdWx0ID0gc3RhdGUucmVzdWx0LFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoaXNfV1NfT1JfRU9MKGNoKSAgICAgIHx8XG4gICAgICBpc19GTE9XX0lORElDQVRPUihjaCkgfHxcbiAgICAgIGNoID09PSAweDIzLyogIyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjYvKiAmICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyQS8qICogKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIxLyogISAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4N0MvKiB8ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgzRS8qID4gKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI3LyogJyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjIvKiBcIiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjUvKiAlICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg0MC8qIEAgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDYwLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNy8qICcgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGV4TGVuZ3RoLFxuICAgICAgaGV4UmVzdWx0LFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjIvKiBcIiAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDIyLyogXCIgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCk7XG5cbiAgICAgICAgLy8gVE9ETzogcmV3b3JrIHRvIGlubGluZSBmbiB3aXRoIG5vIHR5cGUgY2FzdD9cbiAgICAgIH0gZWxzZSBpZiAoY2ggPCAyNTYgJiYgc2ltcGxlRXNjYXBlQ2hlY2tbY2hdKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBzaW1wbGVFc2NhcGVNYXBbY2hdO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2UgaWYgKCh0bXAgPSBlc2NhcGVkSGV4TGVuKGNoKSkgPiAwKSB7XG4gICAgICAgIGhleExlbmd0aCA9IHRtcDtcbiAgICAgICAgaGV4UmVzdWx0ID0gMDtcblxuICAgICAgICBmb3IgKDsgaGV4TGVuZ3RoID4gMDsgaGV4TGVuZ3RoLS0pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoKHRtcCA9IGZyb21IZXhDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgICAgICAgaGV4UmVzdWx0ID0gKGhleFJlc3VsdCA8PCA0KSArIHRtcDtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNoYXJGcm9tQ29kZXBvaW50KGhleFJlc3VsdCk7XG5cbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gZXNjYXBlIHNlcXVlbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgcmVhZE5leHQgPSB0cnVlLFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX3BvcyxcbiAgICAgIF90YWcgICAgID0gc3RhdGUudGFnLFxuICAgICAgX3Jlc3VsdCxcbiAgICAgIF9hbmNob3IgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgdGVybWluYXRvcixcbiAgICAgIGlzUGFpcixcbiAgICAgIGlzRXhwbGljaXRQYWlyLFxuICAgICAgaXNNYXBwaW5nLFxuICAgICAgb3ZlcnJpZGFibGVLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGtleU5vZGUsXG4gICAgICBrZXlUYWcsXG4gICAgICB2YWx1ZU5vZGUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg1RDsvKiBdICovXG4gICAgaXNNYXBwaW5nID0gZmFsc2U7XG4gICAgX3Jlc3VsdCA9IFtdO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDdCLyogeyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDdEOy8qIH0gKi9cbiAgICBpc01hcHBpbmcgPSB0cnVlO1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gdGVybWluYXRvcikge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgc3RhdGUua2luZCA9IGlzTWFwcGluZyA/ICdtYXBwaW5nJyA6ICdzZXF1ZW5jZSc7XG4gICAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghcmVhZE5leHQpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdtaXNzZWQgY29tbWEgYmV0d2VlbiBmbG93IGNvbGxlY3Rpb24gZW50cmllcycpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkMvKiAsICovKSB7XG4gICAgICAvLyBcImZsb3cgY29sbGVjdGlvbiBlbnRyaWVzIGNhbiBuZXZlciBiZSBjb21wbGV0ZWx5IGVtcHR5XCIsIGFzIHBlciBZQU1MIDEuMiwgc2VjdGlvbiA3LjRcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsIFwiZXhwZWN0ZWQgdGhlIG5vZGUgY29udGVudCwgYnV0IGZvdW5kICcsJ1wiKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKGNoID09PSAweDNGLyogPyAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cbiAgICBfbGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgIF9wb3MgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKChpc0V4cGxpY2l0UGFpciB8fCBzdGF0ZS5saW5lID09PSBfbGluZSkgJiYgY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBpc1BhaXIgPSB0cnVlO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKGlzTWFwcGluZykge1xuICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9saW5lU3RhcnQsIF9wb3MpO1xuICAgIH0gZWxzZSBpZiAoaXNQYWlyKSB7XG4gICAgICBfcmVzdWx0LnB1c2goc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgbnVsbCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9saW5lU3RhcnQsIF9wb3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdC5wdXNoKGtleU5vZGUpO1xuICAgIH1cblxuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIHJlYWROZXh0ID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhZE5leHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBmb2xkaW5nLFxuICAgICAgY2hvbXBpbmcgICAgICAgPSBDSE9NUElOR19DTElQLFxuICAgICAgZGlkUmVhZENvbnRlbnQgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJCLyogKyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9IChjaCA9PT0gMHgyQi8qICsgKi8pID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0NMSVApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB0aGUgc2NhbGFyIGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQnJlYWsgdGhpcyBgd2hpbGVgIGN5Y2xlIGFuZCBnbyB0byB0aGUgZnVuY2l0b24ncyBlcGlsb2d1ZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEZvbGRlZCBzdHlsZTogdXNlIGZhbmN5IHJ1bGVzIHRvIGhhbmRsZSBsaW5lIGJyZWFrcy5cbiAgICBpZiAoZm9sZGluZykge1xuXG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMgKG1vcmUtaW5kZW50ZWQgbGluZXMpIGFyZSBub3QgZm9sZGVkLlxuICAgICAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSAoY2YuIEV4YW1wbGUgOC4xKVxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuXG4gICAgICAvLyBFbmQgb2YgbW9yZS1pbmRlbnRlZCBibG9jay5cbiAgICAgIH0gZWxzZSBpZiAoYXRNb3JlSW5kZW50ZWQpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gSnVzdCBvbmUgbGluZSBicmVhayAtIHBlcmNlaXZlIGFzIHRoZSBzYW1lIGxpbmUuXG4gICAgICB9IGVsc2UgaWYgKGVtcHR5TGluZXMgPT09IDApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB3ZSBoYXZlIGFscmVhZHkgcmVhZCBzb21lIHNjYWxhciBjb250ZW50LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgLy8gU2V2ZXJhbCBsaW5lIGJyZWFrcyAtIHBlcmNlaXZlIGFzIGRpZmZlcmVudCBsaW5lcy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICAgIH1cblxuICAgIC8vIExpdGVyYWwgc3R5bGU6IGp1c3QgYWRkIGV4YWN0IG51bWJlciBvZiBsaW5lIGJyZWFrcyBiZXR3ZWVuIGNvbnRlbnQgbGluZXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgYWxsIGxpbmUgYnJlYWtzIGV4Y2VwdCB0aGUgaGVhZGVyIGxpbmUgYnJlYWsuXG4gICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgIH1cblxuICAgIGRpZFJlYWRDb250ZW50ID0gdHJ1ZTtcbiAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgZW1wdHlMaW5lcyA9IDA7XG4gICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIF9saW5lLFxuICAgICAgX3RhZyAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgID0gW10sXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBkZXRlY3RlZCAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIC8vIHRoZXJlIGlzIGEgbGVhZGluZyB0YWIgYmVmb3JlIHRoaXMgdG9rZW4sIHNvIGl0IGNhbid0IGJlIGEgYmxvY2sgc2VxdWVuY2UvbWFwcGluZztcbiAgLy8gaXQgY2FuIHN0aWxsIGJlIGZsb3cgc2VxdWVuY2UvbWFwcGluZyBvciBhIHNjYWxhclxuICBpZiAoc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKHN0YXRlLmZpcnN0VGFiSW5MaW5lICE9PSAtMSkge1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGF0ZS5maXJzdFRhYkluTGluZTtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWIgY2hhcmFjdGVycyBtdXN0IG5vdCBiZSB1c2VkIGluIGluZGVudGF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGNoICE9PSAweDJELyogLSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKCFpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA8PSBub2RlSW5kZW50KSB7XG4gICAgICAgIF9yZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgX3Jlc3VsdC5wdXNoKHN0YXRlLnJlc3VsdCk7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ3NlcXVlbmNlJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfa2V5TGluZSxcbiAgICAgIF9rZXlMaW5lU3RhcnQsXG4gICAgICBfa2V5UG9zLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICAgICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgICAgID0ge30sXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAga2V5VGFnICAgICAgICA9IG51bGwsXG4gICAgICBrZXlOb2RlICAgICAgID0gbnVsbCxcbiAgICAgIHZhbHVlTm9kZSAgICAgPSBudWxsLFxuICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWQgICAgICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgLy8gdGhlcmUgaXMgYSBsZWFkaW5nIHRhYiBiZWZvcmUgdGhpcyB0b2tlbiwgc28gaXQgY2FuJ3QgYmUgYSBibG9jayBzZXF1ZW5jZS9tYXBwaW5nO1xuICAvLyBpdCBjYW4gc3RpbGwgYmUgZmxvdyBzZXF1ZW5jZS9tYXBwaW5nIG9yIGEgc2NhbGFyXG4gIGlmIChzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoIWF0RXhwbGljaXRLZXkgJiYgc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXRlLmZpcnN0VGFiSW5MaW5lO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhYiBjaGFyYWN0ZXJzIG11c3Qgbm90IGJlIHVzZWQgaW4gaW5kZW50YXRpb24nKTtcbiAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lOyAvLyBTYXZlIHRoZSBjdXJyZW50IGxpbmUuXG5cbiAgICAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cbiAgICBpZiAoKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgzQS8qIDogKi8pICYmIGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIC8vIGkuZS4gMHgzQS8qIDogKi8gPT09IGNoYXJhY3RlciBhZnRlciB0aGUgZXhwbGljaXQga2V5LlxuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbmNvbXBsZXRlIGV4cGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBrZXkgbm9kZSBpcyBtaXNzZWQ7IG9yIGZvbGxvd2VkIGJ5IGEgbm9uLXRhYnVsYXRlZCBlbXB0eSBsaW5lJyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gICAgICBjaCA9IGZvbGxvd2luZztcblxuICAgIC8vXG4gICAgLy8gSW1wbGljaXQgbm90YXRpb24gY2FzZS4gRmxvdy1zdHlsZSBub2RlIGFzIHRoZSBrZXkgZmlyc3QsIHRoZW4gXCI6XCIsIGFuZCB0aGUgdmFsdWUuXG4gICAgLy9cbiAgICB9IGVsc2Uge1xuICAgICAgX2tleUxpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2tleUxpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9rZXlQb3MgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgaWYgKCFjb21wb3NlTm9kZShzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX09VVCwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgIC8vIE5laXRoZXIgaW1wbGljaXQgbm9yIGV4cGxpY2l0IG5vdGF0aW9uLlxuICAgICAgICAvLyBSZWFkaW5nIGlzIGRvbmUuIEdvIHRvIHRoZSBlcGlsb2d1ZS5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBpcyBleHBlY3RlZCBhZnRlciB0aGUga2V5LXZhbHVlIHNlcGFyYXRvciB3aXRoaW4gYSBibG9jayBtYXBwaW5nJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gICAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IGZhbHNlO1xuICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGEgYmxvY2sgbWFwcGluZyBlbnRyeTsgYSBtdWx0aWxpbmUga2V5IG1heSBub3QgYmUgYW4gaW1wbGljaXQga2V5Jyk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIENvbW1vbiByZWFkaW5nIGNvZGUgZm9yIGJvdGggZXhwbGljaXQgYW5kIGltcGxpY2l0IG5vdGF0aW9ucy5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkge1xuICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgX2tleUxpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgICBfa2V5TGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgICBfa2V5UG9zID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19PVVQsIHRydWUsIGFsbG93Q29tcGFjdCkpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiAoY2ggIT09IDApKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgbWFwcGluZyBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIEVwaWxvZ3VlLlxuICAvL1xuXG4gIC8vIFNwZWNpYWwgY2FzZTogbGFzdCBtYXBwaW5nJ3Mgbm9kZSBjb250YWlucyBvbmx5IHRoZSBrZXkgaW4gZXhwbGljaXQgbm90YXRpb24uXG4gIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwsIF9rZXlMaW5lLCBfa2V5TGluZVN0YXJ0LCBfa2V5UG9zKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ21hcHBpbmcnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgaXNWZXJiYXRpbSA9IGZhbHNlLFxuICAgICAgaXNOYW1lZCAgICA9IGZhbHNlLFxuICAgICAgdGFnSGFuZGxlLFxuICAgICAgdGFnTmFtZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIxLyogISAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS50YWcgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4M0MvKiA8ICovKSB7XG4gICAgaXNWZXJiYXRpbSA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgaXNOYW1lZCA9IHRydWU7XG4gICAgdGFnSGFuZGxlID0gJyEhJztcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGNoICE9PSAwICYmIGNoICE9PSAweDNFLyogPiAqLyk7XG5cbiAgICBpZiAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgdmVyYmF0aW0gdGFnJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgICAgIGlmICghaXNOYW1lZCkge1xuICAgICAgICAgIHRhZ0hhbmRsZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiAtIDEsIHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lZCB0YWcgaGFuZGxlIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoUEFUVEVSTl9GTE9XX0lORElDQVRPUlMudGVzdCh0YWdOYW1lKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWdOYW1lICYmICFQQVRURVJOX1RBR19VUkkudGVzdCh0YWdOYW1lKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGFnTmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudCh0YWdOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGlzIG1hbGZvcm1lZDogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBzdGF0ZS50YWcgPSB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChzdGF0ZS50YWdNYXAsIHRhZ0hhbmRsZSkpIHtcbiAgICBzdGF0ZS50YWcgPSBzdGF0ZS50YWdNYXBbdGFnSGFuZGxlXSArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchJykge1xuICAgIHN0YXRlLnRhZyA9ICchJyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchIScpIHtcbiAgICBzdGF0ZS50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5kZWNsYXJlZCB0YWcgaGFuZGxlIFwiJyArIHRhZ0hhbmRsZSArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjYvKiAmICovKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhbiBhbmNob3IgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFuY2hvciBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XG4gIH1cblxuICBzdGF0ZS5hbmNob3IgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbGlhcyhzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLCBhbGlhcyxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDJBLyogKiAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFsaWFzIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIGFsaWFzID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKCFfaGFzT3duUHJvcGVydHkkMS5jYWxsKHN0YXRlLmFuY2hvck1hcCwgYWxpYXMpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicgKyBhbGlhcyArICdcIicpO1xuICB9XG5cbiAgc3RhdGUucmVzdWx0ID0gc3RhdGUuYW5jaG9yTWFwW2FsaWFzXTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZU5vZGUoc3RhdGUsIHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcbiAgdmFyIGFsbG93QmxvY2tTdHlsZXMsXG4gICAgICBhbGxvd0Jsb2NrU2NhbGFycyxcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcbiAgICAgIGluZGVudFN0YXR1cyA9IDEsIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gICAgICBhdE5ld0xpbmUgID0gZmFsc2UsXG4gICAgICBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICB0eXBlSW5kZXgsXG4gICAgICB0eXBlUXVhbnRpdHksXG4gICAgICB0eXBlTGlzdCxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQ7XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ29wZW4nLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgfHwgc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRTdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyA9PT0gbnVsbCkge1xuICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICB9IGVsc2UgaWYgKHN0YXRlLnRhZyA9PT0gJz8nKSB7XG4gICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXG4gICAgLy8gbm9uLXNwZWNpZmljIHRhZyBpcyBvbmx5IGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdG8gcGxhaW4gc2NhbGFycy5cbiAgICAvL1xuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBjaGVjayBraW5kIGNvbmZvcm1pdHkgaW4gY2FzZSB1c2VyIGV4cGxpY2l0bHkgYXNzaWducyAnPydcbiAgICAvLyB0YWcsIGZvciBleGFtcGxlIGxpa2UgdGhpczogXCIhPD8+IFswXVwiXG4gICAgLy9cbiAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHN0YXRlLmtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITw/PiB0YWc7IGl0IHNob3VsZCBiZSBcInNjYWxhclwiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgIH1cblxuICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW3R5cGVJbmRleF07XG5cbiAgICAgIGlmICh0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdGUudGFnICE9PSAnIScpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ10sIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ11bc3RhdGUudGFnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9va2luZyBmb3IgbXVsdGkgdHlwZVxuICAgICAgdHlwZSA9IG51bGw7XG4gICAgICB0eXBlTGlzdCA9IHN0YXRlLnR5cGVNYXAubXVsdGlbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXTtcblxuICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSB0eXBlTGlzdC5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgICAgaWYgKHN0YXRlLnRhZy5zbGljZSgwLCB0eXBlTGlzdFt0eXBlSW5kZXhdLnRhZy5sZW5ndGgpID09PSB0eXBlTGlzdFt0eXBlSW5kZXhdLnRhZykge1xuICAgICAgICAgIHR5cGUgPSB0eXBlTGlzdFt0eXBlSW5kZXhdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biB0YWcgITwnICsgc3RhdGUudGFnICsgJz4nKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHR5cGUua2luZCAhPT0gc3RhdGUua2luZCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8JyArIHN0YXRlLnRhZyArICc+IHRhZzsgaXQgc2hvdWxkIGJlIFwiJyArIHR5cGUua2luZCArICdcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQsIHN0YXRlLnRhZykpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IHJlc29sdmUgYSBub2RlIHdpdGggITwnICsgc3RhdGUudGFnICsgJz4gZXhwbGljaXQgdGFnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCwgc3RhdGUudGFnKTtcbiAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ2Nsb3NlJywgc3RhdGUpO1xuICB9XG4gIHJldHVybiBzdGF0ZS50YWcgIT09IG51bGwgfHwgIHN0YXRlLmFuY2hvciAhPT0gbnVsbCB8fCBoYXNDb250ZW50O1xufVxuXG5mdW5jdGlvbiByZWFkRG9jdW1lbnQoc3RhdGUpIHtcbiAgdmFyIGRvY3VtZW50U3RhcnQgPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIF9wb3NpdGlvbixcbiAgICAgIGRpcmVjdGl2ZU5hbWUsXG4gICAgICBkaXJlY3RpdmVBcmdzLFxuICAgICAgaGFzRGlyZWN0aXZlcyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgc3RhdGUudmVyc2lvbiA9IG51bGw7XG4gIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IHN0YXRlLmxlZ2FjeTtcbiAgc3RhdGUudGFnTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RhdGUuYW5jaG9yTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gMCB8fCBjaCAhPT0gMHgyNS8qICUgKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGRpcmVjdGl2ZU5hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICBkaXJlY3RpdmVBcmdzID0gW107XG5cbiAgICBpZiAoZGlyZWN0aXZlTmFtZS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX0VPTChjaCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzX0VPTChjaCkpIGJyZWFrO1xuXG4gICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0aXZlQXJncy5wdXNoKHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDApIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQxLmNhbGwoZGlyZWN0aXZlSGFuZGxlcnMsIGRpcmVjdGl2ZU5hbWUpKSB7XG4gICAgICBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmVOYW1lXShzdGF0ZSwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJyArIGRpcmVjdGl2ZU5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IDAgJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pICAgICA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKSA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAyKSA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICB9IGVsc2UgaWYgKGhhc0RpcmVjdGl2ZXMpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlcyBlbmQgbWFyayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgY29tcG9zZU5vZGUoc3RhdGUsIHN0YXRlLmxpbmVJbmRlbnQgLSAxLCBDT05URVhUX0JMT0NLX09VVCwgZmFsc2UsIHRydWUpO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmNoZWNrTGluZUJyZWFrcyAmJlxuICAgICAgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MudGVzdChzdGF0ZS5pbnB1dC5zbGljZShkb2N1bWVudFN0YXJ0LCBzdGF0ZS5wb3NpdGlvbikpKSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnbm9uLUFTQ0lJIGxpbmUgYnJlYWtzIGFyZSBpbnRlcnByZXRlZCBhcyBjb250ZW50Jyk7XG4gIH1cblxuICBzdGF0ZS5kb2N1bWVudHMucHVzaChzdGF0ZS5yZXN1bHQpO1xuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcblxuICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyRS8qIC4gKi8pIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdlbmQgb2YgdGhlIHN0cmVhbSBvciBhIGRvY3VtZW50IHNlcGFyYXRvciBpcyBleHBlY3RlZCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5wdXQubGVuZ3RoICE9PSAwKSB7XG5cbiAgICAvLyBBZGQgdGFpbGluZyBgXFxuYCBpZiBub3QgZXhpc3RzXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEEvKiBMRiAqLyAmJlxuICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBELyogQ1IgKi8pIHtcbiAgICAgIGlucHV0ICs9ICdcXG4nO1xuICAgIH1cblxuICAgIC8vIFN0cmlwIEJPTVxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlJDEoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIHZhciBudWxscG9zID0gaW5wdXQuaW5kZXhPZignXFwwJyk7XG5cbiAgaWYgKG51bGxwb3MgIT09IC0xKSB7XG4gICAgc3RhdGUucG9zaXRpb24gPSBudWxscG9zO1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdudWxsIGJ5dGUgaXMgbm90IGFsbG93ZWQgaW4gaW5wdXQnKTtcbiAgfVxuXG4gIC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG4gIHN0YXRlLmlucHV0ICs9ICdcXDAnO1xuXG4gIHdoaWxlIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICByZWFkRG9jdW1lbnQoc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmRvY3VtZW50cztcbn1cblxuXG5mdW5jdGlvbiBsb2FkQWxsJDEoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGlmIChpdGVyYXRvciAhPT0gbnVsbCAmJiB0eXBlb2YgaXRlcmF0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBpdGVyYXRvcjtcbiAgICBpdGVyYXRvciA9IG51bGw7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkb2N1bWVudHM7XG4gIH1cblxuICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGRvY3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgaXRlcmF0b3IoZG9jdW1lbnRzW2luZGV4XSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBkb2N1bWVudHNbMF07XG4gIH1cbiAgdGhyb3cgbmV3IGV4Y2VwdGlvbignZXhwZWN0ZWQgYSBzaW5nbGUgZG9jdW1lbnQgaW4gdGhlIHN0cmVhbSwgYnV0IGZvdW5kIG1vcmUnKTtcbn1cblxuXG52YXIgbG9hZEFsbF8xID0gbG9hZEFsbCQxO1xudmFyIGxvYWRfMSAgICA9IGxvYWQkMTtcblxudmFyIGxvYWRlciA9IHtcblx0bG9hZEFsbDogbG9hZEFsbF8xLFxuXHRsb2FkOiBsb2FkXzFcbn07XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG5cblxuXG5cbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBDSEFSX0JPTSAgICAgICAgICAgICAgICAgID0gMHhGRUZGO1xudmFyIENIQVJfVEFCICAgICAgICAgICAgICAgICAgPSAweDA5OyAvKiBUYWIgKi9cbnZhciBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgID0gMHgwQTsgLyogTEYgKi9cbnZhciBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgID0gMHgwRDsgLyogQ1IgKi9cbnZhciBDSEFSX1NQQUNFICAgICAgICAgICAgICAgID0gMHgyMDsgLyogU3BhY2UgKi9cbnZhciBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgID0gMHgyMTsgLyogISAqL1xudmFyIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPSAweDIyOyAvKiBcIiAqL1xudmFyIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPSAweDIzOyAvKiAjICovXG52YXIgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICA9IDB4MjU7IC8qICUgKi9cbnZhciBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID0gMHgyNjsgLyogJiAqL1xudmFyIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPSAweDI3OyAvKiAnICovXG52YXIgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICA9IDB4MkE7IC8qICogKi9cbnZhciBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID0gMHgyQzsgLyogLCAqL1xudmFyIENIQVJfTUlOVVMgICAgICAgICAgICAgICAgPSAweDJEOyAvKiAtICovXG52YXIgQ0hBUl9DT0xPTiAgICAgICAgICAgICAgICA9IDB4M0E7IC8qIDogKi9cbnZhciBDSEFSX0VRVUFMUyAgICAgICAgICAgICAgID0gMHgzRDsgLyogPSAqL1xudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXG52YXIgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9IDB4M0Y7IC8qID8gKi9cbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgLyogQCAqL1xudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7IC8qIF0gKi9cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID0gMHg2MDsgLyogYCAqL1xudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7IC8qIHwgKi9cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID0gMHg3RDsgLyogfSAqL1xuXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xuXG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDBdICAgPSAnXFxcXDAnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA3XSAgID0gJ1xcXFxhJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOF0gICA9ICdcXFxcYic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDldICAgPSAnXFxcXHQnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBBXSAgID0gJ1xcXFxuJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQl0gICA9ICdcXFxcdic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MENdICAgPSAnXFxcXGYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBEXSAgID0gJ1xcXFxyJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgxQl0gICA9ICdcXFxcZSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjJdICAgPSAnXFxcXFwiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg1Q10gICA9ICdcXFxcXFxcXCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4ODVdICAgPSAnXFxcXE4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweEEwXSAgID0gJ1xcXFxfJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI4XSA9ICdcXFxcTCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOV0gPSAnXFxcXFAnO1xuXG52YXIgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVggPSBbXG4gICd5JywgJ1knLCAneWVzJywgJ1llcycsICdZRVMnLCAnb24nLCAnT24nLCAnT04nLFxuICAnbicsICdOJywgJ25vJywgJ05vJywgJ05PJywgJ29mZicsICdPZmYnLCAnT0ZGJ1xuXTtcblxudmFyIERFUFJFQ0FURURfQkFTRTYwX1NZTlRBWCA9IC9eWy0rXT9bMC05X10rKD86OlswLTlfXSspKyg/OlxcLlswLTlfXSopPyQvO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVNYXAoc2NoZW1hLCBtYXApIHtcbiAgdmFyIHJlc3VsdCwga2V5cywgaW5kZXgsIGxlbmd0aCwgdGFnLCBzdHlsZSwgdHlwZTtcblxuICBpZiAobWFwID09PSBudWxsKSByZXR1cm4ge307XG5cbiAgcmVzdWx0ID0ge307XG4gIGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0YWcgPSBrZXlzW2luZGV4XTtcbiAgICBzdHlsZSA9IFN0cmluZyhtYXBbdGFnXSk7XG5cbiAgICBpZiAodGFnLnNsaWNlKDAsIDIpID09PSAnISEnKSB7XG4gICAgICB0YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZy5zbGljZSgyKTtcbiAgICB9XG4gICAgdHlwZSA9IHNjaGVtYS5jb21waWxlZFR5cGVNYXBbJ2ZhbGxiYWNrJ11bdGFnXTtcblxuICAgIGlmICh0eXBlICYmIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUuc3R5bGVBbGlhc2VzLCBzdHlsZSkpIHtcbiAgICAgIHN0eWxlID0gdHlwZS5zdHlsZUFsaWFzZXNbc3R5bGVdO1xuICAgIH1cblxuICAgIHJlc3VsdFt0YWddID0gc3R5bGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVIZXgoY2hhcmFjdGVyKSB7XG4gIHZhciBzdHJpbmcsIGhhbmRsZSwgbGVuZ3RoO1xuXG4gIHN0cmluZyA9IGNoYXJhY3Rlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuICBpZiAoY2hhcmFjdGVyIDw9IDB4RkYpIHtcbiAgICBoYW5kbGUgPSAneCc7XG4gICAgbGVuZ3RoID0gMjtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGKSB7XG4gICAgaGFuZGxlID0gJ3UnO1xuICAgIGxlbmd0aCA9IDQ7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRkZGRkYpIHtcbiAgICBoYW5kbGUgPSAnVSc7XG4gICAgbGVuZ3RoID0gODtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdjb2RlIHBvaW50IHdpdGhpbiBhIHN0cmluZyBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiAweEZGRkZGRkZGJyk7XG4gIH1cblxuICByZXR1cm4gJ1xcXFwnICsgaGFuZGxlICsgY29tbW9uLnJlcGVhdCgnMCcsIGxlbmd0aCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5cbnZhciBRVU9USU5HX1RZUEVfU0lOR0xFID0gMSxcbiAgICBRVU9USU5HX1RZUEVfRE9VQkxFID0gMjtcblxuZnVuY3Rpb24gU3RhdGUob3B0aW9ucykge1xuICB0aGlzLnNjaGVtYSAgICAgICAgPSBvcHRpb25zWydzY2hlbWEnXSB8fCBfZGVmYXVsdDtcbiAgdGhpcy5pbmRlbnQgICAgICAgID0gTWF0aC5tYXgoMSwgKG9wdGlvbnNbJ2luZGVudCddIHx8IDIpKTtcbiAgdGhpcy5ub0FycmF5SW5kZW50ID0gb3B0aW9uc1snbm9BcnJheUluZGVudCddIHx8IGZhbHNlO1xuICB0aGlzLnNraXBJbnZhbGlkICAgPSBvcHRpb25zWydza2lwSW52YWxpZCddIHx8IGZhbHNlO1xuICB0aGlzLmZsb3dMZXZlbCAgICAgPSAoY29tbW9uLmlzTm90aGluZyhvcHRpb25zWydmbG93TGV2ZWwnXSkgPyAtMSA6IG9wdGlvbnNbJ2Zsb3dMZXZlbCddKTtcbiAgdGhpcy5zdHlsZU1hcCAgICAgID0gY29tcGlsZVN0eWxlTWFwKHRoaXMuc2NoZW1hLCBvcHRpb25zWydzdHlsZXMnXSB8fCBudWxsKTtcbiAgdGhpcy5zb3J0S2V5cyAgICAgID0gb3B0aW9uc1snc29ydEtleXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5saW5lV2lkdGggICAgID0gb3B0aW9uc1snbGluZVdpZHRoJ10gfHwgODA7XG4gIHRoaXMubm9SZWZzICAgICAgICA9IG9wdGlvbnNbJ25vUmVmcyddIHx8IGZhbHNlO1xuICB0aGlzLm5vQ29tcGF0TW9kZSAgPSBvcHRpb25zWydub0NvbXBhdE1vZGUnXSB8fCBmYWxzZTtcbiAgdGhpcy5jb25kZW5zZUZsb3cgID0gb3B0aW9uc1snY29uZGVuc2VGbG93J10gfHwgZmFsc2U7XG4gIHRoaXMucXVvdGluZ1R5cGUgICA9IG9wdGlvbnNbJ3F1b3RpbmdUeXBlJ10gPT09ICdcIicgPyBRVU9USU5HX1RZUEVfRE9VQkxFIDogUVVPVElOR19UWVBFX1NJTkdMRTtcbiAgdGhpcy5mb3JjZVF1b3RlcyAgID0gb3B0aW9uc1snZm9yY2VRdW90ZXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5yZXBsYWNlciAgICAgID0gdHlwZW9mIG9wdGlvbnNbJ3JlcGxhY2VyJ10gPT09ICdmdW5jdGlvbicgPyBvcHRpb25zWydyZXBsYWNlciddIDogbnVsbDtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLmV4cGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEV4cGxpY2l0O1xuXG4gIHRoaXMudGFnID0gbnVsbDtcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICB0aGlzLmR1cGxpY2F0ZXMgPSBbXTtcbiAgdGhpcy51c2VkRHVwbGljYXRlcyA9IG51bGw7XG59XG5cbi8vIEluZGVudHMgZXZlcnkgbGluZSBpbiBhIHN0cmluZy4gRW1wdHkgbGluZXMgKFxcbiBvbmx5KSBhcmUgbm90IGluZGVudGVkLlxuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0cmluZywgc3BhY2VzKSB7XG4gIHZhciBpbmQgPSBjb21tb24ucmVwZWF0KCcgJywgc3BhY2VzKSxcbiAgICAgIHBvc2l0aW9uID0gMCxcbiAgICAgIG5leHQgPSAtMSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbGluZSxcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgbmV4dCA9IHN0cmluZy5pbmRleE9mKCdcXG4nLCBwb3NpdGlvbik7XG4gICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBuZXh0ICsgMSk7XG4gICAgICBwb3NpdGlvbiA9IG5leHQgKyAxO1xuICAgIH1cblxuICAgIGlmIChsaW5lLmxlbmd0aCAmJiBsaW5lICE9PSAnXFxuJykgcmVzdWx0ICs9IGluZDtcblxuICAgIHJlc3VsdCArPSBsaW5lO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpIHtcbiAgcmV0dXJuICdcXG4nICsgY29tbW9uLnJlcGVhdCgnICcsIHN0YXRlLmluZGVudCAqIGxldmVsKTtcbn1cblxuZnVuY3Rpb24gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHIpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIHR5cGU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW2luZGV4XTtcblxuICAgIGlmICh0eXBlLnJlc29sdmUoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBbMzNdIHMtd2hpdGUgOjo9IHMtc3BhY2UgfCBzLXRhYlxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGMgPT09IENIQVJfU1BBQ0UgfHwgYyA9PT0gQ0hBUl9UQUI7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGNhbiBiZSBwcmludGVkIHdpdGhvdXQgZXNjYXBpbmcuXG4vLyBGcm9tIFlBTUwgMS4yOiBcImFueSBhbGxvd2VkIGNoYXJhY3RlcnMga25vd24gdG8gYmUgbm9uLXByaW50YWJsZVxuLy8gc2hvdWxkIGFsc28gYmUgZXNjYXBlZC4gW0hvd2V2ZXIsXSBUaGlzIGlzbuKAmXQgbWFuZGF0b3J5XCJcbi8vIERlcml2ZWQgZnJvbSBuYi1jaGFyIC0gXFx0IC0gI3g4NSAtICN4QTAgLSAjeDIwMjggLSAjeDIwMjkuXG5mdW5jdGlvbiBpc1ByaW50YWJsZShjKSB7XG4gIHJldHVybiAgKDB4MDAwMjAgPD0gYyAmJiBjIDw9IDB4MDAwMDdFKVxuICAgICAgfHwgKCgweDAwMEExIDw9IGMgJiYgYyA8PSAweDAwRDdGRikgJiYgYyAhPT0gMHgyMDI4ICYmIGMgIT09IDB4MjAyOSlcbiAgICAgIHx8ICgoMHgwRTAwMCA8PSBjICYmIGMgPD0gMHgwMEZGRkQpICYmIGMgIT09IENIQVJfQk9NKVxuICAgICAgfHwgICgweDEwMDAwIDw9IGMgJiYgYyA8PSAweDEwRkZGRik7XG59XG5cbi8vIFszNF0gbnMtY2hhciA6Oj0gbmItY2hhciAtIHMtd2hpdGVcbi8vIFsyN10gbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFya1xuLy8gWzI2XSBiLWNoYXIgIDo6PSBiLWxpbmUtZmVlZCB8IGItY2FycmlhZ2UtcmV0dXJuXG4vLyBJbmNsdWRpbmcgcy13aGl0ZSAoZm9yIHNvbWUgcmVhc29uLCBleGFtcGxlcyBkb2Vzbid0IG1hdGNoIHNwZWNzIGluIHRoaXMgYXNwZWN0KVxuLy8gbnMtY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWxpbmUtZmVlZCAtIGItY2FycmlhZ2UtcmV0dXJuIC0gYy1ieXRlLW9yZGVyLW1hcmtcbmZ1bmN0aW9uIGlzTnNDaGFyT3JXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpXG4gICAgJiYgYyAhPT0gQ0hBUl9CT01cbiAgICAvLyAtIGItY2hhclxuICAgICYmIGMgIT09IENIQVJfQ0FSUklBR0VfUkVUVVJOXG4gICAgJiYgYyAhPT0gQ0hBUl9MSU5FX0ZFRUQ7XG59XG5cbi8vIFsxMjddICBucy1wbGFpbi1zYWZlKGMpIDo6PSBjID0gZmxvdy1vdXQgIOKHkiBucy1wbGFpbi1zYWZlLW91dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBmbG93LWluICAg4oeSIG5zLXBsYWluLXNhZmUtaW5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gYmxvY2sta2V5IOKHkiBucy1wbGFpbi1zYWZlLW91dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBmbG93LWtleSAg4oeSIG5zLXBsYWluLXNhZmUtaW5cbi8vIFsxMjhdIG5zLXBsYWluLXNhZmUtb3V0IDo6PSBucy1jaGFyXG4vLyBbMTI5XSAgbnMtcGxhaW4tc2FmZS1pbiA6Oj0gbnMtY2hhciAtIGMtZmxvdy1pbmRpY2F0b3Jcbi8vIFsxMzBdICBucy1wbGFpbi1jaGFyKGMpIDo6PSAgKCBucy1wbGFpbi1zYWZlKGMpIC0g4oCcOuKAnSAtIOKAnCPigJ0gKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoIC8qIEFuIG5zLWNoYXIgcHJlY2VkaW5nICovIOKAnCPigJ0gKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoIOKAnDrigJ0gLyogRm9sbG93ZWQgYnkgYW4gbnMtcGxhaW4tc2FmZShjKSAqLyApXG5mdW5jdGlvbiBpc1BsYWluU2FmZShjLCBwcmV2LCBpbmJsb2NrKSB7XG4gIHZhciBjSXNOc0NoYXJPcldoaXRlc3BhY2UgPSBpc05zQ2hhck9yV2hpdGVzcGFjZShjKTtcbiAgdmFyIGNJc05zQ2hhciA9IGNJc05zQ2hhck9yV2hpdGVzcGFjZSAmJiAhaXNXaGl0ZXNwYWNlKGMpO1xuICByZXR1cm4gKFxuICAgIC8vIG5zLXBsYWluLXNhZmVcbiAgICBpbmJsb2NrID8gLy8gYyA9IGZsb3ctaW5cbiAgICAgIGNJc05zQ2hhck9yV2hpdGVzcGFjZVxuICAgICAgOiBjSXNOc0NoYXJPcldoaXRlc3BhY2VcbiAgICAgICAgLy8gLSBjLWZsb3ctaW5kaWNhdG9yXG4gICAgICAgICYmIGMgIT09IENIQVJfQ09NTUFcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUXG4gICAgICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUXG4gIClcbiAgICAvLyBucy1wbGFpbi1jaGFyXG4gICAgJiYgYyAhPT0gQ0hBUl9TSEFSUCAvLyBmYWxzZSBvbiAnIydcbiAgICAmJiAhKHByZXYgPT09IENIQVJfQ09MT04gJiYgIWNJc05zQ2hhcikgLy8gZmFsc2Ugb24gJzogJ1xuICAgIHx8IChpc05zQ2hhck9yV2hpdGVzcGFjZShwcmV2KSAmJiAhaXNXaGl0ZXNwYWNlKHByZXYpICYmIGMgPT09IENIQVJfU0hBUlApIC8vIGNoYW5nZSB0byB0cnVlIG9uICdbXiBdIydcbiAgICB8fCAocHJldiA9PT0gQ0hBUl9DT0xPTiAmJiBjSXNOc0NoYXIpOyAvLyBjaGFuZ2UgdG8gdHJ1ZSBvbiAnOlteIF0nXG59XG5cbi8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlRmlyc3QoYykge1xuICAvLyBVc2VzIGEgc3Vic2V0IG9mIG5zLWNoYXIgLSBjLWluZGljYXRvclxuICAvLyB3aGVyZSBucy1jaGFyID0gbmItY2hhciAtIHMtd2hpdGUuXG4gIC8vIE5vIHN1cHBvcnQgb2YgKCAoIOKAnD/igJ0gfCDigJw64oCdIHwg4oCcLeKAnSApIC8qIEZvbGxvd2VkIGJ5IGFuIG5zLXBsYWluLXNhZmUoYykpICovICkgcGFydFxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gQ0hBUl9CT01cbiAgICAmJiAhaXNXaGl0ZXNwYWNlKGMpIC8vIC0gcy13aGl0ZVxuICAgIC8vIC0gKGMtaW5kaWNhdG9yIDo6PVxuICAgIC8vIOKAnC3igJ0gfCDigJw/4oCdIHwg4oCcOuKAnSB8IOKAnCzigJ0gfCDigJxb4oCdIHwg4oCcXeKAnSB8IOKAnHvigJ0gfCDigJx94oCdXG4gICAgJiYgYyAhPT0gQ0hBUl9NSU5VU1xuICAgICYmIGMgIT09IENIQVJfUVVFU1RJT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTE9OXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVFxuICAgIC8vIHwg4oCcI+KAnSB8IOKAnCbigJ0gfCDigJwq4oCdIHwg4oCcIeKAnSB8IOKAnHzigJ0gfCDigJw94oCdIHwg4oCcPuKAnSB8IOKAnCfigJ0gfCDigJxcIuKAnVxuICAgICYmIGMgIT09IENIQVJfU0hBUlBcbiAgICAmJiBjICE9PSBDSEFSX0FNUEVSU0FORFxuICAgICYmIGMgIT09IENIQVJfQVNURVJJU0tcbiAgICAmJiBjICE9PSBDSEFSX0VYQ0xBTUFUSU9OXG4gICAgJiYgYyAhPT0gQ0hBUl9WRVJUSUNBTF9MSU5FXG4gICAgJiYgYyAhPT0gQ0hBUl9FUVVBTFNcbiAgICAmJiBjICE9PSBDSEFSX0dSRUFURVJfVEhBTlxuICAgICYmIGMgIT09IENIQVJfU0lOR0xFX1FVT1RFXG4gICAgJiYgYyAhPT0gQ0hBUl9ET1VCTEVfUVVPVEVcbiAgICAvLyB8IOKAnCXigJ0gfCDigJxA4oCdIHwg4oCcYOKAnSlcbiAgICAmJiBjICE9PSBDSEFSX1BFUkNFTlRcbiAgICAmJiBjICE9PSBDSEFSX0NPTU1FUkNJQUxfQVRcbiAgICAmJiBjICE9PSBDSEFSX0dSQVZFX0FDQ0VOVDtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhcyB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gcGxhaW4gc3R5bGUuXG5mdW5jdGlvbiBpc1BsYWluU2FmZUxhc3QoYykge1xuICAvLyBqdXN0IG5vdCB3aGl0ZXNwYWNlIG9yIGNvbG9uLCBpdCB3aWxsIGJlIGNoZWNrZWQgdG8gYmUgcGxhaW4gY2hhcmFjdGVyIGxhdGVyXG4gIHJldHVybiAhaXNXaGl0ZXNwYWNlKGMpICYmIGMgIT09IENIQVJfQ09MT047XG59XG5cbi8vIFNhbWUgYXMgJ3N0cmluZycuY29kZVBvaW50QXQocG9zKSwgYnV0IHdvcmtzIGluIG9sZGVyIGJyb3dzZXJzLlxuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyaW5nLCBwb3MpIHtcbiAgdmFyIGZpcnN0ID0gc3RyaW5nLmNoYXJDb2RlQXQocG9zKSwgc2Vjb25kO1xuICBpZiAoZmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRiAmJiBwb3MgKyAxIDwgc3RyaW5nLmxlbmd0aCkge1xuICAgIHNlY29uZCA9IHN0cmluZy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcbiAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgcmV0dXJuIChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaXJzdDtcbn1cblxuLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBpcyByZXF1aXJlZC5cbmZ1bmN0aW9uIG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSB7XG4gIHZhciBsZWFkaW5nU3BhY2VSZSA9IC9eXFxuKiAvO1xuICByZXR1cm4gbGVhZGluZ1NwYWNlUmUudGVzdChzdHJpbmcpO1xufVxuXG52YXIgU1RZTEVfUExBSU4gICA9IDEsXG4gICAgU1RZTEVfU0lOR0xFICA9IDIsXG4gICAgU1RZTEVfTElURVJBTCA9IDMsXG4gICAgU1RZTEVfRk9MREVEICA9IDQsXG4gICAgU1RZTEVfRE9VQkxFICA9IDU7XG5cbi8vIERldGVybWluZXMgd2hpY2ggc2NhbGFyIHN0eWxlcyBhcmUgcG9zc2libGUgYW5kIHJldHVybnMgdGhlIHByZWZlcnJlZCBzdHlsZS5cbi8vIGxpbmVXaWR0aCA9IC0xID0+IG5vIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0ci5sZW5ndGggPiAwLlxuLy8gUG9zdC1jb25kaXRpb25zOlxuLy8gICAgU1RZTEVfUExBSU4gb3IgU1RZTEVfU0lOR0xFID0+IG5vIFxcbiBhcmUgaW4gdGhlIHN0cmluZy5cbi8vICAgIFNUWUxFX0xJVEVSQUwgPT4gbm8gbGluZXMgYXJlIHN1aXRhYmxlIGZvciBmb2xkaW5nIChvciBsaW5lV2lkdGggaXMgLTEpLlxuLy8gICAgU1RZTEVfRk9MREVEID0+IGEgbGluZSA+IGxpbmVXaWR0aCBhbmQgY2FuIGJlIGZvbGRlZCAoYW5kIGxpbmVXaWR0aCAhPSAtMSkuXG5mdW5jdGlvbiBjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBpbmRlbnRQZXJMZXZlbCwgbGluZVdpZHRoLFxuICB0ZXN0QW1iaWd1b3VzVHlwZSwgcXVvdGluZ1R5cGUsIGZvcmNlUXVvdGVzLCBpbmJsb2NrKSB7XG5cbiAgdmFyIGk7XG4gIHZhciBjaGFyID0gMDtcbiAgdmFyIHByZXZDaGFyID0gbnVsbDtcbiAgdmFyIGhhc0xpbmVCcmVhayA9IGZhbHNlO1xuICB2YXIgaGFzRm9sZGFibGVMaW5lID0gZmFsc2U7IC8vIG9ubHkgY2hlY2tlZCBpZiBzaG91bGRUcmFja1dpZHRoXG4gIHZhciBzaG91bGRUcmFja1dpZHRoID0gbGluZVdpZHRoICE9PSAtMTtcbiAgdmFyIHByZXZpb3VzTGluZUJyZWFrID0gLTE7IC8vIGNvdW50IHRoZSBmaXJzdCBsaW5lIGNvcnJlY3RseVxuICB2YXIgcGxhaW4gPSBpc1BsYWluU2FmZUZpcnN0KGNvZGVQb2ludEF0KHN0cmluZywgMCkpXG4gICAgICAgICAgJiYgaXNQbGFpblNhZmVMYXN0KGNvZGVQb2ludEF0KHN0cmluZywgc3RyaW5nLmxlbmd0aCAtIDEpKTtcblxuICBpZiAoc2luZ2xlTGluZU9ubHkgfHwgZm9yY2VRdW90ZXMpIHtcbiAgICAvLyBDYXNlOiBubyBibG9jayBzdHlsZXMuXG4gICAgLy8gQ2hlY2sgZm9yIGRpc2FsbG93ZWQgY2hhcmFjdGVycyB0byBydWxlIG91dCBwbGFpbiBhbmQgc2luZ2xlLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBjaGFyID49IDB4MTAwMDAgPyBpICs9IDIgOiBpKyspIHtcbiAgICAgIGNoYXIgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGkpO1xuICAgICAgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuICAgICAgcGxhaW4gPSBwbGFpbiAmJiBpc1BsYWluU2FmZShjaGFyLCBwcmV2Q2hhciwgaW5ibG9jayk7XG4gICAgICBwcmV2Q2hhciA9IGNoYXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIENhc2U6IGJsb2NrIHN0eWxlcyBwZXJtaXR0ZWQuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGNoYXIgPj0gMHgxMDAwMCA/IGkgKz0gMiA6IGkrKykge1xuICAgICAgY2hhciA9IGNvZGVQb2ludEF0KHN0cmluZywgaSk7XG4gICAgICBpZiAoY2hhciA9PT0gQ0hBUl9MSU5FX0ZFRUQpIHtcbiAgICAgICAgaGFzTGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGxpbmUgY2FuIGJlIGZvbGRlZC5cbiAgICAgICAgaWYgKHNob3VsZFRyYWNrV2lkdGgpIHtcbiAgICAgICAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHxcbiAgICAgICAgICAgIC8vIEZvbGRhYmxlIGxpbmUgPSB0b28gbG9uZywgYW5kIG5vdCBtb3JlLWluZGVudGVkLlxuICAgICAgICAgICAgKGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiZcbiAgICAgICAgICAgICBzdHJpbmdbcHJldmlvdXNMaW5lQnJlYWsgKyAxXSAhPT0gJyAnKTtcbiAgICAgICAgICBwcmV2aW91c0xpbmVCcmVhayA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIsIHByZXZDaGFyLCBpbmJsb2NrKTtcbiAgICAgIHByZXZDaGFyID0gY2hhcjtcbiAgICB9XG4gICAgLy8gaW4gY2FzZSB0aGUgZW5kIGlzIG1pc3NpbmcgYSBcXG5cbiAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHwgKHNob3VsZFRyYWNrV2lkdGggJiZcbiAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJykpO1xuICB9XG4gIC8vIEFsdGhvdWdoIGV2ZXJ5IHN0eWxlIGNhbiByZXByZXNlbnQgXFxuIHdpdGhvdXQgZXNjYXBpbmcsIHByZWZlciBibG9jayBzdHlsZXNcbiAgLy8gZm9yIG11bHRpbGluZSwgc2luY2UgdGhleSdyZSBtb3JlIHJlYWRhYmxlIGFuZCB0aGV5IGRvbid0IGFkZCBlbXB0eSBsaW5lcy5cbiAgLy8gQWxzbyBwcmVmZXIgZm9sZGluZyBhIHN1cGVyLWxvbmcgbGluZS5cbiAgaWYgKCFoYXNMaW5lQnJlYWsgJiYgIWhhc0ZvbGRhYmxlTGluZSkge1xuICAgIC8vIFN0cmluZ3MgaW50ZXJwcmV0YWJsZSBhcyBhbm90aGVyIHR5cGUgaGF2ZSB0byBiZSBxdW90ZWQ7XG4gICAgLy8gZS5nLiB0aGUgc3RyaW5nICd0cnVlJyB2cy4gdGhlIGJvb2xlYW4gdHJ1ZS5cbiAgICBpZiAocGxhaW4gJiYgIWZvcmNlUXVvdGVzICYmICF0ZXN0QW1iaWd1b3VzVHlwZShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gU1RZTEVfUExBSU47XG4gICAgfVxuICAgIHJldHVybiBxdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/IFNUWUxFX0RPVUJMRSA6IFNUWUxFX1NJTkdMRTtcbiAgfVxuICAvLyBFZGdlIGNhc2U6IGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBjYW4gb25seSBoYXZlIG9uZSBkaWdpdC5cbiAgaWYgKGluZGVudFBlckxldmVsID4gOSAmJiBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykpIHtcbiAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICB9XG4gIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyBibG9jayBzdHlsZXMgYXJlIHZhbGlkLlxuICAvLyBQcmVmZXIgbGl0ZXJhbCBzdHlsZSB1bmxlc3Mgd2Ugd2FudCB0byBmb2xkLlxuICBpZiAoIWZvcmNlUXVvdGVzKSB7XG4gICAgcmV0dXJuIGhhc0ZvbGRhYmxlTGluZSA/IFNUWUxFX0ZPTERFRCA6IFNUWUxFX0xJVEVSQUw7XG4gIH1cbiAgcmV0dXJuIHF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gU1RZTEVfRE9VQkxFIDogU1RZTEVfU0lOR0xFO1xufVxuXG4vLyBOb3RlOiBsaW5lIGJyZWFraW5nL2ZvbGRpbmcgaXMgaW1wbGVtZW50ZWQgZm9yIG9ubHkgdGhlIGZvbGRlZCBzdHlsZS5cbi8vIE5CLiBXZSBkcm9wIHRoZSBsYXN0IHRyYWlsaW5nIG5ld2xpbmUgKGlmIGFueSkgb2YgYSByZXR1cm5lZCBibG9jayBzY2FsYXJcbi8vICBzaW5jZSB0aGUgZHVtcGVyIGFkZHMgaXRzIG93biBuZXdsaW5lLiBUaGlzIGFsd2F5cyB3b3Jrczpcbi8vICAgIOKAoiBObyBlbmRpbmcgbmV3bGluZSA9PiB1bmFmZmVjdGVkOyBhbHJlYWR5IHVzaW5nIHN0cmlwIFwiLVwiIGNob21waW5nLlxuLy8gICAg4oCiIEVuZGluZyBuZXdsaW5lICAgID0+IHJlbW92ZWQgdGhlbiByZXN0b3JlZC5cbi8vICBJbXBvcnRhbnRseSwgdGhpcyBrZWVwcyB0aGUgXCIrXCIgY2hvbXAgaW5kaWNhdG9yIGZyb20gZ2FpbmluZyBhbiBleHRyYSBsaW5lLlxuZnVuY3Rpb24gd3JpdGVTY2FsYXIoc3RhdGUsIHN0cmluZywgbGV2ZWwsIGlza2V5LCBpbmJsb2NrKSB7XG4gIHN0YXRlLmR1bXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc3RhdGUucXVvdGluZ1R5cGUgPT09IFFVT1RJTkdfVFlQRV9ET1VCTEUgPyAnXCJcIicgOiBcIicnXCI7XG4gICAgfVxuICAgIGlmICghc3RhdGUubm9Db21wYXRNb2RlKSB7XG4gICAgICBpZiAoREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVguaW5kZXhPZihzdHJpbmcpICE9PSAtMSB8fCBERVBSRUNBVEVEX0JBU0U2MF9TWU5UQVgudGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5xdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/ICgnXCInICsgc3RyaW5nICsgJ1wiJykgOiAoXCInXCIgKyBzdHJpbmcgKyBcIidcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IHN0YXRlLmluZGVudCAqIE1hdGgubWF4KDEsIGxldmVsKTsgLy8gbm8gMC1pbmRlbnQgc2NhbGFyc1xuICAgIC8vIEFzIGluZGVudGF0aW9uIGdldHMgZGVlcGVyLCBsZXQgdGhlIHdpZHRoIGRlY3JlYXNlIG1vbm90b25pY2FsbHlcbiAgICAvLyB0byB0aGUgbG93ZXIgYm91bmQgbWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGltcGxpZXNcbiAgICAvLyAgc3RhdGUubGluZVdpZHRoIOKJpCA0MCArIHN0YXRlLmluZGVudDogd2lkdGggaXMgZml4ZWQgYXQgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vICBzdGF0ZS5saW5lV2lkdGggPiA0MCArIHN0YXRlLmluZGVudDogd2lkdGggZGVjcmVhc2VzIHVudGlsIHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyBUaGlzIGJlaGF2ZXMgYmV0dGVyIHRoYW4gYSBjb25zdGFudCBtaW5pbXVtIHdpZHRoIHdoaWNoIGRpc2FsbG93cyBuYXJyb3dlciBvcHRpb25zLFxuICAgIC8vIG9yIGFuIGluZGVudCB0aHJlc2hvbGQgd2hpY2ggY2F1c2VzIHRoZSB3aWR0aCB0byBzdWRkZW5seSBpbmNyZWFzZS5cbiAgICB2YXIgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoID09PSAtMVxuICAgICAgPyAtMSA6IE1hdGgubWF4KE1hdGgubWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLCBzdGF0ZS5saW5lV2lkdGggLSBpbmRlbnQpO1xuXG4gICAgLy8gV2l0aG91dCBrbm93aW5nIGlmIGtleXMgYXJlIGltcGxpY2l0L2V4cGxpY2l0LCBhc3N1bWUgaW1wbGljaXQgZm9yIHNhZmV0eS5cbiAgICB2YXIgc2luZ2xlTGluZU9ubHkgPSBpc2tleVxuICAgICAgLy8gTm8gYmxvY2sgc3R5bGVzIGluIGZsb3cgbW9kZS5cbiAgICAgIHx8IChzdGF0ZS5mbG93TGV2ZWwgPiAtMSAmJiBsZXZlbCA+PSBzdGF0ZS5mbG93TGV2ZWwpO1xuICAgIGZ1bmN0aW9uIHRlc3RBbWJpZ3VpdHkoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHJpbmcpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY2hvb3NlU2NhbGFyU3R5bGUoc3RyaW5nLCBzaW5nbGVMaW5lT25seSwgc3RhdGUuaW5kZW50LCBsaW5lV2lkdGgsXG4gICAgICB0ZXN0QW1iaWd1aXR5LCBzdGF0ZS5xdW90aW5nVHlwZSwgc3RhdGUuZm9yY2VRdW90ZXMgJiYgIWlza2V5LCBpbmJsb2NrKSkge1xuXG4gICAgICBjYXNlIFNUWUxFX1BMQUlOOlxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgY2FzZSBTVFlMRV9TSU5HTEU6XG4gICAgICAgIHJldHVybiBcIidcIiArIHN0cmluZy5yZXBsYWNlKC8nL2csIFwiJydcIikgKyBcIidcIjtcbiAgICAgIGNhc2UgU1RZTEVfTElURVJBTDpcbiAgICAgICAgcmV0dXJuICd8JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKHN0cmluZywgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0ZPTERFRDpcbiAgICAgICAgcmV0dXJuICc+JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKGZvbGRTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpLCBpbmRlbnQpKTtcbiAgICAgIGNhc2UgU1RZTEVfRE9VQkxFOlxuICAgICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZVN0cmluZyhzdHJpbmcpICsgJ1wiJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ2ltcG9zc2libGUgZXJyb3I6IGludmFsaWQgc2NhbGFyIHN0eWxlJyk7XG4gICAgfVxuICB9KCkpO1xufVxuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyaW5nIGlzIHZhbGlkIGZvciBhIGJsb2NrIHNjYWxhciwgMSA8PSBpbmRlbnRQZXJMZXZlbCA8PSA5LlxuZnVuY3Rpb24gYmxvY2tIZWFkZXIoc3RyaW5nLCBpbmRlbnRQZXJMZXZlbCkge1xuICB2YXIgaW5kZW50SW5kaWNhdG9yID0gbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpID8gU3RyaW5nKGluZGVudFBlckxldmVsKSA6ICcnO1xuXG4gIC8vIG5vdGUgdGhlIHNwZWNpYWwgY2FzZTogdGhlIHN0cmluZyAnXFxuJyBjb3VudHMgYXMgYSBcInRyYWlsaW5nXCIgZW1wdHkgbGluZS5cbiAgdmFyIGNsaXAgPSAgICAgICAgICBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnXFxuJztcbiAgdmFyIGtlZXAgPSBjbGlwICYmIChzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDJdID09PSAnXFxuJyB8fCBzdHJpbmcgPT09ICdcXG4nKTtcbiAgdmFyIGNob21wID0ga2VlcCA/ICcrJyA6IChjbGlwID8gJycgOiAnLScpO1xuXG4gIHJldHVybiBpbmRlbnRJbmRpY2F0b3IgKyBjaG9tcCArICdcXG4nO1xufVxuXG4vLyAoU2VlIHRoZSBub3RlIGZvciB3cml0ZVNjYWxhci4pXG5mdW5jdGlvbiBkcm9wRW5kaW5nTmV3bGluZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nID8gc3RyaW5nLnNsaWNlKDAsIC0xKSA6IHN0cmluZztcbn1cblxuLy8gTm90ZTogYSBsb25nIGxpbmUgd2l0aG91dCBhIHN1aXRhYmxlIGJyZWFrIHBvaW50IHdpbGwgZXhjZWVkIHRoZSB3aWR0aCBsaW1pdC5cbi8vIFByZS1jb25kaXRpb25zOiBldmVyeSBjaGFyIGluIHN0ciBpc1ByaW50YWJsZSwgc3RyLmxlbmd0aCA+IDAsIHdpZHRoID4gMC5cbmZ1bmN0aW9uIGZvbGRTdHJpbmcoc3RyaW5nLCB3aWR0aCkge1xuICAvLyBJbiBmb2xkZWQgc3R5bGUsICRrJCBjb25zZWN1dGl2ZSBuZXdsaW5lcyBvdXRwdXQgYXMgJGsrMSQgbmV3bGluZXPigJRcbiAgLy8gdW5sZXNzIHRoZXkncmUgYmVmb3JlIG9yIGFmdGVyIGEgbW9yZS1pbmRlbnRlZCBsaW5lLCBvciBhdCB0aGUgdmVyeVxuICAvLyBiZWdpbm5pbmcgb3IgZW5kLCBpbiB3aGljaCBjYXNlICRrJCBtYXBzIHRvICRrJC5cbiAgLy8gVGhlcmVmb3JlLCBwYXJzZSBlYWNoIGNodW5rIGFzIG5ld2xpbmUocykgZm9sbG93ZWQgYnkgYSBjb250ZW50IGxpbmUuXG4gIHZhciBsaW5lUmUgPSAvKFxcbispKFteXFxuXSopL2c7XG5cbiAgLy8gZmlyc3QgbGluZSAocG9zc2libHkgYW4gZW1wdHkgbGluZSlcbiAgdmFyIHJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRMRiA9IHN0cmluZy5pbmRleE9mKCdcXG4nKTtcbiAgICBuZXh0TEYgPSBuZXh0TEYgIT09IC0xID8gbmV4dExGIDogc3RyaW5nLmxlbmd0aDtcbiAgICBsaW5lUmUubGFzdEluZGV4ID0gbmV4dExGO1xuICAgIHJldHVybiBmb2xkTGluZShzdHJpbmcuc2xpY2UoMCwgbmV4dExGKSwgd2lkdGgpO1xuICB9KCkpO1xuICAvLyBJZiB3ZSBoYXZlbid0IHJlYWNoZWQgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSB5ZXQsIGRvbid0IGFkZCBhbiBleHRyYSBcXG4uXG4gIHZhciBwcmV2TW9yZUluZGVudGVkID0gc3RyaW5nWzBdID09PSAnXFxuJyB8fCBzdHJpbmdbMF0gPT09ICcgJztcbiAgdmFyIG1vcmVJbmRlbnRlZDtcblxuICAvLyByZXN0IG9mIHRoZSBsaW5lc1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSBsaW5lUmUuZXhlYyhzdHJpbmcpKSkge1xuICAgIHZhciBwcmVmaXggPSBtYXRjaFsxXSwgbGluZSA9IG1hdGNoWzJdO1xuICAgIG1vcmVJbmRlbnRlZCA9IChsaW5lWzBdID09PSAnICcpO1xuICAgIHJlc3VsdCArPSBwcmVmaXhcbiAgICAgICsgKCFwcmV2TW9yZUluZGVudGVkICYmICFtb3JlSW5kZW50ZWQgJiYgbGluZSAhPT0gJydcbiAgICAgICAgPyAnXFxuJyA6ICcnKVxuICAgICAgKyBmb2xkTGluZShsaW5lLCB3aWR0aCk7XG4gICAgcHJldk1vcmVJbmRlbnRlZCA9IG1vcmVJbmRlbnRlZDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEdyZWVkeSBsaW5lIGJyZWFraW5nLlxuLy8gUGlja3MgdGhlIGxvbmdlc3QgbGluZSB1bmRlciB0aGUgbGltaXQgZWFjaCB0aW1lLFxuLy8gb3RoZXJ3aXNlIHNldHRsZXMgZm9yIHRoZSBzaG9ydGVzdCBsaW5lIG92ZXIgdGhlIGxpbWl0LlxuLy8gTkIuIE1vcmUtaW5kZW50ZWQgbGluZXMgKmNhbm5vdCogYmUgZm9sZGVkLCBhcyB0aGF0IHdvdWxkIGFkZCBhbiBleHRyYSBcXG4uXG5mdW5jdGlvbiBmb2xkTGluZShsaW5lLCB3aWR0aCkge1xuICBpZiAobGluZSA9PT0gJycgfHwgbGluZVswXSA9PT0gJyAnKSByZXR1cm4gbGluZTtcblxuICAvLyBTaW5jZSBhIG1vcmUtaW5kZW50ZWQgbGluZSBhZGRzIGEgXFxuLCBicmVha3MgY2FuJ3QgYmUgZm9sbG93ZWQgYnkgYSBzcGFjZS5cbiAgdmFyIGJyZWFrUmUgPSAvIFteIF0vZzsgLy8gbm90ZTogdGhlIG1hdGNoIGluZGV4IHdpbGwgYWx3YXlzIGJlIDw9IGxlbmd0aC0yLlxuICB2YXIgbWF0Y2g7XG4gIC8vIHN0YXJ0IGlzIGFuIGluY2x1c2l2ZSBpbmRleC4gZW5kLCBjdXJyLCBhbmQgbmV4dCBhcmUgZXhjbHVzaXZlLlxuICB2YXIgc3RhcnQgPSAwLCBlbmQsIGN1cnIgPSAwLCBuZXh0ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIC8vIEludmFyaWFudHM6IDAgPD0gc3RhcnQgPD0gbGVuZ3RoLTEuXG4gIC8vICAgMCA8PSBjdXJyIDw9IG5leHQgPD0gbWF4KDAsIGxlbmd0aC0yKS4gY3VyciAtIHN0YXJ0IDw9IHdpZHRoLlxuICAvLyBJbnNpZGUgdGhlIGxvb3A6XG4gIC8vICAgQSBtYXRjaCBpbXBsaWVzIGxlbmd0aCA+PSAyLCBzbyBjdXJyIGFuZCBuZXh0IGFyZSA8PSBsZW5ndGgtMi5cbiAgd2hpbGUgKChtYXRjaCA9IGJyZWFrUmUuZXhlYyhsaW5lKSkpIHtcbiAgICBuZXh0ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gbWFpbnRhaW4gaW52YXJpYW50OiBjdXJyIC0gc3RhcnQgPD0gd2lkdGhcbiAgICBpZiAobmV4dCAtIHN0YXJ0ID4gd2lkdGgpIHtcbiAgICAgIGVuZCA9IChjdXJyID4gc3RhcnQpID8gY3VyciA6IG5leHQ7IC8vIGRlcml2ZSBlbmQgPD0gbGVuZ3RoLTJcbiAgICAgIHJlc3VsdCArPSAnXFxuJyArIGxpbmUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAvLyBza2lwIHRoZSBzcGFjZSB0aGF0IHdhcyBvdXRwdXQgYXMgXFxuXG4gICAgICBzdGFydCA9IGVuZCArIDE7ICAgICAgICAgICAgICAgICAgICAvLyBkZXJpdmUgc3RhcnQgPD0gbGVuZ3RoLTFcbiAgICB9XG4gICAgY3VyciA9IG5leHQ7XG4gIH1cblxuICAvLyBCeSB0aGUgaW52YXJpYW50cywgc3RhcnQgPD0gbGVuZ3RoLTEsIHNvIHRoZXJlIGlzIHNvbWV0aGluZyBsZWZ0IG92ZXIuXG4gIC8vIEl0IGlzIGVpdGhlciB0aGUgd2hvbGUgc3RyaW5nIG9yIGEgcGFydCBzdGFydGluZyBmcm9tIG5vbi13aGl0ZXNwYWNlLlxuICByZXN1bHQgKz0gJ1xcbic7XG4gIC8vIEluc2VydCBhIGJyZWFrIGlmIHRoZSByZW1haW5kZXIgaXMgdG9vIGxvbmcgYW5kIHRoZXJlIGlzIGEgYnJlYWsgYXZhaWxhYmxlLlxuICBpZiAobGluZS5sZW5ndGggLSBzdGFydCA+IHdpZHRoICYmIGN1cnIgPiBzdGFydCkge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0LCBjdXJyKSArICdcXG4nICsgbGluZS5zbGljZShjdXJyICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2Uoc3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5zbGljZSgxKTsgLy8gZHJvcCBleHRyYSBcXG4gam9pbmVyXG59XG5cbi8vIEVzY2FwZXMgYSBkb3VibGUtcXVvdGVkIHN0cmluZy5cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY2hhciA9IDA7XG4gIHZhciBlc2NhcGVTZXE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBjaGFyID49IDB4MTAwMDAgPyBpICs9IDIgOiBpKyspIHtcbiAgICBjaGFyID0gY29kZVBvaW50QXQoc3RyaW5nLCBpKTtcbiAgICBlc2NhcGVTZXEgPSBFU0NBUEVfU0VRVUVOQ0VTW2NoYXJdO1xuXG4gICAgaWYgKCFlc2NhcGVTZXEgJiYgaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdbaV07XG4gICAgICBpZiAoY2hhciA+PSAweDEwMDAwKSByZXN1bHQgKz0gc3RyaW5nW2kgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IGVzY2FwZVNlcSB8fCBlbmNvZGVIZXgoY2hhcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIHZhbHVlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHZhbHVlID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgICAgdmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKG9iamVjdCwgU3RyaW5nKGluZGV4KSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMsIHB1dCBudWxsIGluc3RlYWQgb2YgaW52YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgdmFsdWUsIGZhbHNlLCBmYWxzZSkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG51bGwsIGZhbHNlLCBmYWxzZSkpKSB7XG5cbiAgICAgIGlmIChfcmVzdWx0ICE9PSAnJykgX3Jlc3VsdCArPSAnLCcgKyAoIXN0YXRlLmNvbmRlbnNlRmxvdyA/ICcgJyA6ICcnKTtcbiAgICAgIF9yZXN1bHQgKz0gc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ1snICsgX3Jlc3VsdCArICddJztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnICAgID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICB2YWx1ZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB2YWx1ZSA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIHZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIFN0cmluZyhpbmRleCksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLCBwdXQgbnVsbCBpbnN0ZWFkIG9mIGludmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWUpIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICB3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgbnVsbCwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWUpKSkge1xuXG4gICAgICBpZiAoIWNvbXBhY3QgfHwgX3Jlc3VsdCAhPT0gJycpIHtcbiAgICAgICAgX3Jlc3VsdCArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdWx0ICs9ICctICc7XG4gICAgICB9XG5cbiAgICAgIF9yZXN1bHQgKz0gc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAnW10nOyAvLyBFbXB0eSBzZXF1ZW5jZSBpZiBubyB2YWxpZCB2YWx1ZXMuXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcblxuICAgIHBhaXJCdWZmZXIgPSAnJztcbiAgICBpZiAoX3Jlc3VsdCAhPT0gJycpIHBhaXJCdWZmZXIgKz0gJywgJztcblxuICAgIGlmIChzdGF0ZS5jb25kZW5zZUZsb3cpIHBhaXJCdWZmZXIgKz0gJ1wiJztcblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIG9iamVjdFZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIG9iamVjdEtleSwgb2JqZWN0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KSBwYWlyQnVmZmVyICs9ICc/ICc7XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXAgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJ1wiJyA6ICcnKSArICc6JyArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnJyA6ICcgJyk7XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdFZhbHVlLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICd7JyArIF9yZXN1bHQgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgZXhwbGljaXRQYWlyLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICAvLyBBbGxvdyBzb3J0aW5nIGtleXMgc28gdGhhdCB0aGUgb3V0cHV0IGZpbGUgaXMgZGV0ZXJtaW5pc3RpY1xuICBpZiAoc3RhdGUuc29ydEtleXMgPT09IHRydWUpIHtcbiAgICAvLyBEZWZhdWx0IHNvcnRpbmdcbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhdGUuc29ydEtleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBDdXN0b20gc29ydCBmdW5jdGlvblxuICAgIG9iamVjdEtleUxpc3Quc29ydChzdGF0ZS5zb3J0S2V5cyk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc29ydEtleXMpIHtcbiAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmdcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdzb3J0S2V5cyBtdXN0IGJlIGEgYm9vbGVhbiBvciBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuXG4gICAgaWYgKCFjb21wYWN0IHx8IF9yZXN1bHQgIT09ICcnKSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgICBvYmplY3RWYWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwob2JqZWN0LCBvYmplY3RLZXksIG9iamVjdFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RLZXksIHRydWUsIHRydWUsIHRydWUpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleS5cbiAgICB9XG5cbiAgICBleHBsaWNpdFBhaXIgPSAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB8fFxuICAgICAgICAgICAgICAgICAgIChzdGF0ZS5kdW1wICYmIHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCk7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdFZhbHVlLCB0cnVlLCBleHBsaWNpdFBhaXIpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzonO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAne30nOyAvLyBFbXB0eSBtYXBwaW5nIGlmIG5vIHZhbGlkIHBhaXJzLlxufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGV4cGxpY2l0KSB7XG4gIHZhciBfcmVzdWx0LCB0eXBlTGlzdCwgaW5kZXgsIGxlbmd0aCwgdHlwZSwgc3R5bGU7XG5cbiAgdHlwZUxpc3QgPSBleHBsaWNpdCA/IHN0YXRlLmV4cGxpY2l0VHlwZXMgOiBzdGF0ZS5pbXBsaWNpdFR5cGVzO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0eXBlTGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcblxuICAgIGlmICgodHlwZS5pbnN0YW5jZU9mICB8fCB0eXBlLnByZWRpY2F0ZSkgJiZcbiAgICAgICAgKCF0eXBlLmluc3RhbmNlT2YgfHwgKCh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JykgJiYgKG9iamVjdCBpbnN0YW5jZW9mIHR5cGUuaW5zdGFuY2VPZikpKSAmJlxuICAgICAgICAoIXR5cGUucHJlZGljYXRlICB8fCB0eXBlLnByZWRpY2F0ZShvYmplY3QpKSkge1xuXG4gICAgICBpZiAoZXhwbGljaXQpIHtcbiAgICAgICAgaWYgKHR5cGUubXVsdGkgJiYgdHlwZS5yZXByZXNlbnROYW1lKSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS5yZXByZXNlbnROYW1lKG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUucmVwcmVzZW50KSB7XG4gICAgICAgIHN0eWxlID0gc3RhdGUuc3R5bGVNYXBbdHlwZS50YWddIHx8IHR5cGUuZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbCh0eXBlLnJlcHJlc2VudCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnQob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5yZXByZXNlbnQsIHN0eWxlKSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudFtzdHlsZV0ob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmR1bXAgPSBfcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFNlcmlhbGl6ZXMgYG9iamVjdGAgYW5kIHdyaXRlcyBpdCB0byBnbG9iYWwgYHJlc3VsdGAuXG4vLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXG4vL1xuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCwgaXNrZXksIGlzYmxvY2tzZXEpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwoc3RhdGUuZHVtcCk7XG4gIHZhciBpbmJsb2NrID0gYmxvY2s7XG4gIHZhciB0YWdTdHI7XG5cbiAgaWYgKGJsb2NrKSB7XG4gICAgYmxvY2sgPSAoc3RhdGUuZmxvd0xldmVsIDwgMCB8fCBzdGF0ZS5mbG93TGV2ZWwgPiBsZXZlbCk7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9IHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8IGR1cGxpY2F0ZSB8fCAoc3RhdGUuaW5kZW50ICE9PSAyICYmIGxldmVsID4gMCkpIHtcbiAgICBjb21wYWN0ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZHVwbGljYXRlICYmIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgIHN0YXRlLmR1bXAgPSAnKnJlZl8nICsgZHVwbGljYXRlSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9iamVjdE9yQXJyYXkgJiYgZHVwbGljYXRlICYmICFzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICAgIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgaWYgKGJsb2NrICYmIChPYmplY3Qua2V5cyhzdGF0ZS5kdW1wKS5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIGlmIChibG9jayAmJiAoc3RhdGUuZHVtcC5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIGlmIChzdGF0ZS5ub0FycmF5SW5kZW50ICYmICFpc2Jsb2Nrc2VxICYmIGxldmVsID4gMCkge1xuICAgICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwgLSAxLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgIGlmIChzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwsIGlza2V5LCBpbmJsb2NrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVuZGVmaW5lZF0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5za2lwSW52YWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbigndW5hY2NlcHRhYmxlIGtpbmQgb2YgYW4gb2JqZWN0IHRvIGR1bXAgJyArIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHtcbiAgICAgIC8vIE5lZWQgdG8gZW5jb2RlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCB0aG9zZSBhbGxvd2VkIGJ5IHRoZSBzcGVjOlxuICAgICAgLy9cbiAgICAgIC8vIFszNV0gbnMtZGVjLWRpZ2l0ICAgIDo6PSAgWyN4MzAtI3gzOV0gLyogMC05ICovXG4gICAgICAvLyBbMzZdIG5zLWhleC1kaWdpdCAgICA6Oj0gIG5zLWRlYy1kaWdpdFxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfCBbI3g0MS0jeDQ2XSAvKiBBLUYgKi8gfCBbI3g2MS0jeDY2XSAvKiBhLWYgKi9cbiAgICAgIC8vIFszN10gbnMtYXNjaWktbGV0dGVyIDo6PSAgWyN4NDEtI3g1QV0gLyogQS1aICovIHwgWyN4NjEtI3g3QV0gLyogYS16ICovXG4gICAgICAvLyBbMzhdIG5zLXdvcmQtY2hhciAgICA6Oj0gIG5zLWRlYy1kaWdpdCB8IG5zLWFzY2lpLWxldHRlciB8IOKAnC3igJ1cbiAgICAgIC8vIFszOV0gbnMtdXJpLWNoYXIgICAgIDo6PSAg4oCcJeKAnSBucy1oZXgtZGlnaXQgbnMtaGV4LWRpZ2l0IHwgbnMtd29yZC1jaGFyIHwg4oCcI+KAnVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfCDigJw74oCdIHwg4oCcL+KAnSB8IOKAnD/igJ0gfCDigJw64oCdIHwg4oCcQOKAnSB8IOKAnCbigJ0gfCDigJw94oCdIHwg4oCcK+KAnSB8IOKAnCTigJ0gfCDigJws4oCdXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB8IOKAnF/igJ0gfCDigJwu4oCdIHwg4oCcIeKAnSB8IOKAnH7igJ0gfCDigJwq4oCdIHwg4oCcJ+KAnSB8IOKAnCjigJ0gfCDigJwp4oCdIHwg4oCcW+KAnSB8IOKAnF3igJ1cbiAgICAgIC8vXG4gICAgICAvLyBBbHNvIG5lZWQgdG8gZW5jb2RlICchJyBiZWNhdXNlIGl0IGhhcyBzcGVjaWFsIG1lYW5pbmcgKGVuZCBvZiB0YWcgcHJlZml4KS5cbiAgICAgIC8vXG4gICAgICB0YWdTdHIgPSBlbmNvZGVVUkkoXG4gICAgICAgIHN0YXRlLnRhZ1swXSA9PT0gJyEnID8gc3RhdGUudGFnLnNsaWNlKDEpIDogc3RhdGUudGFnXG4gICAgICApLnJlcGxhY2UoLyEvZywgJyUyMScpO1xuXG4gICAgICBpZiAoc3RhdGUudGFnWzBdID09PSAnIScpIHtcbiAgICAgICAgdGFnU3RyID0gJyEnICsgdGFnU3RyO1xuICAgICAgfSBlbHNlIGlmICh0YWdTdHIuc2xpY2UoMCwgMTgpID09PSAndGFnOnlhbWwub3JnLDIwMDI6Jykge1xuICAgICAgICB0YWdTdHIgPSAnISEnICsgdGFnU3RyLnNsaWNlKDE4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ1N0ciA9ICchPCcgKyB0YWdTdHIgKyAnPic7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmR1bXAgPSB0YWdTdHIgKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKG9iamVjdCwgc3RhdGUpIHtcbiAgdmFyIG9iamVjdHMgPSBbXSxcbiAgICAgIGR1cGxpY2F0ZXNJbmRleGVzID0gW10sXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZHVwbGljYXRlc0luZGV4ZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHN0YXRlLmR1cGxpY2F0ZXMucHVzaChvYmplY3RzW2R1cGxpY2F0ZXNJbmRleGVzW2luZGV4XV0pO1xuICB9XG4gIHN0YXRlLnVzZWREdXBsaWNhdGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpIHtcbiAgdmFyIG9iamVjdEtleUxpc3QsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpZiAob2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoZHVwbGljYXRlc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgIGR1cGxpY2F0ZXNJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3RbaW5kZXhdLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3Rbb2JqZWN0S2V5TGlzdFtpbmRleF1dLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHVtcCQxKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKTtcblxuICBpZiAoIXN0YXRlLm5vUmVmcykgZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhpbnB1dCwgc3RhdGUpO1xuXG4gIHZhciB2YWx1ZSA9IGlucHV0O1xuXG4gIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgIHZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbCh7ICcnOiB2YWx1ZSB9LCAnJywgdmFsdWUpO1xuICB9XG5cbiAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgMCwgdmFsdWUsIHRydWUsIHRydWUpKSByZXR1cm4gc3RhdGUuZHVtcCArICdcXG4nO1xuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGR1bXBfMSA9IGR1bXAkMTtcblxudmFyIGR1bXBlciA9IHtcblx0ZHVtcDogZHVtcF8xXG59O1xuXG5mdW5jdGlvbiByZW5hbWVkKGZyb20sIHRvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiB5YW1sLicgKyBmcm9tICsgJyBpcyByZW1vdmVkIGluIGpzLXlhbWwgNC4gJyArXG4gICAgICAnVXNlIHlhbWwuJyArIHRvICsgJyBpbnN0ZWFkLCB3aGljaCBpcyBub3cgc2FmZSBieSBkZWZhdWx0LicpO1xuICB9O1xufVxuXG5cbnZhciBUeXBlICAgICAgICAgICAgICAgID0gdHlwZTtcbnZhciBTY2hlbWEgICAgICAgICAgICAgID0gc2NoZW1hO1xudmFyIEZBSUxTQUZFX1NDSEVNQSAgICAgPSBmYWlsc2FmZTtcbnZhciBKU09OX1NDSEVNQSAgICAgICAgID0ganNvbjtcbnZhciBDT1JFX1NDSEVNQSAgICAgICAgID0gY29yZTtcbnZhciBERUZBVUxUX1NDSEVNQSAgICAgID0gX2RlZmF1bHQ7XG52YXIgbG9hZCAgICAgICAgICAgICAgICA9IGxvYWRlci5sb2FkO1xudmFyIGxvYWRBbGwgICAgICAgICAgICAgPSBsb2FkZXIubG9hZEFsbDtcbnZhciBkdW1wICAgICAgICAgICAgICAgID0gZHVtcGVyLmR1bXA7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IGV4Y2VwdGlvbjtcblxuLy8gUmUtZXhwb3J0IGFsbCB0eXBlcyBpbiBjYXNlIHVzZXIgd2FudHMgdG8gY3JlYXRlIGN1c3RvbSBzY2hlbWFcbnZhciB0eXBlcyA9IHtcbiAgYmluYXJ5OiAgICBiaW5hcnksXG4gIGZsb2F0OiAgICAgZmxvYXQsXG4gIG1hcDogICAgICAgbWFwLFxuICBudWxsOiAgICAgIF9udWxsLFxuICBwYWlyczogICAgIHBhaXJzLFxuICBzZXQ6ICAgICAgIHNldCxcbiAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gIGJvb2w6ICAgICAgYm9vbCxcbiAgaW50OiAgICAgICBpbnQsXG4gIG1lcmdlOiAgICAgbWVyZ2UsXG4gIG9tYXA6ICAgICAgb21hcCxcbiAgc2VxOiAgICAgICBzZXEsXG4gIHN0cjogICAgICAgc3RyXG59O1xuXG4vLyBSZW1vdmVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMy4wLnhcbnZhciBzYWZlTG9hZCAgICAgICAgICAgID0gcmVuYW1lZCgnc2FmZUxvYWQnLCAnbG9hZCcpO1xudmFyIHNhZmVMb2FkQWxsICAgICAgICAgPSByZW5hbWVkKCdzYWZlTG9hZEFsbCcsICdsb2FkQWxsJyk7XG52YXIgc2FmZUR1bXAgICAgICAgICAgICA9IHJlbmFtZWQoJ3NhZmVEdW1wJywgJ2R1bXAnKTtcblxudmFyIGpzWWFtbCA9IHtcblx0VHlwZTogVHlwZSxcblx0U2NoZW1hOiBTY2hlbWEsXG5cdEZBSUxTQUZFX1NDSEVNQTogRkFJTFNBRkVfU0NIRU1BLFxuXHRKU09OX1NDSEVNQTogSlNPTl9TQ0hFTUEsXG5cdENPUkVfU0NIRU1BOiBDT1JFX1NDSEVNQSxcblx0REVGQVVMVF9TQ0hFTUE6IERFRkFVTFRfU0NIRU1BLFxuXHRsb2FkOiBsb2FkLFxuXHRsb2FkQWxsOiBsb2FkQWxsLFxuXHRkdW1wOiBkdW1wLFxuXHRZQU1MRXhjZXB0aW9uOiBZQU1MRXhjZXB0aW9uLFxuXHR0eXBlczogdHlwZXMsXG5cdHNhZmVMb2FkOiBzYWZlTG9hZCxcblx0c2FmZUxvYWRBbGw6IHNhZmVMb2FkQWxsLFxuXHRzYWZlRHVtcDogc2FmZUR1bXBcbn07XG5cbmV4cG9ydCB7IENPUkVfU0NIRU1BLCBERUZBVUxUX1NDSEVNQSwgRkFJTFNBRkVfU0NIRU1BLCBKU09OX1NDSEVNQSwgU2NoZW1hLCBUeXBlLCBZQU1MRXhjZXB0aW9uLCBqc1lhbWwgYXMgZGVmYXVsdCwgZHVtcCwgbG9hZCwgbG9hZEFsbCwgc2FmZUR1bXAsIHNhZmVMb2FkLCBzYWZlTG9hZEFsbCwgdHlwZXMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/js-yaml/dist/js-yaml.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fmaxlund%2Fprojects%2Ffloze%2Fdocs%2Fpages%2Fconfig%2Fvariables.md&page=%2Fconfig%2Fvariables!":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fmaxlund%2Fprojects%2Ffloze%2Fdocs%2Fpages%2Fconfig%2Fvariables.md&page=%2Fconfig%2Fvariables! ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/config/variables\",\n      function () {\n        return __webpack_require__(/*! ./pages/config/variables.md */ \"(pages-dir-browser)/./pages/config/variables.md\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/config/variables\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcz9hYnNvbHV0ZVBhZ2VQYXRoPSUyRlVzZXJzJTJGbWF4bHVuZCUyRnByb2plY3RzJTJGZmxvemUlMkZkb2NzJTJGcGFnZXMlMkZjb25maWclMkZ2YXJpYWJsZXMubWQmcGFnZT0lMkZjb25maWclMkZ2YXJpYWJsZXMhIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsb0ZBQTZCO0FBQ3BEO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL2NvbmZpZy92YXJpYWJsZXNcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3BhZ2VzL2NvbmZpZy92YXJpYWJsZXMubWRcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL2NvbmZpZy92YXJpYWJsZXNcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fmaxlund%2Fprojects%2Ffloze%2Fdocs%2Fpages%2Fconfig%2Fvariables.md&page=%2Fconfig%2Fvariables!\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/config/variables.md":
/*!***********************************!*\
  !*** ./pages/config/variables.md ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __N_SSG: () => (/* binding */ __N_SSG),\n/* harmony export */   \"default\": () => (/* binding */ MarkdocComponent),\n/* harmony export */   markdoc: () => (/* binding */ markdoc)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-yaml */ \"(pages-dir-browser)/./node_modules/js-yaml/dist/js-yaml.mjs\");\n/* harmony import */ var _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @markdoc/markdoc */ \"(pages-dir-browser)/./node_modules/@markdoc/markdoc/dist/index.mjs\");\n/* harmony import */ var _markdoc_next_js_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @markdoc/next.js/runtime */ \"(pages-dir-browser)/./node_modules/@markdoc/next.js/src/runtime.js\");\n/* harmony import */ var _Users_maxlund_projects_floze_docs_markdoc_tags_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./markdoc/tags.js */ \"(pages-dir-browser)/./markdoc/tags.js\");\n/* harmony import */ var _Users_maxlund_projects_floze_docs_markdoc_nodes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./markdoc/nodes.js */ \"(pages-dir-browser)/./markdoc/nodes.js\");\n\n\n// renderers is imported separately so Markdoc isn't sent to the client\n\n\n/**\n * Schema is imported like this so end-user's code is compiled using build-in babel/webpack configs.\n * This enables typescript/ESnext support\n */ const config = {};\n\n\nconst functions = {};\nconst schema = {\n    tags: (0,_markdoc_next_js_runtime__WEBPACK_IMPORTED_MODULE_2__.defaultObject)(_Users_maxlund_projects_floze_docs_markdoc_tags_js__WEBPACK_IMPORTED_MODULE_3__),\n    nodes: (0,_markdoc_next_js_runtime__WEBPACK_IMPORTED_MODULE_2__.defaultObject)(_Users_maxlund_projects_floze_docs_markdoc_nodes_js__WEBPACK_IMPORTED_MODULE_4__),\n    functions: (0,_markdoc_next_js_runtime__WEBPACK_IMPORTED_MODULE_2__.defaultObject)(functions),\n    ...(0,_markdoc_next_js_runtime__WEBPACK_IMPORTED_MODULE_2__.defaultObject)(config)\n};\nconst tokenizer = new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_5__[\"default\"].Tokenizer({\n    \"allowComments\": true\n});\n/**\n * Source will never change at runtime, so parse happens at the file root\n */ const source = \"---\\ntitle: Variables\\n---\\n\\n# Variables\\n\\nVariables store configuration values that can be referenced throughout your HCL files.\\n\\n## Defining Variables\\n\\n```hcl\\nvariable \\\"api_key\\\" {\\n  secret = true  # Mask value in output\\n}\\n\\nvariable \\\"app_name\\\" {\\n  default = \\\"myapp\\\"  # Optional default value\\n}\\n\\nvariable \\\"max_retries\\\" {\\n  default = 3\\n}\\n```\\n\\n## Attributes\\n\\n| Attribute | Type | Description |\\n|-----------|------|-------------|\\n| `secret` | bool | If true, value is masked in CLI output |\\n| `default` | any | Default value if not set via `squad vars set` |\\n\\n## Setting Values\\n\\nUse the CLI to set variable values:\\n\\n```bash\\nsquad vars set api_key sk-ant-...\\nsquad vars set app_name production-app\\n```\\n\\nValues are stored in `~/.squad/vars.txt`.\\n\\n## Referencing Variables\\n\\nUse `vars.name` to reference a variable:\\n\\n```hcl\\nmodel \\\"anthropic\\\" {\\n  api_key = vars.api_key\\n}\\n\\nagent \\\"assistant\\\" {\\n  personality = \\\"Assistant for ${vars.app_name}\\\"\\n}\\n```\\n\\n## Resolution Order\\n\\n1. Value set via `squad vars set` (stored in `~/.squad/vars.txt`)\\n2. Default value from `variable` block\\n3. Error if neither exists\\n\\n## Best Practices\\n\\n### Secrets\\n\\nAlways mark sensitive values as secrets:\\n\\n```hcl\\nvariable \\\"anthropic_api_key\\\" {\\n  secret = true\\n}\\n\\nvariable \\\"database_password\\\" {\\n  secret = true\\n}\\n```\\n\\n### Defaults for Non-Sensitive Values\\n\\nProvide defaults for convenience:\\n\\n```hcl\\nvariable \\\"environment\\\" {\\n  default = \\\"development\\\"\\n}\\n\\nvariable \\\"log_level\\\" {\\n  default = \\\"info\\\"\\n}\\n```\\n\\n### Naming Convention\\n\\nUse snake_case for variable names:\\n\\n```hcl\\nvariable \\\"anthropic_api_key\\\" { }  # Good\\nvariable \\\"anthropicApiKey\\\" { }    # Avoid\\n```\\n\";\nconst tokens = tokenizer.tokenize(source);\nconst parseOptions = {\n    \"slots\": false\n};\nconst ast = _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_5__[\"default\"].parse(tokens, parseOptions);\n/**\n * Like the AST, frontmatter won't change at runtime, so it is loaded at file root.\n * This unblocks future features, such a per-page dataFetchingFunction.\n */ const frontmatter = ast.attributes.frontmatter ? js_yaml__WEBPACK_IMPORTED_MODULE_1__[\"default\"].load(ast.attributes.frontmatter) : {};\nconst { components } = (0,_markdoc_next_js_runtime__WEBPACK_IMPORTED_MODULE_2__.getSchema)(schema);\nvar __N_SSG = true;\nconst markdoc = {\n    frontmatter\n};\nfunction MarkdocComponent(props) {\n    const markdoc = props.markdoc;\n    // Only execute HMR code in development\n    return _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_5__.renderers.react(markdoc.content, (react__WEBPACK_IMPORTED_MODULE_0___default()), {\n        components: {\n            ...components,\n            // Allows users to override default components at runtime, via their _app\n            ...props.components\n        }\n    });\n}\n_c = MarkdocComponent;\nvar _c;\n$RefreshReg$(_c, \"MarkdocComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbmZpZy92YXJpYWJsZXMubWQiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUNDO0FBQzNCLHVFQUF1RTtBQUNwQjtBQUVlO0FBQ2xFOzs7Q0FHQyxHQUNELE1BQU1NLFNBQVMsQ0FBQztBQUMwRDtBQUNFO0FBQzVFLE1BQU1HLFlBQVksQ0FBQztBQUNuQixNQUFNQyxTQUFTO0lBQ2ZILE1BQU1GLHVFQUFhQSxDQUFDRSwrRUFBSUE7SUFDeEJDLE9BQU9ILHVFQUFhQSxDQUFDRyxnRkFBS0E7SUFDMUJDLFdBQVdKLHVFQUFhQSxDQUFDSTtJQUN6QixHQUFHSix1RUFBYUEsQ0FBQ0MsT0FBTztBQUN4QjtBQUVBLE1BQU1LLFlBQVksSUFBSVQsa0VBQWlCLENBQUM7SUFBQyxpQkFBZ0I7QUFBSTtBQUU3RDs7Q0FFQyxHQUNELE1BQU1XLFNBQVM7QUFFZixNQUFNQyxTQUFTSCxVQUFVSSxRQUFRLENBQUNGO0FBQ2xDLE1BQU1HLGVBQWU7SUFBQyxTQUFRO0FBQUs7QUFDbkMsTUFBTUMsTUFBTWYsOERBQWEsQ0FBQ1ksUUFBUUU7QUFFbEM7OztDQUdDLEdBQ0QsTUFBTUcsY0FBY0YsSUFBSUcsVUFBVSxDQUFDRCxXQUFXLEdBQzFDbEIsb0RBQVMsQ0FBQ2dCLElBQUlHLFVBQVUsQ0FBQ0QsV0FBVyxJQUNwQyxDQUFDO0FBRUwsTUFBTSxFQUFDRyxVQUFVLEVBQVUsR0FBR2xCLG1FQUFTQSxDQUFDTTs7QUFrRGpDLE1BQU1hLFVBQVU7SUFBQ0o7QUFBVyxFQUFFO0FBQ3RCLFNBQVNLLGlCQUFpQkMsS0FBSztJQUM1QyxNQUFNRixVQUFVRSxNQUFNRixPQUFPO0lBQzdCLHVDQUF1QztJQUN2QyxPQUFPcEIsdURBQVNBLENBQUN1QixLQUFLLENBQUNILFFBQVFJLE9BQU8sRUFBRTNCLDhDQUFLQSxFQUFFO1FBQzdDc0IsWUFBWTtZQUNWLEdBQUdBLFVBQVU7WUFDYix5RUFBeUU7WUFDekUsR0FBR0csTUFBTUgsVUFBVTtRQUNyQjtJQUNGO0FBQ0Y7S0FWd0JFIiwic291cmNlcyI6WyIvVXNlcnMvbWF4bHVuZC9wcm9qZWN0cy9mbG96ZS9kb2NzL3BhZ2VzL2NvbmZpZy92YXJpYWJsZXMubWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB5YW1sIGZyb20gJ2pzLXlhbWwnO1xuLy8gcmVuZGVyZXJzIGlzIGltcG9ydGVkIHNlcGFyYXRlbHkgc28gTWFya2RvYyBpc24ndCBzZW50IHRvIHRoZSBjbGllbnRcbmltcG9ydCBNYXJrZG9jLCB7cmVuZGVyZXJzfSBmcm9tICdAbWFya2RvYy9tYXJrZG9jJ1xuXG5pbXBvcnQge2dldFNjaGVtYSwgZGVmYXVsdE9iamVjdH0gZnJvbSAnQG1hcmtkb2MvbmV4dC5qcy9ydW50aW1lJztcbi8qKlxuICogU2NoZW1hIGlzIGltcG9ydGVkIGxpa2UgdGhpcyBzbyBlbmQtdXNlcidzIGNvZGUgaXMgY29tcGlsZWQgdXNpbmcgYnVpbGQtaW4gYmFiZWwvd2VicGFjayBjb25maWdzLlxuICogVGhpcyBlbmFibGVzIHR5cGVzY3JpcHQvRVNuZXh0IHN1cHBvcnRcbiAqL1xuY29uc3QgY29uZmlnID0ge307XG5pbXBvcnQgKiBhcyB0YWdzIGZyb20gJy9Vc2Vycy9tYXhsdW5kL3Byb2plY3RzL2Zsb3plL2RvY3MvbWFya2RvYy90YWdzLmpzJ1xuaW1wb3J0ICogYXMgbm9kZXMgZnJvbSAnL1VzZXJzL21heGx1bmQvcHJvamVjdHMvZmxvemUvZG9jcy9tYXJrZG9jL25vZGVzLmpzJ1xuY29uc3QgZnVuY3Rpb25zID0ge307XG5jb25zdCBzY2hlbWEgPSB7XG50YWdzOiBkZWZhdWx0T2JqZWN0KHRhZ3MpLFxubm9kZXM6IGRlZmF1bHRPYmplY3Qobm9kZXMpLFxuZnVuY3Rpb25zOiBkZWZhdWx0T2JqZWN0KGZ1bmN0aW9ucyksXG4uLi5kZWZhdWx0T2JqZWN0KGNvbmZpZyksXG59O1xuXG5jb25zdCB0b2tlbml6ZXIgPSBuZXcgTWFya2RvYy5Ub2tlbml6ZXIoe1wiYWxsb3dDb21tZW50c1wiOnRydWV9KTtcblxuLyoqXG4gKiBTb3VyY2Ugd2lsbCBuZXZlciBjaGFuZ2UgYXQgcnVudGltZSwgc28gcGFyc2UgaGFwcGVucyBhdCB0aGUgZmlsZSByb290XG4gKi9cbmNvbnN0IHNvdXJjZSA9IFwiLS0tXFxudGl0bGU6IFZhcmlhYmxlc1xcbi0tLVxcblxcbiMgVmFyaWFibGVzXFxuXFxuVmFyaWFibGVzIHN0b3JlIGNvbmZpZ3VyYXRpb24gdmFsdWVzIHRoYXQgY2FuIGJlIHJlZmVyZW5jZWQgdGhyb3VnaG91dCB5b3VyIEhDTCBmaWxlcy5cXG5cXG4jIyBEZWZpbmluZyBWYXJpYWJsZXNcXG5cXG5gYGBoY2xcXG52YXJpYWJsZSBcXFwiYXBpX2tleVxcXCIge1xcbiAgc2VjcmV0ID0gdHJ1ZSAgIyBNYXNrIHZhbHVlIGluIG91dHB1dFxcbn1cXG5cXG52YXJpYWJsZSBcXFwiYXBwX25hbWVcXFwiIHtcXG4gIGRlZmF1bHQgPSBcXFwibXlhcHBcXFwiICAjIE9wdGlvbmFsIGRlZmF1bHQgdmFsdWVcXG59XFxuXFxudmFyaWFibGUgXFxcIm1heF9yZXRyaWVzXFxcIiB7XFxuICBkZWZhdWx0ID0gM1xcbn1cXG5gYGBcXG5cXG4jIyBBdHRyaWJ1dGVzXFxuXFxufCBBdHRyaWJ1dGUgfCBUeXBlIHwgRGVzY3JpcHRpb24gfFxcbnwtLS0tLS0tLS0tLXwtLS0tLS18LS0tLS0tLS0tLS0tLXxcXG58IGBzZWNyZXRgIHwgYm9vbCB8IElmIHRydWUsIHZhbHVlIGlzIG1hc2tlZCBpbiBDTEkgb3V0cHV0IHxcXG58IGBkZWZhdWx0YCB8IGFueSB8IERlZmF1bHQgdmFsdWUgaWYgbm90IHNldCB2aWEgYHNxdWFkIHZhcnMgc2V0YCB8XFxuXFxuIyMgU2V0dGluZyBWYWx1ZXNcXG5cXG5Vc2UgdGhlIENMSSB0byBzZXQgdmFyaWFibGUgdmFsdWVzOlxcblxcbmBgYGJhc2hcXG5zcXVhZCB2YXJzIHNldCBhcGlfa2V5IHNrLWFudC0uLi5cXG5zcXVhZCB2YXJzIHNldCBhcHBfbmFtZSBwcm9kdWN0aW9uLWFwcFxcbmBgYFxcblxcblZhbHVlcyBhcmUgc3RvcmVkIGluIGB+Ly5zcXVhZC92YXJzLnR4dGAuXFxuXFxuIyMgUmVmZXJlbmNpbmcgVmFyaWFibGVzXFxuXFxuVXNlIGB2YXJzLm5hbWVgIHRvIHJlZmVyZW5jZSBhIHZhcmlhYmxlOlxcblxcbmBgYGhjbFxcbm1vZGVsIFxcXCJhbnRocm9waWNcXFwiIHtcXG4gIGFwaV9rZXkgPSB2YXJzLmFwaV9rZXlcXG59XFxuXFxuYWdlbnQgXFxcImFzc2lzdGFudFxcXCIge1xcbiAgcGVyc29uYWxpdHkgPSBcXFwiQXNzaXN0YW50IGZvciAke3ZhcnMuYXBwX25hbWV9XFxcIlxcbn1cXG5gYGBcXG5cXG4jIyBSZXNvbHV0aW9uIE9yZGVyXFxuXFxuMS4gVmFsdWUgc2V0IHZpYSBgc3F1YWQgdmFycyBzZXRgIChzdG9yZWQgaW4gYH4vLnNxdWFkL3ZhcnMudHh0YClcXG4yLiBEZWZhdWx0IHZhbHVlIGZyb20gYHZhcmlhYmxlYCBibG9ja1xcbjMuIEVycm9yIGlmIG5laXRoZXIgZXhpc3RzXFxuXFxuIyMgQmVzdCBQcmFjdGljZXNcXG5cXG4jIyMgU2VjcmV0c1xcblxcbkFsd2F5cyBtYXJrIHNlbnNpdGl2ZSB2YWx1ZXMgYXMgc2VjcmV0czpcXG5cXG5gYGBoY2xcXG52YXJpYWJsZSBcXFwiYW50aHJvcGljX2FwaV9rZXlcXFwiIHtcXG4gIHNlY3JldCA9IHRydWVcXG59XFxuXFxudmFyaWFibGUgXFxcImRhdGFiYXNlX3Bhc3N3b3JkXFxcIiB7XFxuICBzZWNyZXQgPSB0cnVlXFxufVxcbmBgYFxcblxcbiMjIyBEZWZhdWx0cyBmb3IgTm9uLVNlbnNpdGl2ZSBWYWx1ZXNcXG5cXG5Qcm92aWRlIGRlZmF1bHRzIGZvciBjb252ZW5pZW5jZTpcXG5cXG5gYGBoY2xcXG52YXJpYWJsZSBcXFwiZW52aXJvbm1lbnRcXFwiIHtcXG4gIGRlZmF1bHQgPSBcXFwiZGV2ZWxvcG1lbnRcXFwiXFxufVxcblxcbnZhcmlhYmxlIFxcXCJsb2dfbGV2ZWxcXFwiIHtcXG4gIGRlZmF1bHQgPSBcXFwiaW5mb1xcXCJcXG59XFxuYGBgXFxuXFxuIyMjIE5hbWluZyBDb252ZW50aW9uXFxuXFxuVXNlIHNuYWtlX2Nhc2UgZm9yIHZhcmlhYmxlIG5hbWVzOlxcblxcbmBgYGhjbFxcbnZhcmlhYmxlIFxcXCJhbnRocm9waWNfYXBpX2tleVxcXCIgeyB9ICAjIEdvb2RcXG52YXJpYWJsZSBcXFwiYW50aHJvcGljQXBpS2V5XFxcIiB7IH0gICAgIyBBdm9pZFxcbmBgYFxcblwiO1xuY29uc3QgZmlsZXBhdGggPSBcIi9jb25maWcvdmFyaWFibGVzLm1kXCI7XG5jb25zdCB0b2tlbnMgPSB0b2tlbml6ZXIudG9rZW5pemUoc291cmNlKTtcbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHtcInNsb3RzXCI6ZmFsc2V9O1xuY29uc3QgYXN0ID0gTWFya2RvYy5wYXJzZSh0b2tlbnMsIHBhcnNlT3B0aW9ucyk7XG5cbi8qKlxuICogTGlrZSB0aGUgQVNULCBmcm9udG1hdHRlciB3b24ndCBjaGFuZ2UgYXQgcnVudGltZSwgc28gaXQgaXMgbG9hZGVkIGF0IGZpbGUgcm9vdC5cbiAqIFRoaXMgdW5ibG9ja3MgZnV0dXJlIGZlYXR1cmVzLCBzdWNoIGEgcGVyLXBhZ2UgZGF0YUZldGNoaW5nRnVuY3Rpb24uXG4gKi9cbmNvbnN0IGZyb250bWF0dGVyID0gYXN0LmF0dHJpYnV0ZXMuZnJvbnRtYXR0ZXJcbiAgPyB5YW1sLmxvYWQoYXN0LmF0dHJpYnV0ZXMuZnJvbnRtYXR0ZXIpXG4gIDoge307XG5cbmNvbnN0IHtjb21wb25lbnRzLCAuLi5yZXN0fSA9IGdldFNjaGVtYShzY2hlbWEpXG5cbmFzeW5jIGZ1bmN0aW9uIGdldE1hcmtkb2NEYXRhKGNvbnRleHQgPSB7fSkge1xuICBjb25zdCBwYXJ0aWFscyA9IHt9O1xuXG4gIC8vIEVuc3VyZSBOb2RlLnRyYW5zZm9ybUNoaWxkcmVuIGlzIGF2YWlsYWJsZVxuICBPYmplY3Qua2V5cyhwYXJ0aWFscykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgdG9rZW5zID0gdG9rZW5pemVyLnRva2VuaXplKHBhcnRpYWxzW2tleV0pO1xuICAgIHBhcnRpYWxzW2tleV0gPSBNYXJrZG9jLnBhcnNlKHRva2VucywgcGFyc2VPcHRpb25zKTtcbiAgfSk7XG5cbiAgY29uc3QgY2ZnID0ge1xuICAgIC4uLnJlc3QsXG4gICAgdmFyaWFibGVzOiB7XG4gICAgICAuLi4ocmVzdCA/IHJlc3QudmFyaWFibGVzIDoge30pLFxuICAgICAgLy8gdXNlciBjYW4ndCBvdmVycmlkZSB0aGlzIG5hbWVzcGFjZVxuICAgICAgbWFya2RvYzoge2Zyb250bWF0dGVyfSxcbiAgICAgIC8vIEFsbG93cyB1c2VycyB0byBlamVjdCBmcm9tIE1hcmtkb2MgcmVuZGVyaW5nIGFuZCBwYXNzIGluIGR5bmFtaWMgdmFyaWFibGVzIHZpYSBnZXRTZXJ2ZXJTaWRlUHJvcHNcbiAgICAgIC4uLihjb250ZXh0LnZhcmlhYmxlcyB8fCB7fSlcbiAgICB9LFxuICAgIHBhcnRpYWxzLFxuICAgIHNvdXJjZSxcbiAgfTtcblxuICAvKipcbiAgICogdHJhbnNmb3JtIG11c3QgYmUgY2FsbGVkIGluIGRhdGFGZXRjaGluZ0Z1bmN0aW9uIHRvIHN1cHBvcnQgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHdoaWxlXG4gICAqIGFjY2Vzc2luZyB2YXJpYWJsZXMgb24gdGhlIHNlcnZlclxuICAgKi9cbiAgY29uc3QgY29udGVudCA9IGF3YWl0IE1hcmtkb2MudHJhbnNmb3JtKGFzdCwgY2ZnKTtcblxuICAvLyBSZW1vdmVzIHVuZGVmaW5lZFxuICByZXR1cm4gSlNPTi5wYXJzZShcbiAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBjb250ZW50LFxuICAgICAgZnJvbnRtYXR0ZXIsXG4gICAgICBmaWxlOiB7XG4gICAgICAgIHBhdGg6IGZpbGVwYXRoLFxuICAgICAgfSxcbiAgICB9KVxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RhdGljUHJvcHMoY29udGV4dCkge1xuICByZXR1cm4ge1xuICAgIHByb3BzOiB7XG4gICAgICBtYXJrZG9jOiBhd2FpdCBnZXRNYXJrZG9jRGF0YShjb250ZXh0KSxcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgbWFya2RvYyA9IHtmcm9udG1hdHRlcn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXJrZG9jQ29tcG9uZW50KHByb3BzKSB7XG4gIGNvbnN0IG1hcmtkb2MgPSBwcm9wcy5tYXJrZG9jO1xuICAvLyBPbmx5IGV4ZWN1dGUgSE1SIGNvZGUgaW4gZGV2ZWxvcG1lbnRcbiAgcmV0dXJuIHJlbmRlcmVycy5yZWFjdChtYXJrZG9jLmNvbnRlbnQsIFJlYWN0LCB7XG4gICAgY29tcG9uZW50czoge1xuICAgICAgLi4uY29tcG9uZW50cyxcbiAgICAgIC8vIEFsbG93cyB1c2VycyB0byBvdmVycmlkZSBkZWZhdWx0IGNvbXBvbmVudHMgYXQgcnVudGltZSwgdmlhIHRoZWlyIF9hcHBcbiAgICAgIC4uLnByb3BzLmNvbXBvbmVudHMsXG4gICAgfSxcbiAgfSk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ5YW1sIiwiTWFya2RvYyIsInJlbmRlcmVycyIsImdldFNjaGVtYSIsImRlZmF1bHRPYmplY3QiLCJjb25maWciLCJ0YWdzIiwibm9kZXMiLCJmdW5jdGlvbnMiLCJzY2hlbWEiLCJ0b2tlbml6ZXIiLCJUb2tlbml6ZXIiLCJzb3VyY2UiLCJ0b2tlbnMiLCJ0b2tlbml6ZSIsInBhcnNlT3B0aW9ucyIsImFzdCIsInBhcnNlIiwiZnJvbnRtYXR0ZXIiLCJhdHRyaWJ1dGVzIiwibG9hZCIsImNvbXBvbmVudHMiLCJtYXJrZG9jIiwiTWFya2RvY0NvbXBvbmVudCIsInByb3BzIiwicmVhY3QiLCJjb250ZW50Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/config/variables.md\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["pages/_app","main"], () => (__webpack_exec__("(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fmaxlund%2Fprojects%2Ffloze%2Fdocs%2Fpages%2Fconfig%2Fvariables.md&page=%2Fconfig%2Fvariables!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);